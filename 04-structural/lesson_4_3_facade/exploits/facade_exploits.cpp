#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <cstring>

// ============================================================================
// ЭКСПЛОИТЫ ДЛЯ FACADE
// ============================================================================

// TODO: Добавить комментарии на русском языке
// TODO: Создать более сложные эксплоиты
// TODO: Добавить обход защитных механизмов

// Уязвимый Facade для демонстрации
class VulnerableFacade {
private:
    void* subsystem1;
    void* subsystem2;
    void* subsystem3;
    char* sensitiveData;
    size_t dataSize;
    
    VulnerableFacade() : subsystem1(nullptr), subsystem2(nullptr), subsystem3(nullptr), 
                        sensitiveData(nullptr), dataSize(0) {
        std::cout << "VulnerableFacade создан в потоке " << std::this_thread::get_id() << std::endl;
    }
    
public:
    static VulnerableFacade& getInstance() {
        static VulnerableFacade instance;
        return instance;
    }
    
    // УЯЗВИМОСТЬ: Небезопасная инициализация подсистем
    void initializeSubsystems() {
        // УЯЗВИМОСТЬ: Небезопасное выделение памяти
        subsystem1 = new char[1024];
        subsystem2 = new char[2048];
        subsystem3 = new char[4096];
        
        // УЯЗВИМОСТЬ: Хранение чувствительных данных в открытом виде
        sensitiveData = new char[512];
        strcpy(sensitiveData, "Sensitive password: admin123");
        dataSize = strlen(sensitiveData);
    }
    
    // УЯЗВИМОСТЬ: Возврат указателя на чувствительные данные
    char* getSensitiveData() {
        return sensitiveData;
    }
    
    // УЯЗВИМОСТЬ: Небезопасная обработка подсистем
    void processRequest(const char* request) {
        if (subsystem1) {
            // УЯЗВИМОСТЬ: Небезопасное копирование
            memcpy(subsystem1, request, strlen(request));
        }
        
        if (subsystem2) {
            // УЯЗВИМОСТЬ: Может произойти переполнение
            strcpy(static_cast<char*>(subsystem2), request);
        }
        
        if (subsystem3) {
            // УЯЗВИМОСТЬ: Небезопасная обработка
            memcpy(subsystem3, sensitiveData, dataSize);
        }
    }
    
    // УЯЗВИМОСТЬ: Возврат указателей на внутренние данные
    void* getSubsystem1() { return subsystem1; }
    void* getSubsystem2() { return subsystem2; }
    void* getSubsystem3() { return subsystem3; }
    
    ~VulnerableFacade() {
        delete[] static_cast<char*>(subsystem1);
        delete[] static_cast<char*>(subsystem2);
        delete[] static_cast<char*>(subsystem3);
        delete[] sensitiveData;
        std::cout << "VulnerableFacade уничтожен" << std::endl;
    }
};

// ============================================================================
// ЭКСПЛОИТ 1: INFORMATION DISCLOSURE ДЛЯ ПОЛУЧЕНИЯ ЧУВСТВИТЕЛЬНЫХ ДАННЫХ
// ============================================================================

void exploitInformationDisclosure() {
    std::cout << "\n=== ЭКСПЛОИТ 1: INFORMATION DISCLOSURE ===" << std::endl;
    
    auto& facade = VulnerableFacade::getInstance();
    facade.initializeSubsystems();
    
    // УЯЗВИМОСТЬ: Получение доступа к чувствительным данным
    char* sensitiveData = facade.getSensitiveData();
    if (sensitiveData) {
        std::cout << "Получены чувствительные данные: " << sensitiveData << std::endl;
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Information disclosure достигнут!" << std::endl;
    }
    
    // УЯЗВИМОСТЬ: Получение доступа к подсистемам
    void* subsystem1 = facade.getSubsystem1();
    void* subsystem2 = facade.getSubsystem2();
    void* subsystem3 = facade.getSubsystem3();
    
    std::cout << "Получен доступ к подсистемам:" << std::endl;
    std::cout << "Subsystem1: " << subsystem1 << std::endl;
    std::cout << "Subsystem2: " << subsystem2 << std::endl;
    std::cout << "Subsystem3: " << subsystem3 << std::endl;
    
    // Попытка чтения данных из подсистем
    if (subsystem1) {
        char* data = static_cast<char*>(subsystem1);
        std::cout << "Данные из Subsystem1: " << data << std::endl;
    }
}

// ============================================================================
// ЭКСПЛОИТ 2: BUFFER OVERFLOW ЧЕРЕЗ ОБРАБОТКУ ЗАПРОСОВ
// ============================================================================

class BufferOverflowFacade {
private:
    char* requestBuffer;
    size_t bufferSize;
    size_t currentSize;
    
public:
    BufferOverflowFacade() : requestBuffer(nullptr), bufferSize(0), currentSize(0) {
        std::cout << "BufferOverflowFacade создан" << std::endl;
    }
    
    // УЯЗВИМОСТЬ: Небезопасная обработка запросов
    void processRequest(const char* request, size_t length) {
        // УЯЗВИМОСТЬ: Нет проверки переполнения буфера
        if (currentSize + length > bufferSize) {
            bufferSize = currentSize + length;
            char* newBuffer = new char[bufferSize];
            if (requestBuffer) {
                memcpy(newBuffer, requestBuffer, currentSize);
                delete[] requestBuffer;
            }
            requestBuffer = newBuffer;
        }
        
        // УЯЗВИМОСТЬ: Может произойти переполнение
        memcpy(requestBuffer + currentSize, request, length);
        currentSize += length;
    }
    
    // УЯЗВИМОСТЬ: Возврат указателя на внутренние данные
    char* getRequestBuffer() {
        return requestBuffer;
    }
    
    size_t getBufferSize() const {
        return bufferSize;
    }
    
    size_t getCurrentSize() const {
        return currentSize;
    }
    
    ~BufferOverflowFacade() {
        delete[] requestBuffer;
        std::cout << "BufferOverflowFacade уничтожен" << std::endl;
    }
};

void exploitBufferOverflow() {
    std::cout << "\n=== ЭКСПЛОИТ 2: BUFFER OVERFLOW ===" << std::endl;
    
    BufferOverflowFacade facade;
    
    // Нормальное использование
    facade.processRequest("Hello", 5);
    std::cout << "Обработан запрос размером 5 байт" << std::endl;
    
    // УЯЗВИМОСТЬ: Попытка обработки очень больших данных
    std::string largeRequest(1000000, 'A');
    facade.processRequest(largeRequest.c_str(), largeRequest.length());
    
    std::cout << "Обработан запрос размером: " << facade.getCurrentSize() << std::endl;
    std::cout << "Размер буфера: " << facade.getBufferSize() << std::endl;
    
    // Попытка получить доступ к буферу
    char* buffer = facade.getRequestBuffer();
    if (buffer) {
        std::cout << "Получен доступ к буферу" << std::endl;
        std::cout << "Первые 50 символов: ";
        for (int i = 0; i < 50 && i < facade.getCurrentSize(); ++i) {
            std::cout << buffer[i];
        }
        std::cout << std::endl;
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Buffer overflow достигнут!" << std::endl;
    }
}

// ============================================================================
// ЭКСПЛОИТ 3: USE-AFTER-FREE АТАКА
// ============================================================================

class UseAfterFreeFacade {
private:
    void* subsystem1;
    void* subsystem2;
    bool isValid;
    
public:
    UseAfterFreeFacade() : subsystem1(nullptr), subsystem2(nullptr), isValid(false) {
        std::cout << "UseAfterFreeFacade создан" << std::endl;
    }
    
    void initializeSubsystems() {
        subsystem1 = new char[1024];
        subsystem2 = new char[2048];
        isValid = true;
    }
    
    // УЯЗВИМОСТЬ: Use-after-free при освобождении подсистем
    void releaseSubsystem1() {
        delete[] static_cast<char*>(subsystem1);
        subsystem1 = nullptr;
        // УЯЗВИМОСТЬ: Не обнуляем указатель
    }
    
    // УЯЗВИМОСТЬ: Возврат указателя на освобожденную память
    void* getSubsystem1() {
        return subsystem1; // Может быть dangling pointer
    }
    
    bool isSubsystem1Valid() const {
        return isValid && subsystem1 != nullptr;
    }
    
    void processRequest(const char* request) {
        if (isValid && subsystem1) {
            // УЯЗВИМОСТЬ: Может произойти use-after-free
            strcpy(static_cast<char*>(subsystem1), request);
        }
        
        if (subsystem2) {
            strcpy(static_cast<char*>(subsystem2), request);
        }
    }
    
    ~UseAfterFreeFacade() {
        delete[] static_cast<char*>(subsystem1);
        delete[] static_cast<char*>(subsystem2);
        std::cout << "UseAfterFreeFacade уничтожен" << std::endl;
    }
};

void exploitUseAfterFree() {
    std::cout << "\n=== ЭКСПЛОИТ 3: USE-AFTER-FREE ===" << std::endl;
    
    UseAfterFreeFacade facade;
    facade.initializeSubsystems();
    
    // Освобождаем подсистему
    facade.releaseSubsystem1();
    std::cout << "Подсистема 1 освобождена" << std::endl;
    
    // УЯЗВИМОСТЬ: Попытка использования после освобождения
    void* subsystem1 = facade.getSubsystem1();
    if (subsystem1) {
        std::cout << "Подсистема 1 все еще доступна (dangling pointer)" << std::endl;
        std::cout << "Валидность: " << (facade.isSubsystem1Valid() ? "Да" : "Нет") << std::endl;
        
        // Попытка обработки запроса
        facade.processRequest("Test request for exploitation");
        
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Use-After-Free достигнут!" << std::endl;
    }
}

// ============================================================================
// ЭКСПЛОИТ 4: INTEGER OVERFLOW ДЛЯ ОБХОДА ПРОВЕРОК
// ============================================================================

void exploitIntegerOverflow() {
    std::cout << "\n=== ЭКСПЛОИТ 4: INTEGER OVERFLOW ===" << std::endl;
    
    auto& facade = VulnerableFacade::getInstance();
    
    // УЯЗВИМОСТЬ: Integer overflow
    size_t largeCount = SIZE_MAX - 100;
    
    std::cout << "Попытка обработать " << largeCount << " запросов" << std::endl;
    
    // Создаем данные для overflow
    std::vector<char> overflowData(1000);
    std::fill(overflowData.begin(), overflowData.end(), 'X');
    
    // Попытка вызвать overflow
    try {
        for (size_t i = 0; i < largeCount; ++i) {
            facade.processRequest(overflowData.data());
        }
        
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Integer overflow достигнут!" << std::endl;
    } catch (...) {
        std::cout << "Произошло исключение при обработке запросов" << std::endl;
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Integer overflow достигнут!" << std::endl;
    }
}

// ============================================================================
// ОСНОВНАЯ ФУНКЦИЯ
// ============================================================================

int main() {
    std::cout << "=== ДЕМОНСТРАЦИЯ ЭКСПЛОИТОВ ДЛЯ FACADE ===" << std::endl;
    std::cout << "ВНИМАНИЕ: Этот код содержит эксплоиты для образовательных целей!" << std::endl;
    
    // Запуск различных эксплоитов
    exploitInformationDisclosure();
    exploitBufferOverflow();
    exploitUseAfterFree();
    exploitIntegerOverflow();
    
    std::cout << "\n=== РЕКОМЕНДАЦИИ ПО ЗАЩИТЕ ===" << std::endl;
    std::cout << "1. Шифруйте чувствительные данные" << std::endl;
    std::cout << "2. Используйте RAII для управления ресурсами" << std::endl;
    std::cout << "3. Проверяйте валидность указателей" << std::endl;
    std::cout << "4. Валидируйте входные данные" << std::endl;
    std::cout << "5. Используйте умные указатели" << std::endl;
    std::cout << "6. Регулярно анализируйте код с помощью инструментов безопасности" << std::endl;
    
    return 0;
}