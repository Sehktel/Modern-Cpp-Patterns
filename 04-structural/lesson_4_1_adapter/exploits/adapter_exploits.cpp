#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <cstring>

// ============================================================================
// ЭКСПЛОИТЫ ДЛЯ ADAPTER
// ============================================================================

// TODO: Добавить комментарии на русском языке
// TODO: Создать более сложные эксплоиты
// TODO: Добавить обход защитных механизмов

// Уязвимый Adapter для демонстрации
class VulnerableAdapter {
private:
    void* adaptedObject;
    size_t objectSize;
    bool isValid;
    
    VulnerableAdapter() : adaptedObject(nullptr), objectSize(0), isValid(false) {
        std::cout << "VulnerableAdapter создан в потоке " << std::this_thread::get_id() << std::endl;
    }
    
public:
    static VulnerableAdapter& getInstance() {
        static VulnerableAdapter instance;
        return instance;
    }
    
    // УЯЗВИМОСТЬ: Небезопасная адаптация объекта
    template<typename T>
    void adapt(T* obj) {
        adaptedObject = static_cast<void*>(obj);
        objectSize = sizeof(T);
        isValid = true;
    }
    
    // УЯЗВИМОСТЬ: Небезопасное получение адаптированного объекта
    template<typename T>
    T* getAdapted() {
        if (!isValid) {
            return nullptr;
        }
        return static_cast<T*>(adaptedObject);
    }
    
    void* getRawObject() {
        return adaptedObject;
    }
    
    bool isValidObject() const {
        return isValid;
    }
    
    ~VulnerableAdapter() {
        std::cout << "VulnerableAdapter уничтожен" << std::endl;
    }
};

// ============================================================================
// ЭКСПЛОИТ 1: TYPE CONFUSION ДЛЯ ПОЛУЧЕНИЯ КОНТРОЛЯ
// ============================================================================

void exploitTypeConfusion() {
    std::cout << "\n=== ЭКСПЛОИТ 1: TYPE CONFUSION ===" << std::endl;
    
    auto& adapter = VulnerableAdapter::getInstance();
    
    // Создаем объект одного типа
    int* intObj = new int(0x41414141); // 'AAAA'
    adapter.adapt(intObj);
    
    std::cout << "Адаптирован int объект со значением: " << std::hex << *intObj << std::dec << std::endl;
    
    // УЯЗВИМОСТЬ: Получаем объект как другой тип
    char* charObj = adapter.getAdapted<char>();
    if (charObj) {
        std::cout << "Получен как char: ";
        for (int i = 0; i < sizeof(int); ++i) {
            std::cout << charObj[i];
        }
        std::cout << std::endl;
    }
    
    // УЯЗВИМОСТЬ: Получаем как указатель на функцию
    void (**funcPtr)() = adapter.getAdapted<void (**)()>();
    if (funcPtr) {
        std::cout << "Получен как указатель на функцию: " << funcPtr << std::endl;
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Type confusion достигнут!" << std::endl;
    }
    
    delete intObj;
}

// ============================================================================
// ЭКСПЛОИТ 2: BUFFER OVERFLOW ЧЕРЕЗ АДАПТАЦИЮ ДАННЫХ
// ============================================================================

class CorruptibleAdapter {
private:
    char* buffer;
    size_t bufferSize;
    size_t currentSize;
    
public:
    CorruptibleAdapter() : buffer(nullptr), bufferSize(0), currentSize(0) {
        std::cout << "CorruptibleAdapter создан" << std::endl;
    }
    
    void adaptData(const char* data, size_t length) {
        if (currentSize + length > bufferSize) {
            bufferSize = currentSize + length;
            char* newBuffer = new char[bufferSize];
            if (buffer) {
                memcpy(newBuffer, buffer, currentSize);
                delete[] buffer;
            }
            buffer = newBuffer;
        }
        
        memcpy(buffer + currentSize, data, length);
        currentSize += length;
    }
    
    char* getBuffer() {
        return buffer;
    }
    
    size_t getSize() const {
        return currentSize;
    }
    
    ~CorruptibleAdapter() {
        delete[] buffer;
        std::cout << "CorruptibleAdapter уничтожен" << std::endl;
    }
};

void exploitBufferOverflow() {
    std::cout << "\n=== ЭКСПЛОИТ 2: BUFFER OVERFLOW ===" << std::endl;
    
    CorruptibleAdapter adapter;
    
    // Нормальное использование
    adapter.adaptData("Hello", 5);
    std::cout << "Адаптированы данные размером: " << adapter.getSize() << std::endl;
    
    // УЯЗВИМОСТЬ: Попытка адаптировать очень большие данные
    std::string largeData(1000000, 'A');
    adapter.adaptData(largeData.c_str(), largeData.length());
    
    std::cout << "Адаптированы большие данные размером: " << adapter.getSize() << std::endl;
    
    // Попытка получить доступ к буферу
    char* buffer = adapter.getBuffer();
    if (buffer) {
        std::cout << "Получен доступ к буферу" << std::endl;
        std::cout << "Первые 50 символов: ";
        for (int i = 0; i < 50 && i < adapter.getSize(); ++i) {
            std::cout << buffer[i];
        }
        std::cout << std::endl;
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Buffer overflow достигнут!" << std::endl;
    }
}

// ============================================================================
// ЭКСПЛОИТ 3: USE-AFTER-FREE АТАКА
// ============================================================================

class UseAfterFreeAdapter {
private:
    void* adaptedObject;
    bool isOwned;
    bool isValid;
    
public:
    UseAfterFreeAdapter() : adaptedObject(nullptr), isOwned(false), isValid(false) {
        std::cout << "UseAfterFreeAdapter создан" << std::endl;
    }
    
    void adaptWithOwnership(void* obj) {
        adaptedObject = obj;
        isOwned = true;
        isValid = true;
    }
    
    void release() {
        if (isOwned && adaptedObject) {
            delete[] static_cast<char*>(adaptedObject);
            adaptedObject = nullptr;
            isOwned = false;
            isValid = false;
        }
    }
    
    void* getObject() {
        return adaptedObject;
    }
    
    bool isObjectValid() const {
        return isValid;
    }
    
    ~UseAfterFreeAdapter() {
        if (isOwned && adaptedObject) {
            delete[] static_cast<char*>(adaptedObject);
        }
        std::cout << "UseAfterFreeAdapter уничтожен" << std::endl;
    }
};

void exploitUseAfterFree() {
    std::cout << "\n=== ЭКСПЛОИТ 3: USE-AFTER-FREE ===" << std::endl;
    
    UseAfterFreeAdapter adapter;
    
    // Создаем объект
    char* obj = new char[1024];
    strcpy(obj, "Adapted object data for exploitation");
    
    // Адаптируем с передачей владения
    adapter.adaptWithOwnership(obj);
    std::cout << "Объект адаптирован с передачей владения" << std::endl;
    
    // Освобождаем объект
    adapter.release();
    std::cout << "Объект освобожден" << std::endl;
    
    // УЯЗВИМОСТЬ: Попытка использовать после освобождения
    void* danglingObj = adapter.getObject();
    if (danglingObj) {
        std::cout << "Объект все еще доступен (dangling pointer)" << std::endl;
        std::cout << "Валидность: " << (adapter.isObjectValid() ? "Да" : "Нет") << std::endl;
        
        // Попытка прочитать данные
        char* data = static_cast<char*>(danglingObj);
        std::cout << "Данные: " << data << std::endl;
        
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Use-After-Free достигнут!" << std::endl;
    }
}

// ============================================================================
// ЭКСПЛОИТ 4: INTEGER OVERFLOW ДЛЯ ОБХОДА ПРОВЕРОК
// ============================================================================

void exploitIntegerOverflow() {
    std::cout << "\n=== ЭКСПЛОИТ 4: INTEGER OVERFLOW ===" << std::endl;
    
    auto& adapter = VulnerableAdapter::getInstance();
    
    // УЯЗВИМОСТЬ: Integer overflow
    size_t largeSize = SIZE_MAX - 100;
    
    std::cout << "Попытка адаптировать объект размером: " << largeSize << std::endl;
    
    // Создаем данные для overflow
    std::vector<char> overflowData(1000);
    std::fill(overflowData.begin(), overflowData.end(), 'X');
    
    // Попытка вызвать overflow
    try {
        adapter.adapt(overflowData.data());
        std::cout << "Объект адаптирован (возможно из-за overflow)" << std::endl;
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Integer overflow достигнут!" << std::endl;
    } catch (...) {
        std::cout << "Произошло исключение при адаптации объекта" << std::endl;
    }
}

// ============================================================================
// ОСНОВНАЯ ФУНКЦИЯ
// ============================================================================

int main() {
    std::cout << "=== ДЕМОНСТРАЦИЯ ЭКСПЛОИТОВ ДЛЯ ADAPTER ===" << std::endl;
    std::cout << "ВНИМАНИЕ: Этот код содержит эксплоиты для образовательных целей!" << std::endl;
    
    // Запуск различных эксплоитов
    exploitTypeConfusion();
    exploitBufferOverflow();
    exploitUseAfterFree();
    exploitIntegerOverflow();
    
    std::cout << "\n=== РЕКОМЕНДАЦИИ ПО ЗАЩИТЕ ===" << std::endl;
    std::cout << "1. Используйте безопасные типы и шаблоны" << std::endl;
    std::cout << "2. Проверяйте типы перед приведением" << std::endl;
    std::cout << "3. Применяйте RAII для управления ресурсами" << std::endl;
    std::cout << "4. Валидируйте входные данные" << std::endl;
    std::cout << "5. Используйте умные указатели" << std::endl;
    std::cout << "6. Регулярно анализируйте код с помощью инструментов безопасности" << std::endl;
    
    return 0;
}