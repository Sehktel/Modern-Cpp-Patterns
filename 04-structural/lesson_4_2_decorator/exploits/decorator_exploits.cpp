#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <cstring>

// ============================================================================
// ЭКСПЛОИТЫ ДЛЯ DECORATOR
// ============================================================================

// TODO: Добавить комментарии на русском языке
// TODO: Создать более сложные эксплоиты
// TODO: Добавить обход защитных механизмов

// Уязвимый Decorator для демонстрации
class VulnerableDecorator {
private:
    VulnerableDecorator* next;
    char* data;
    size_t dataSize;
    
    VulnerableDecorator() : next(nullptr), data(nullptr), dataSize(0) {
        std::cout << "VulnerableDecorator создан в потоке " << std::this_thread::get_id() << std::endl;
    }
    
public:
    static VulnerableDecorator& getInstance() {
        static VulnerableDecorator instance;
        return instance;
    }
    
    // УЯЗВИМОСТЬ: Небезопасное добавление декоратора
    void addDecorator(VulnerableDecorator* decorator) {
        if (next) {
            // УЯЗВИМОСТЬ: Рекурсивный вызов может привести к stack overflow
            next->addDecorator(decorator);
        } else {
            next = decorator;
        }
    }
    
    // УЯЗВИМОСТЬ: Небезопасное добавление данных
    void setData(const char* str, size_t length) {
        dataSize = length;
        data = new char[dataSize];
        // УЯЗВИМОСТЬ: Нет проверки размера
        memcpy(data, str, length);
    }
    
    // УЯЗВИМОСТЬ: Рекурсивный вызов может привести к stack overflow
    void process() {
        std::cout << "Обработка декоратора" << std::endl;
        if (next) {
            next->process();
        }
    }
    
    // УЯЗВИМОСТЬ: Возврат указателя на внутренние данные
    char* getData() {
        return data;
    }
    
    ~VulnerableDecorator() {
        delete[] data;
        delete next;
        std::cout << "VulnerableDecorator уничтожен" << std::endl;
    }
};

// ============================================================================
// ЭКСПЛОИТ 1: STACK OVERFLOW ДЛЯ ПОЛУЧЕНИЯ КОНТРОЛЯ
// ============================================================================

void exploitStackOverflow() {
    std::cout << "\n=== ЭКСПЛОИТ 1: STACK OVERFLOW ===" << std::endl;
    
    auto& root = VulnerableDecorator::getInstance();
    
    // Создаем глубокую цепочку декораторов
    for (int i = 0; i < 10000; ++i) {
        VulnerableDecorator* decorator = new VulnerableDecorator();
        decorator->setData("Exploit data", 12);
        root.addDecorator(decorator);
    }
    
    std::cout << "Создана цепочка из 10000 декораторов" << std::endl;
    
    // УЯЗВИМОСТЬ: Попытка обработки может привести к stack overflow
    try {
        root.process();
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Stack overflow достигнут!" << std::endl;
    } catch (...) {
        std::cout << "Произошло исключение (stack overflow)" << std::endl;
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Stack overflow достигнут!" << std::endl;
    }
}

// ============================================================================
// ЭКСПЛОИТ 2: MEMORY LEAK ЧЕРЕЗ ИСКЛЮЧЕНИЯ
// ============================================================================

class LeakyDecorator {
private:
    LeakyDecorator* next;
    std::vector<void*> allocatedMemory;
    
public:
    LeakyDecorator() : next(nullptr) {
        std::cout << "LeakyDecorator создан" << std::endl;
    }
    
    // УЯЗВИМОСТЬ: Memory leak при исключении
    void addDecorator(LeakyDecorator* decorator) {
        // УЯЗВИМОСТЬ: Если здесь произойдет исключение,
        // память не будет освобождена
        next = decorator;
        
        // УЯЗВИМОСТЬ: Исключение может произойти здесь
        void* memory = new char[1024];
        allocatedMemory.push_back(memory);
        
        if (allocatedMemory.size() > 1000) {
            throw std::runtime_error("Слишком много декораторов");
        }
    }
    
    // УЯЗВИМОСТЬ: Небезопасная обработка
    void process() {
        if (next) {
            next->process();
        }
        
        // Обработка текущего декоратора
        for (void* mem : allocatedMemory) {
            // УЯЗВИМОСТЬ: Может произойти исключение
            memset(mem, 'A', 1024);
        }
    }
    
    ~LeakyDecorator() {
        // УЯЗВИМОСТЬ: Может быть вызван дважды
        for (void* mem : allocatedMemory) {
            delete[] static_cast<char*>(mem);
        }
        delete next;
        std::cout << "LeakyDecorator уничтожен" << std::endl;
    }
};

void exploitMemoryLeak() {
    std::cout << "\n=== ЭКСПЛОИТ 2: MEMORY LEAK ===" << std::endl;
    
    LeakyDecorator* root = new LeakyDecorator();
    
    try {
        // Создаем цепочку декораторов
        for (int i = 0; i < 100; ++i) {
            LeakyDecorator* decorator = new LeakyDecorator();
            root->addDecorator(decorator);
        }
        
        std::cout << "Создана цепочка декораторов" << std::endl;
        
        // УЯЗВИМОСТЬ: Исключение приведет к утечке памяти
        LeakyDecorator* leakyDecorator = new LeakyDecorator();
        root->addDecorator(leakyDecorator);
        
    } catch (const std::exception& e) {
        std::cout << "Исключение: " << e.what() << std::endl;
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Memory leak достигнут!" << std::endl;
    }
    
    delete root;
}

// ============================================================================
// ЭКСПЛОИТ 3: USE-AFTER-FREE АТАКА
// ============================================================================

class UseAfterFreeDecorator {
private:
    UseAfterFreeDecorator* next;
    char* data;
    bool isValid;
    
public:
    UseAfterFreeDecorator() : next(nullptr), data(nullptr), isValid(false) {
        std::cout << "UseAfterFreeDecorator создан" << std::endl;
    }
    
    void setData(const char* str) {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
        isValid = true;
    }
    
    void addDecorator(UseAfterFreeDecorator* decorator) {
        next = decorator;
    }
    
    // УЯЗВИМОСТЬ: Use-after-free при освобождении данных
    void releaseData() {
        delete[] data;
        data = nullptr;
        isValid = false;
        // УЯЗВИМОСТЬ: Не обнуляем указатель
    }
    
    // УЯЗВИМОСТЬ: Возврат указателя на освобожденную память
    char* getData() {
        return data; // Может быть dangling pointer
    }
    
    bool isDataValid() const {
        return isValid;
    }
    
    void process() {
        if (next) {
            next->process();
        }
        
        if (isValid && data) {
            std::cout << "Данные: " << data << std::endl;
        }
    }
    
    ~UseAfterFreeDecorator() {
        delete[] data;
        delete next;
        std::cout << "UseAfterFreeDecorator уничтожен" << std::endl;
    }
};

void exploitUseAfterFree() {
    std::cout << "\n=== ЭКСПЛОИТ 3: USE-AFTER-FREE ===" << std::endl;
    
    UseAfterFreeDecorator* root = new UseAfterFreeDecorator();
    root->setData("Root data for exploitation");
    
    UseAfterFreeDecorator* decorator = new UseAfterFreeDecorator();
    decorator->setData("Decorator data for exploitation");
    
    root->addDecorator(decorator);
    
    // Освобождаем данные
    root->releaseData();
    std::cout << "Данные освобождены" << std::endl;
    
    // УЯЗВИМОСТЬ: Попытка использования после освобождения
    char* data = root->getData();
    if (data) {
        std::cout << "Данные все еще доступны (dangling pointer)" << std::endl;
        std::cout << "Валидность: " << (root->isDataValid() ? "Да" : "Нет") << std::endl;
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Use-After-Free достигнут!" << std::endl;
    }
    
    delete root;
}

// ============================================================================
// ЭКСПЛОИТ 4: INTEGER OVERFLOW ДЛЯ ОБХОДА ПРОВЕРОК
// ============================================================================

void exploitIntegerOverflow() {
    std::cout << "\n=== ЭКСПЛОИТ 4: INTEGER OVERFLOW ===" << std::endl;
    
    auto& root = VulnerableDecorator::getInstance();
    
    // УЯЗВИМОСТЬ: Integer overflow
    size_t largeCount = SIZE_MAX - 100;
    
    std::cout << "Попытка создать " << largeCount << " декораторов" << std::endl;
    
    // Создаем данные для overflow
    std::vector<char> overflowData(1000);
    std::fill(overflowData.begin(), overflowData.end(), 'X');
    
    // Попытка вызвать overflow
    try {
        for (size_t i = 0; i < largeCount; ++i) {
            VulnerableDecorator* decorator = new VulnerableDecorator();
            decorator->setData(overflowData.data(), overflowData.size());
            root.addDecorator(decorator);
        }
        
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Integer overflow достигнут!" << std::endl;
    } catch (...) {
        std::cout << "Произошло исключение при создании декораторов" << std::endl;
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Integer overflow достигнут!" << std::endl;
    }
}

// ============================================================================
// ОСНОВНАЯ ФУНКЦИЯ
// ============================================================================

int main() {
    std::cout << "=== ДЕМОНСТРАЦИЯ ЭКСПЛОИТОВ ДЛЯ DECORATOR ===" << std::endl;
    std::cout << "ВНИМАНИЕ: Этот код содержит эксплоиты для образовательных целей!" << std::endl;
    
    // Запуск различных эксплоитов
    exploitStackOverflow();
    exploitMemoryLeak();
    exploitUseAfterFree();
    exploitIntegerOverflow();
    
    std::cout << "\n=== РЕКОМЕНДАЦИИ ПО ЗАЩИТЕ ===" << std::endl;
    std::cout << "1. Ограничивайте глубину цепочки декораторов" << std::endl;
    std::cout << "2. Используйте RAII для управления ресурсами" << std::endl;
    std::cout << "3. Проверяйте валидность указателей" << std::endl;
    std::cout << "4. Валидируйте входные данные" << std::endl;
    std::cout << "5. Используйте умные указатели" << std::endl;
    std::cout << "6. Регулярно анализируйте код с помощью инструментов безопасности" << std::endl;
    
    return 0;
}