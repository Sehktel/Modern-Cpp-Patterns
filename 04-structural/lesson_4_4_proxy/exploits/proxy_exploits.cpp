#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <cstring>

// ============================================================================
// ЭКСПЛОИТЫ ДЛЯ PROXY
// ============================================================================

// TODO: Добавить комментарии на русском языке
// TODO: Создать более сложные эксплоиты
// TODO: Добавить обход защитных механизмов

// Уязвимый Proxy для демонстрации
class VulnerableProxy {
private:
    void* realObject;
    char* username;
    char* password;
    bool isAuthenticated;
    
    VulnerableProxy() : realObject(nullptr), username(nullptr), password(nullptr), isAuthenticated(false) {
        std::cout << "VulnerableProxy создан в потоке " << std::this_thread::get_id() << std::endl;
    }
    
public:
    static VulnerableProxy& getInstance() {
        static VulnerableProxy instance;
        return instance;
    }
    
    // УЯЗВИМОСТЬ: Небезопасная аутентификация
    bool authenticate(const char* user, const char* pass) {
        // УЯЗВИМОСТЬ: Небезопасное сравнение паролей
        if (strcmp(user, "admin") == 0 && strcmp(pass, "password") == 0) {
            isAuthenticated = true;
            username = new char[strlen(user) + 1];
            password = new char[strlen(pass) + 1];
            strcpy(username, user);
            strcpy(password, pass);
            return true;
        }
        return false;
    }
    
    // УЯЗВИМОСТЬ: Небезопасный доступ к реальному объекту
    void* getRealObject() {
        if (isAuthenticated) {
            return realObject;
        }
        return nullptr;
    }
    
    // УЯЗВИМОСТЬ: Небезопасная установка реального объекта
    void setRealObject(void* obj) {
        realObject = obj;
    }
    
    // УЯЗВИМОСТЬ: Возврат учетных данных
    char* getUsername() {
        return username;
    }
    
    char* getPassword() {
        return password;
    }
    
    bool isAuth() const {
        return isAuthenticated;
    }
    
    ~VulnerableProxy() {
        delete[] username;
        delete[] password;
        std::cout << "VulnerableProxy уничтожен" << std::endl;
    }
};

// ============================================================================
// ЭКСПЛОИТ 1: AUTHENTICATION BYPASS ДЛЯ ПОЛУЧЕНИЯ НЕСАНКЦИОНИРОВАННОГО ДОСТУПА
// ============================================================================

void exploitAuthenticationBypass() {
    std::cout << "\n=== ЭКСПЛОИТ 1: AUTHENTICATION BYPASS ===" << std::endl;
    
    auto& proxy = VulnerableProxy::getInstance();
    
    // Нормальная аутентификация
    bool auth1 = proxy.authenticate("admin", "password");
    std::cout << "Аутентификация 'admin': " << (auth1 ? "Успех" : "Неудача") << std::endl;
    
    // УЯЗВИМОСТЬ: Попытка обхода аутентификации
    bool auth2 = proxy.authenticate("user", "wrong");
    std::cout << "Аутентификация 'user': " << (auth2 ? "Успех" : "Неудача") << std::endl;
    
    // УЯЗВИМОСТЬ: Получение учетных данных
    char* username = proxy.getUsername();
    char* password = proxy.getPassword();
    
    if (username && password) {
        std::cout << "Получены учетные данные: " << username << " / " << password << std::endl;
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Authentication bypass достигнут!" << std::endl;
    }
    
    // УЯЗВИМОСТЬ: Установка реального объекта без проверки
    char* obj = new char[1024];
    strcpy(obj, "Sensitive data for exploitation");
    proxy.setRealObject(obj);
    
    void* realObj = proxy.getRealObject();
    if (realObj) {
        std::cout << "Получен доступ к реальному объекту" << std::endl;
        char* data = static_cast<char*>(realObj);
        std::cout << "Данные: " << data << std::endl;
    }
    
    delete[] obj;
}

// ============================================================================
// ЭКСПЛОИТ 2: BUFFER OVERFLOW ЧЕРЕЗ ОБРАБОТКУ ЗАПРОСОВ
// ============================================================================

class BufferOverflowProxy {
private:
    char* requestBuffer;
    size_t bufferSize;
    size_t currentSize;
    
public:
    BufferOverflowProxy() : requestBuffer(nullptr), bufferSize(0), currentSize(0) {
        std::cout << "BufferOverflowProxy создан" << std::endl;
    }
    
    // УЯЗВИМОСТЬ: Небезопасная обработка запросов
    void processRequest(const char* request, size_t length) {
        // УЯЗВИМОСТЬ: Нет проверки переполнения буфера
        if (currentSize + length > bufferSize) {
            bufferSize = currentSize + length;
            char* newBuffer = new char[bufferSize];
            if (requestBuffer) {
                memcpy(newBuffer, requestBuffer, currentSize);
                delete[] requestBuffer;
            }
            requestBuffer = newBuffer;
        }
        
        // УЯЗВИМОСТЬ: Может произойти переполнение
        memcpy(requestBuffer + currentSize, request, length);
        currentSize += length;
    }
    
    // УЯЗВИМОСТЬ: Возврат указателя на внутренние данные
    char* getRequestBuffer() {
        return requestBuffer;
    }
    
    size_t getBufferSize() const {
        return bufferSize;
    }
    
    size_t getCurrentSize() const {
        return currentSize;
    }
    
    ~BufferOverflowProxy() {
        delete[] requestBuffer;
        std::cout << "BufferOverflowProxy уничтожен" << std::endl;
    }
};

void exploitBufferOverflow() {
    std::cout << "\n=== ЭКСПЛОИТ 2: BUFFER OVERFLOW ===" << std::endl;
    
    BufferOverflowProxy proxy;
    
    // Нормальное использование
    proxy.processRequest("Hello", 5);
    std::cout << "Обработан запрос размером 5 байт" << std::endl;
    
    // УЯЗВИМОСТЬ: Попытка обработки очень больших данных
    std::string largeRequest(1000000, 'A');
    proxy.processRequest(largeRequest.c_str(), largeRequest.length());
    
    std::cout << "Обработан запрос размером: " << proxy.getCurrentSize() << std::endl;
    std::cout << "Размер буфера: " << proxy.getBufferSize() << std::endl;
    
    // Попытка получить доступ к буферу
    char* buffer = proxy.getRequestBuffer();
    if (buffer) {
        std::cout << "Получен доступ к буферу" << std::endl;
        std::cout << "Первые 50 символов: ";
        for (int i = 0; i < 50 && i < proxy.getCurrentSize(); ++i) {
            std::cout << buffer[i];
        }
        std::cout << std::endl;
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Buffer overflow достигнут!" << std::endl;
    }
}

// ============================================================================
// ЭКСПЛОИТ 3: USE-AFTER-FREE АТАКА
// ============================================================================

class UseAfterFreeProxy {
private:
    void* realObject;
    bool isValid;
    
public:
    UseAfterFreeProxy() : realObject(nullptr), isValid(false) {
        std::cout << "UseAfterFreeProxy создан" << std::endl;
    }
    
    void setRealObject(void* obj) {
        realObject = obj;
        isValid = true;
    }
    
    // УЯЗВИМОСТЬ: Use-after-free при освобождении объекта
    void releaseRealObject() {
        delete[] static_cast<char*>(realObject);
        realObject = nullptr;
        isValid = false;
        // УЯЗВИМОСТЬ: Не обнуляем указатель
    }
    
    // УЯЗВИМОСТЬ: Возврат указателя на освобожденную память
    void* getRealObject() {
        return realObject; // Может быть dangling pointer
    }
    
    bool isObjectValid() const {
        return isValid && realObject != nullptr;
    }
    
    void processRequest(const char* request) {
        if (isValid && realObject) {
            // УЯЗВИМОСТЬ: Может произойти use-after-free
            strcpy(static_cast<char*>(realObject), request);
        }
    }
    
    ~UseAfterFreeProxy() {
        delete[] static_cast<char*>(realObject);
        std::cout << "UseAfterFreeProxy уничтожен" << std::endl;
    }
};

void exploitUseAfterFree() {
    std::cout << "\n=== ЭКСПЛОИТ 3: USE-AFTER-FREE ===" << std::endl;
    
    UseAfterFreeProxy proxy;
    
    // Создаем объект
    char* obj = new char[1024];
    strcpy(obj, "Real object data for exploitation");
    
    proxy.setRealObject(obj);
    std::cout << "Реальный объект установлен" << std::endl;
    
    // Освобождаем объект
    proxy.releaseRealObject();
    std::cout << "Реальный объект освобожден" << std::endl;
    
    // УЯЗВИМОСТЬ: Попытка использования после освобождения
    void* realObj = proxy.getRealObject();
    if (realObj) {
        std::cout << "Реальный объект все еще доступен (dangling pointer)" << std::endl;
        std::cout << "Валидность: " << (proxy.isObjectValid() ? "Да" : "Нет") << std::endl;
        
        // Попытка обработки запроса
        proxy.processRequest("Test request for exploitation");
        
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Use-After-Free достигнут!" << std::endl;
    }
}

// ============================================================================
// ЭКСПЛОИТ 4: INTEGER OVERFLOW ДЛЯ ОБХОДА ПРОВЕРОК
// ============================================================================

void exploitIntegerOverflow() {
    std::cout << "\n=== ЭКСПЛОИТ 4: INTEGER OVERFLOW ===" << std::endl;
    
    auto& proxy = VulnerableProxy::getInstance();
    
    // УЯЗВИМОСТЬ: Integer overflow
    size_t largeCount = SIZE_MAX - 100;
    
    std::cout << "Попытка обработать " << largeCount << " запросов" << std::endl;
    
    // Создаем данные для overflow
    std::vector<char> overflowData(1000);
    std::fill(overflowData.begin(), overflowData.end(), 'X');
    
    // Попытка вызвать overflow
    try {
        for (size_t i = 0; i < largeCount; ++i) {
            proxy.setRealObject(overflowData.data());
        }
        
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Integer overflow достигнут!" << std::endl;
    } catch (...) {
        std::cout << "Произошло исключение при обработке запросов" << std::endl;
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Integer overflow достигнут!" << std::endl;
    }
}

// ============================================================================
// ОСНОВНАЯ ФУНКЦИЯ
// ============================================================================

int main() {
    std::cout << "=== ДЕМОНСТРАЦИЯ ЭКСПЛОИТОВ ДЛЯ PROXY ===" << std::endl;
    std::cout << "ВНИМАНИЕ: Этот код содержит эксплоиты для образовательных целей!" << std::endl;
    
    // Запуск различных эксплоитов
    exploitAuthenticationBypass();
    exploitBufferOverflow();
    exploitUseAfterFree();
    exploitIntegerOverflow();
    
    std::cout << "\n=== РЕКОМЕНДАЦИИ ПО ЗАЩИТЕ ===" << std::endl;
    std::cout << "1. Используйте безопасную аутентификацию и авторизацию" << std::endl;
    std::cout << "2. Используйте RAII для управления ресурсами" << std::endl;
    std::cout << "3. Проверяйте валидность указателей" << std::endl;
    std::cout << "4. Валидируйте входные данные" << std::endl;
    std::cout << "5. Используйте умные указатели" << std::endl;
    std::cout << "6. Регулярно анализируйте код с помощью инструментов безопасности" << std::endl;
    
    return 0;
}