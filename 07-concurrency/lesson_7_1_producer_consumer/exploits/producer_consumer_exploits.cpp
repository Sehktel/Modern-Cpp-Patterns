#include <iostream>
#include <queue>
#include <thread>
#include <chrono>
#include <vector>
#include <atomic>
#include <mutex>
#include <cstring>
#include <iomanip>

/**
 * @file producer_consumer_exploits.cpp
 * @brief Практические эксплойты для Producer-Consumer
 * 
 * ⚠️  ТОЛЬКО ДЛЯ ОБРАЗОВАТЕЛЬНЫХ ЦЕЛЕЙ!
 */

// ============================================================================
// ЭКСПЛОЙТ 1: DATA RACE ДЛЯ BYPASS SECURITY CHECKS
// Цель: Обойти проверку permissions через race condition
// ============================================================================

struct Task {
    std::string command;
    bool requires_admin = false;
};

class VulnerableTaskQueue {
private:
    std::queue<Task> queue_;  // НЕТ СИНХРОНИЗАЦИИ!
    
public:
    void push(const Task& task) {
        queue_.push(task);
    }
    
    bool pop(Task& task) {
        if (queue_.empty()) return false;
        task = queue_.front();
        queue_.pop();
        return true;
    }
    
    bool empty() const {
        return queue_.empty();
    }
};

class VulnerableExecutor {
private:
    VulnerableTaskQueue& queue_;
    bool is_admin_ = false;
    
public:
    VulnerableExecutor(VulnerableTaskQueue& q) : queue_(q) {}
    
    void setAdmin(bool admin) {
        is_admin_ = admin;
    }
    
    void processTask() {
        Task task;
        if (queue_.pop(task)) {
            // УЯЗВИМОСТЬ: Проверка и выполнение не атомарны
            if (task.requires_admin && !is_admin_) {
                std::cout << "❌ Отказано: требуются права администратора для '" 
                          << task.command << "'\n";
                return;
            }
            
            // Задержка для демонстрации race condition
            std::this_thread::sleep_for(std::chrono::microseconds(100));
            
            std::cout << "✅ Выполнено: " << task.command 
                      << (task.requires_admin ? " [ADMIN]" : "") << "\n";
        }
    }
};

void exploit_race_condition_bypass() {
    std::cout << "\n=== ЭКСПЛОЙТ 1: Bypass Security через Data Race ===\n";
    
    VulnerableTaskQueue queue;
    VulnerableExecutor executor(queue);
    
    // Легитимный поток: периодически дает админ права
    std::thread admin_thread([&executor]() {
        for (int i = 0; i < 100; ++i) {
            executor.setAdmin(true);
            std::this_thread::sleep_for(std::chrono::microseconds(50));
            executor.setAdmin(false);
            std::this_thread::sleep_for(std::chrono::microseconds(50));
        }
    });
    
    // Атакующий: добавляет привилегированные задачи
    std::thread attacker([&queue]() {
        for (int i = 0; i < 20; ++i) {
            Task malicious{"rm -rf /*", true};  // Требует admin
            queue.push(malicious);
            std::this_thread::sleep_for(std::chrono::microseconds(150));
        }
    });
    
    // Worker: обрабатывает задачи
    std::thread worker([&executor]() {
        for (int i = 0; i < 20; ++i) {
            executor.processTask();
            std::this_thread::sleep_for(std::chrono::microseconds(100));
        }
    });
    
    admin_thread.join();
    attacker.join();
    worker.join();
    
    std::cout << "\n💡 Атакующий использовал race condition:\n";
    std::cout << "   - Флаг is_admin проверяется, но может измениться\n";
    std::cout << "   - Привилегированная команда выполнена без прав\n";
}

// ============================================================================
// ЭКСПЛОЙТ 2: BUFFER OVERFLOW ДЛЯ ПЕРЕЗАПИСИ ДАННЫХ
// Цель: Перезаписать критические данные в циклическом буфере
// ============================================================================

template<size_t N>
class VulnerableCircularBuffer {
private:
    char buffer_[N];
    size_t head_ = 0;
    size_t tail_ = 0;
    // НЕТ ПРОВЕРКИ ПЕРЕПОЛНЕНИЯ!
    
public:
    void write(const char* data, size_t len) {
        for (size_t i = 0; i < len; ++i) {
            buffer_[head_] = data[i];
            head_ = (head_ + 1) % N;
            // Может перезаписать tail_!
        }
    }
    
    bool read(char* data, size_t len) {
        if (head_ == tail_) return false;
        
        size_t available = (head_ >= tail_) ? (head_ - tail_) : (N + head_ - tail_);
        size_t to_read = std::min(len, available);
        
        for (size_t i = 0; i < to_read; ++i) {
            data[i] = buffer_[tail_];
            tail_ = (tail_ + 1) % N;
        }
        data[to_read] = '\0';
        return true;
    }
    
    void dump() {
        std::cout << "Buffer dump (hex): ";
        for (size_t i = 0; i < N; ++i) {
            std::cout << std::hex << std::setw(2) << std::setfill('0') 
                      << (int)(unsigned char)buffer_[i] << " ";
        }
        std::cout << std::dec << "\n";
    }
};

void exploit_buffer_overflow() {
    std::cout << "\n=== ЭКСПЛОЙТ 2: Buffer Overflow для перезаписи ===\n";
    
    VulnerableCircularBuffer<32> buffer;
    
    // Сначала записываем важные данные
    const char* secret = "SECRET_PASSWORD_123";
    buffer.write(secret, strlen(secret));
    std::cout << "Записан секрет: " << secret << "\n";
    
    // Атакующий producer перезаписывает буфер
    std::thread attacker([&buffer]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
        
        const char* malicious = "HACKED_____________HACKED_____________";
        buffer.write(malicious, strlen(malicious));
        std::cout << "🚨 Атакующий перезаписал буфер!\n";
    });
    
    // Легитимный consumer пытается прочитать
    std::thread consumer([&buffer]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
        
        char data[64];
        if (buffer.read(data, sizeof(data) - 1)) {
            std::cout << "Прочитано: " << data << "\n";
        }
    });
    
    attacker.join();
    consumer.join();
    
    buffer.dump();
    
    std::cout << "\n💡 Последствия:\n";
    std::cout << "   - Секретные данные перезаписаны\n";
    std::cout << "   - Можно контролировать содержимое буфера\n";
}

// ============================================================================
// ЭКСПЛОЙТ 3: MEMORY CORRUPTION ЧЕРЕЗ DANGLING POINTER
// Цель: Использовать dangling pointer для выполнения кода
// ============================================================================

struct VTableObject {
    virtual void execute() = 0;
    virtual ~VTableObject() = default;
};

struct LegitCommand : VTableObject {
    void execute() override {
        std::cout << "✅ Легитимная команда\n";
    }
};

struct MaliciousCommand : VTableObject {
    void execute() override {
        std::cout << "🚨 ЭКСПЛОЙТ: Выполнен злонамеренный код!\n";
        std::cout << "🚨 Получен shell доступ (в реальности)\n";
    }
};

class DanglingPointerQueue {
private:
    std::queue<VTableObject*> queue_;  // ОПАСНО: сырые указатели
    std::mutex mutex_;
    
public:
    void push(VTableObject* obj) {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(obj);
    }
    
    VTableObject* pop() {
        std::lock_guard<std::mutex> lock(mutex_);
        if (queue_.empty()) return nullptr;
        
        auto obj = queue_.front();
        queue_.pop();
        return obj;
    }
};

void exploit_dangling_pointer() {
    std::cout << "\n=== ЭКСПЛОЙТ 3: Memory Corruption через Dangling Pointer ===\n";
    
    DanglingPointerQueue queue;
    
    // Producer создает объект на стеке и удаляет его
    std::thread producer([&queue]() {
        {
            LegitCommand cmd;
            queue.push(&cmd);  // Добавляем указатель на стековый объект
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
            // cmd удаляется здесь
        }
        
        std::this_thread::sleep_for(std::chrono::milliseconds(20));
        
        // Создаем злонамеренный объект в том же месте памяти
        MaliciousCommand malicious;
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    });
    
    // Consumer использует dangling pointer
    std::thread consumer([&queue]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
        
        if (auto obj = queue.pop()) {
            std::cout << "Попытка выполнить команду...\n";
            // ОПАСНО: obj может указывать на MaliciousCommand!
            obj->execute();  // Virtual call через поврежденный vtable
        }
    });
    
    producer.join();
    consumer.join();
    
    std::cout << "\n💡 Атакующий:\n";
    std::cout << "   - Создал dangling pointer\n";
    std::cout << "   - Разместил злонамеренный объект в той же памяти\n";
    std::cout << "   - Перехватил control flow через vtable\n";
}

// ============================================================================
// ЭКСПЛОЙТ 4: DENIAL OF SERVICE ЧЕРЕЗ RESOURCE EXHAUSTION
// Цель: Исчерпать память сервера
// ============================================================================

class UnlimitedQueue {
private:
    std::queue<std::vector<char>> queue_;
    std::mutex mutex_;
    
public:
    void push(std::vector<char> data) {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(std::move(data));
    }
    
    size_t size() const {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.size();
    }
    
    size_t memory_usage() const {
        std::lock_guard<std::mutex> lock(mutex_);
        size_t total = 0;
        auto copy = queue_;
        while (!copy.empty()) {
            total += copy.front().size();
            copy.pop();
        }
        return total;
    }
};

void exploit_dos_resource_exhaustion() {
    std::cout << "\n=== ЭКСПЛОЙТ 4: DoS через Resource Exhaustion ===\n";
    
    UnlimitedQueue queue;
    std::atomic<bool> attack_active{true};
    
    // Атакующий: создает огромные объекты
    std::thread attacker([&queue, &attack_active]() {
        for (int i = 0; i < 100 && attack_active; ++i) {
            // Создаем 10 MB объекты
            std::vector<char> huge_data(10 * 1024 * 1024, 'A');
            queue.push(std::move(huge_data));
            
            if (i % 10 == 0) {
                size_t mem_mb = queue.memory_usage() / (1024 * 1024);
                std::cout << "🚨 Атака: " << queue.size() 
                          << " объектов, ~" << mem_mb << " MB памяти\n";
            }
        }
    });
    
    // Имитация срабатывания защиты
    std::thread monitor([&queue, &attack_active]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
        
        size_t mem_mb = queue.memory_usage() / (1024 * 1024);
        if (mem_mb > 100) {
            std::cout << "\n⚠️  ТРЕВОГА: Обнаружена DoS атака! Память: " 
                      << mem_mb << " MB\n";
            attack_active = false;
        }
    });
    
    attacker.join();
    monitor.join();
    
    std::cout << "\n💡 DoS атака:\n";
    std::cout << "   - Исчерпание памяти сервера\n";
    std::cout << "   - Отказ в обслуживании (OOM)\n";
    std::cout << "   - Защита: ограничение размера очереди\n";
}

// ============================================================================
// ЭКСПЛОЙТ 5: PRIORITY INVERSION ATTACK
// Цель: Блокировать высокоприоритетные задачи
// ============================================================================

struct PriorityTask {
    int id;
    int priority;  // Высокое число = высокий приоритет
    std::function<void()> action;
};

class VulnerablePriorityQueue {
private:
    std::vector<PriorityTask> queue_;  // Неоптимальная реализация
    std::mutex mutex_;
    
public:
    void push(PriorityTask task) {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push_back(task);
        // НЕТ СОРТИРОВКИ!
    }
    
    bool pop(PriorityTask& task) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (queue_.empty()) return false;
        
        // Ищем задачу с наивысшим приоритетом (медленно!)
        auto it = std::max_element(queue_.begin(), queue_.end(),
            [](const PriorityTask& a, const PriorityTask& b) {
                return a.priority < b.priority;
            });
        
        task = *it;
        queue_.erase(it);
        return true;
    }
    
    size_t size() const {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.size();
    }
};

void exploit_priority_inversion() {
    std::cout << "\n=== ЭКСПЛОЙТ 5: Priority Inversion Attack ===\n";
    
    VulnerablePriorityQueue queue;
    
    // Атакующий: заполняет очередь низкоприоритетными задачами
    std::thread attacker([&queue]() {
        for (int i = 0; i < 1000; ++i) {
            PriorityTask spam{
                i, 
                1,  // Низкий приоритет
                []() { /* Пустая задача */ }
            };
            queue.push(spam);
        }
        std::cout << "🚨 Атакующий добавил 1000 спам-задач\n";
    });
    
    // Легитимный producer: добавляет критическую задачу
    std::thread legit_producer([&queue]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
        
        PriorityTask critical{
            9999,
            100,  // ОЧЕНЬ высокий приоритет
            []() { std::cout << "⚡ КРИТИЧЕСКАЯ ЗАДАЧА!\n"; }
        };
        queue.push(critical);
        std::cout << "✅ Добавлена критическая задача (приоритет 100)\n";
    });
    
    // Consumer: медленно обрабатывает из-за O(n) поиска
    std::thread consumer([&queue]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        
        auto start = std::chrono::high_resolution_clock::now();
        
        PriorityTask task;
        if (queue.pop(task)) {
            auto end = std::chrono::high_resolution_clock::now();
            auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
            
            std::cout << "Обработка задачи ID=" << task.id 
                      << " (приоритет " << task.priority << ")\n";
            std::cout << "Время поиска: " << ms << " ms\n";
            task.action();
        }
    });
    
    attacker.join();
    legit_producer.join();
    consumer.join();
    
    std::cout << "\n💡 Priority Inversion:\n";
    std::cout << "   - Спам-задачи замедляют обработку\n";
    std::cout << "   - Критическая задача заблокирована\n";
    std::cout << "   - DoS для высокоприоритетных операций\n";
}

// ============================================================================
// MAIN
// ============================================================================

int main() {
    std::cout << "=== ПРАКТИЧЕСКИЕ ЭКСПЛОЙТЫ PRODUCER-CONSUMER ===\n";
    std::cout << "⚠️  ВНИМАНИЕ: Только для обучения!\n";
    
    try {
        exploit_race_condition_bypass();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    try {
        exploit_buffer_overflow();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    try {
        exploit_dangling_pointer();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    try {
        exploit_dos_resource_exhaustion();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    try {
        exploit_priority_inversion();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    std::cout << "\n=== ЗАЩИТНЫЕ МЕРЫ ===\n";
    std::cout << "✅ Используйте bounded queues\n";
    std::cout << "✅ Применяйте мьютексы для всех shared данных\n";
    std::cout << "✅ Используйте умные указатели\n";
    std::cout << "✅ Ограничивайте размер элементов\n";
    std::cout << "✅ Используйте priority_queue для приоритетов\n";
    std::cout << "✅ Тестируйте с ThreadSanitizer\n";
    
    return 0;
}
