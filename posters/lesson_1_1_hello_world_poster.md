# 📊 Плакат: Hello World в современном C++

## 🎯 Эволюция Hello World

```
┌─────────────────────────────────────────────────────────────────┐
│                    ЭВОЛЮЦИЯ C++ HELLO WORLD                    │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│    C++98        │     C++11       │     C++17       │     C++20       │
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│ • Явное         │ • auto          │ • structured    │ • concepts      │
│   управление    │ • nullptr       │   bindings      │ • ranges        │
│   памятью       │ • range-based   │ • optional      │ • modules       │
│ • Итераторы     │   for loops     │ • string_view   │ • coroutines    │
│ • NULL          │ • smart         │ • variant       │ • constexpr     │
│ • Многословный  │   pointers      │ • any           │   вычисления    │
│   синтаксис     │ • lambda        │ • filesystem    │                 │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

## 🔄 Сравнение подходов

### Управление памятью
```
┌─────────────────────────────────────────────────────────────────┐
│                    УПРАВЛЕНИЕ ПАМЯТЬЮ                          │
└─────────────────────────────────────────────────────────────────┘

❌ ПЛОХО (C++98):
┌─────────────────────────────────────────────────────────────────┐
│ std::vector<std::string>* vec = new std::vector<std::string>(); │
│ // ... использование ...                                        │
│ delete vec;  // ← Легко забыть!                                │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШО (C++11+):
┌─────────────────────────────────────────────────────────────────┐
│ auto vec = std::make_unique<std::vector<std::string>>();        │
│ // ... использование ...                                        │
│ // Автоматическое освобождение при выходе из области видимости  │
└─────────────────────────────────────────────────────────────────┘
```

### Итерация по контейнерам
```
┌─────────────────────────────────────────────────────────────────┐
│                   ИТЕРАЦИЯ ПО КОНТЕЙНЕРАМ                      │
└─────────────────────────────────────────────────────────────────┘

❌ ПЛОХО (C++98):
┌─────────────────────────────────────────────────────────────────┐
│ for (std::vector<int>::iterator it = vec.begin();               │
│      it != vec.end(); ++it) {                                   │
│     std::cout << *it << std::endl;                              │
│ }                                                                │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШО (C++11+):
┌─────────────────────────────────────────────────────────────────┐
│ for (const auto& item : vec) {                                  │
│     std::cout << item << std::endl;                             │
│ }                                                                │
└─────────────────────────────────────────────────────────────────┘
```

### Работа с парами и кортежами
```
┌─────────────────────────────────────────────────────────────────┐
│               PAIRS И TUPLES (C++17 Structured Bindings)        │
└─────────────────────────────────────────────────────────────────┘

❌ ПЛОХО (C++98):
┌─────────────────────────────────────────────────────────────────┐
│ std::pair<std::string, int> p = getPair();                      │
│ std::string name = p.first;                                     │
│ int age = p.second;                                             │
│ std::cout << name << ": " << age << std::endl;                  │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШО (C++17+):
┌─────────────────────────────────────────────────────────────────┐
│ auto [name, age] = getPair();                                   │
│ std::cout << name << ": " << age << std::endl;                  │
└─────────────────────────────────────────────────────────────────┘
```

## 🧠 Ключевые принципы современного C++

```
┌─────────────────────────────────────────────────────────────────┐
│                   ПРИНЦИПЫ СОВРЕМЕННОГО C++                    │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   RAII          │ Resource Acquisition Is Initialization        │
│                 │ • Ресурсы захватываются при создании         │
│                 │ • Автоматически освобождаются при уничтожении│
│                 │ • Исключения безопасность                     │
├─────────────────┼───────────────────────────────────────────────┤
│   SMART         │ Автоматическое управление памятью             │
│   POINTERS      │ • unique_ptr - единоличное владение           │
│                 │ • shared_ptr - разделяемое владение           │
│                 │ • weak_ptr - слабые ссылки                    │
├─────────────────┼───────────────────────────────────────────────┤
│   MOVE          │ Эффективная передача данных                   │
│   SEMANTICS     │ • Избегание ненужных копирований             │
│                 │ • std::move для явного перемещения           │
│                 │ • rvalue references                           │
├─────────────────┼───────────────────────────────────────────────┤
│   TYPE          │ Безопасность типов на этапе компиляции       │
│   SAFETY        │ • auto для вывода типов                      │
│                 │ • constexpr для вычислений времени компиляции│
│                 │ • static_assert для проверок                 │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🎨 Современные идиомы

### Auto и Type Deduction
```
┌─────────────────────────────────────────────────────────────────┐
│                    AUTO И ВЫВОД ТИПОВ                          │
└─────────────────────────────────────────────────────────────────┘

Когда ИСПОЛЬЗОВАТЬ auto:
✅ • Итераторы контейнеров
✅ • Результаты вызовов функций
✅ • Lambda выражения
✅ • Шаблонные функции

Когда НЕ использовать auto:
❌ • Публичные интерфейсы API
❌ • Когда тип неочевиден из контекста
❌ • Целочисленные типы (предпочесть explicit)
```

### Lambda выражения
```
┌─────────────────────────────────────────────────────────────────┐
│                     LAMBDA ВЫРАЖЕНИЯ                           │
└─────────────────────────────────────────────────────────────────┘

Синтаксис:
[capture](parameters) -> return_type { body }

Примеры:
• [](int x) { return x * 2; }                    // Простая lambda
• [=](int x) { return x + y; }                   // Capture по значению
• [&](int x) { counter++; }                      // Capture по ссылке
• [y](int x) { return x + y; }                   // Capture конкретной переменной
```

## 🚀 Подготовка к паттернам

```
┌─────────────────────────────────────────────────────────────────┐
│                ПОДГОТОВКА К ИЗУЧЕНИЮ ПАТТЕРНОВ                 │
└─────────────────────────────────────────────────────────────────┘

Навыки, которые мы развили:
┌─────────────────┬───────────────────────────────────────────────┐
│ ✅ RAII         │ Основа для всех паттернов управления ресурсами│
├─────────────────┼───────────────────────────────────────────────┤
│ ✅ Smart        │ Ключевой инструмент в креационных паттернах   │
│    Pointers     │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│ ✅ Auto         │ Упрощает код в структурных и поведенческих    │
│                 │ паттернах                                     │
├─────────────────┼───────────────────────────────────────────────┤
│ ✅ Lambda       │ Основа для функциональных паттернов           │
├─────────────────┼───────────────────────────────────────────────┤
│ ✅ Type Safety  │ Предотвращает ошибки в сложных архитектурах   │
└─────────────────┴───────────────────────────────────────────────┘

Следующий шаг: Принципы проектирования (SOLID, DRY, KISS)
```

## 💡 Практические советы

```
┌─────────────────────────────────────────────────────────────────┐
│                      ПРАКТИЧЕСКИЕ СОВЕТЫ                       │
└─────────────────────────────────────────────────────────────────┘

1. 📚 Изучайте постепенно
   • Начните с auto и range-based for
   • Затем переходите к smart pointers
   • Изучайте lambda по мере необходимости

2. 🔍 Анализируйте код
   • Сравнивайте старый и новый подходы
   • Понимайте компромиссы каждого решения
   • Задавайте вопросы "почему?"

3. 🛠️ Практикуйтесь
   • Рефакторите существующий код
   • Экспериментируйте с новыми возможностями
   • Изучайте стандартную библиотеку

4. 🤔 Критически мыслите
   • Не все новое автоматически лучше
   • Рассматривайте альтернативы
   • Учитывайте контекст применения
```

---
*Этот плакат - ваш справочник по современным возможностям C++. 
Используйте его как основу для понимания паттернов проектирования.*
