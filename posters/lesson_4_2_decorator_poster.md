# 📊 Плакат: Decorator Pattern (Декоратор)

## 🎯 Назначение паттерна Decorator

```
┌─────────────────────────────────────────────────────────────────┐
│                        DECORATOR PATTERN                       │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  🎨 ДИНАМИЧЕСКИ ДОБАВЛЯЕТ НОВУЮ ФУНКЦИОНАЛЬНОСТЬ ОБЪЕКТАМ      │
│  🔄 ОБЕРТЫВАЕТ ОБЪЕКТЫ ДЛЯ РАСШИРЕНИЯ ИХ ВОЗМОЖНОСТЕЙ          │
│  🎯 АЛЬТЕРНАТИВА НАСЛЕДОВАНИЮ ДЛЯ ДОБАВЛЕНИЯ ПОВЕДЕНИЯ         │
└─────────────────────────────────────────────────────────────────┘

Применение:
┌─────────────────┬───────────────────────────────────────────────┐
│   Streams       │ • Добавление сжатия, шифрования, буферизации │
├─────────────────┼───────────────────────────────────────────────┤
│   UI Components │ • Добавление скроллинга, границ, теней       │
├─────────────────┼───────────────────────────────────────────────┤
│   Logging       │ • Добавление временных меток, форматирования  │
├─────────────────┼───────────────────────────────────────────────┤
│   Caching       │ • Добавление кэширования к любым операциям   │
├─────────────────┼───────────────────────────────────────────────┤
│   Validation    │ • Добавление проверок к существующим методам  │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🔄 Проблема без Decorator

```
┌─────────────────────────────────────────────────────────────────┐
│                    ПРОБЛЕМА: ВЗРЫВ НАСЛЕДОВАНИЯ               │
└─────────────────────────────────────────────────────────────────┘

❌ ПЛОХО - Классическое наследование:
┌─────────────────────────────────────────────────────────────────┐
│ class Coffee {                                                  │
│ public:                                                         │
│     virtual double cost() = 0;                                 │
│     virtual std::string description() = 0;                     │
│ };                                                              │
│                                                                 │
│ class Espresso : public Coffee {                               │
│ public:                                                         │
│     double cost() override { return 1.99; }                    │
│     std::string description() override { return "Espresso"; }   │
│ };                                                              │
│                                                                 │
│ class EspressoWithMilk : public Coffee {                       │
│ public:                                                         │
│     double cost() override { return 1.99 + 0.50; }             │
│     std::string description() override {                         │
│         return "Espresso with Milk";                            │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ class EspressoWithMilkAndSugar : public Coffee {               │
│ public:                                                         │
│     double cost() override { return 1.99 + 0.50 + 0.25; }       │
│     std::string description() override {                         │
│         return "Espresso with Milk and Sugar";                  │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ // Проблемы:                                                    │
│ // • Взрыв классов (2^n комбинаций)                            │
│ // • Дублирование кода                                         │
│ // • Нарушение Open/Closed Principle                           │
│ // • Сложность добавления новых добавок                       │
└─────────────────────────────────────────────────────────────────┘
```

## ✅ Решение с Decorator

```
┌─────────────────────────────────────────────────────────────────┐
│                    РЕШЕНИЕ: КОМПОЗИЦИЯ                        │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШО - Динамическое добавление функциональности:
┌─────────────────────────────────────────────────────────────────┐
│ class Coffee {                                                  │
│ public:                                                         │
│     virtual double cost() = 0;                                 │
│     virtual std::string description() = 0;                     │
│     virtual ~Coffee() = default;                               │
│ };                                                              │
│                                                                 │
│ class Espresso : public Coffee {                               │
│ public:                                                         │
│     double cost() override { return 1.99; }                    │
│     std::string description() override { return "Espresso"; }   │
│ };                                                              │
│                                                                 │
│ class CoffeeDecorator : public Coffee {                        │
│ protected:                                                      │
│     std::unique_ptr<Coffee> coffee_;                            │
│                                                                 │
│ public:                                                         │
│     CoffeeDecorator(std::unique_ptr<Coffee> coffee)             │
│         : coffee_(std::move(coffee)) {}                         │
│                                                                 │
│     double cost() override {                                    │
│         return coffee_->cost();                                  │
│     }                                                           │
│                                                                 │
│     std::string description() override {                        │
│         return coffee_->description();                          │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ class MilkDecorator : public CoffeeDecorator {                  │
│ public:                                                         │
│     MilkDecorator(std::unique_ptr<Coffee> coffee)              │
│         : CoffeeDecorator(std::move(coffee)) {}                 │
│                                                                 │
│     double cost() override {                                    │
│         return coffee_->cost() + 0.50;                          │
│     }                                                           │
│                                                                 │
│     std::string description() override {                        │
│         return coffee_->description() + " with Milk";           │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ class SugarDecorator : public CoffeeDecorator {                │
│ public:                                                         │
│     SugarDecorator(std::unique_ptr<Coffee> coffee)              │
│         : CoffeeDecorator(std::move(coffee)) {}                 │
│                                                                 │
│     double cost() override {                                    │
│         return coffee_->cost() + 0.25;                          │
│     }                                                           │
│                                                                 │
│     std::string description() override {                        │
│         return coffee_->description() + " with Sugar";          │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘

Использование:
┌─────────────────────────────────────────────────────────────────┐
│ // Создание кофе с молоком и сахаром                           │
│ auto coffee = std::make_unique<Espresso>();                     │
│ coffee = std::make_unique<MilkDecorator>(std::move(coffee));    │
│ coffee = std::make_unique<SugarDecorator>(std::move(coffee));   │
│                                                                 │
│ std::cout << coffee->description() << std::endl;                │
│ std::cout << "Cost: $" << coffee->cost() << std::endl;         │
│ // Вывод: "Espresso with Milk with Sugar"                       │
│ //        "Cost: $2.74"                                         │
└─────────────────────────────────────────────────────────────────┘

Преимущества:
✅ Динамическое добавление функциональности
✅ Избежание взрыва классов
✅ Соблюдение Open/Closed Principle
✅ Композиция вместо наследования
```

## 🏗️ Структура Decorator

```
┌─────────────────────────────────────────────────────────────────┐
│                    СТРУКТУРА ПАТТЕРНА                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Component (Компонент)                       │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class Coffee {                                              ││
│  │ public:                                                     ││
│  │     virtual double cost() = 0;                             ││
│  │     virtual std::string description() = 0;                ││
│  │     virtual ~Coffee() = default;                           ││
│  │ };                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    ConcreteComponent (Конкретный компонент)    │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class Espresso : public Coffee {                           ││
│  │ public:                                                     ││
│  │     double cost() override { return 1.99; }                ││
│  │     std::string description() override { return "Espresso"; }││
│  │ };                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Decorator (Декоратор)                       │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class CoffeeDecorator : public Coffee {                    ││
│  │ protected:                                                  ││
│  │     std::unique_ptr<Coffee> coffee_;                        ││
│  │                                                             ││
│  │ public:                                                     ││
│  │     CoffeeDecorator(std::unique_ptr<Coffee> coffee)         ││
│  │         : coffee_(std::move(coffee)) {}                     ││
│  │                                                             ││
│  │     double cost() override {                                ││
│  │         return coffee_->cost();                             ││
│  │     }                                                       ││
│  │                                                             ││
│  │     std::string description() override {                    ││
│  │         return coffee_->description();                      ││
│  │     }                                                       ││
│  │ };                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    ConcreteDecorator (Конкретный декоратор)   │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class MilkDecorator : public CoffeeDecorator {              ││
│  │ public:                                                     ││
│  │     MilkDecorator(std::unique_ptr<Coffee> coffee)           ││
│  │         : CoffeeDecorator(std::move(coffee)) {}            ││
│  │                                                             ││
│  │     double cost() override {                                ││
│  │         return coffee_->cost() + 0.50;                      ││
│  │     }                                                       ││
│  │                                                             ││
│  │     std::string description() override {                    ││
│  │         return coffee_->description() + " with Milk";       ││
│  │     }                                                       ││
│  │ };                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 Последовательность взаимодействий

```
┌─────────────────────────────────────────────────────────────────┐
│                ПОСЛЕДОВАТЕЛЬНОСТЬ ВЗАИМОДЕЙСТВИЙ               │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   1. Клиент     │ auto coffee = std::make_unique<Espresso>();   │
│      создает     │                                               │
│      базовый     │                                               │
│      объект     │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   2. Клиент     │ coffee = std::make_unique<MilkDecorator>(     │
│      оборачивает│     std::move(coffee));                       │
│      объект     │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   3. Клиент     │ coffee = std::make_unique<SugarDecorator>(    │
│      добавляет   │     std::move(coffee));                       │
│      еще один    │                                               │
│      декоратор   │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   4. Клиент     │ double cost = coffee->cost();                 │
│      вызывает    │ std::string desc = coffee->description();    │
│      методы     │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   5. Декораторы│ SugarDecorator::cost() → MilkDecorator::cost() │
│      передают    │ → Espresso::cost() → 1.99 + 0.50 + 0.25     │
│      вызовы     │                                               │
└─────────────────┴───────────────────────────────────────────────┘

Диаграмма взаимодействий:
┌─────────────────────────────────────────────────────────────────┐
│  Client ──┐                                                    │
│           │                                                    │
│           ▼                                                    │
│  SugarDecorator ──┐                                            │
│                   │                                            │
│                   ▼                                            │
│  MilkDecorator ──┐                                             │
│                   │                                             │
│                   ▼                                             │
│  Espresso ──┐                                                   │
│              │                                                   │
│              ▼                                                   │
│  cost() = 1.99                                                   │
└─────────────────────────────────────────────────────────────────┘
```

## 🎨 Варианты реализации

### 1. Classic Decorator (Классический)
```
┌─────────────────────────────────────────────────────────────────┐
│                    CLASSIC DECORATOR                           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ class TextProcessor {                                           │
│ public:                                                         │
│     virtual std::string process(const std::string& text) = 0;  │
│     virtual ~TextProcessor() = default;                        │
│ };                                                              │
│                                                                 │
│ class PlainTextProcessor : public TextProcessor {              │
│ public:                                                         │
│     std::string process(const std::string& text) override {    │
│         return text;                                            │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ class TextProcessorDecorator : public TextProcessor {          │
│ protected:                                                      │
│     std::unique_ptr<TextProcessor> processor_;                  │
│                                                                 │
│ public:                                                         │
│     TextProcessorDecorator(std::unique_ptr<TextProcessor> processor) │
│         : processor_(std::move(processor)) {}                   │
│ };                                                              │
│                                                                 │
│ class UpperCaseDecorator : public TextProcessorDecorator {     │
│ public:                                                         │
│     UpperCaseDecorator(std::unique_ptr<TextProcessor> processor) │
│         : TextProcessorDecorator(std::move(processor)) {}       │
│                                                                 │
│     std::string process(const std::string& text) override {    │
│         std::string result = processor_->process(text);        │
│         std::transform(result.begin(), result.end(),            │
│                        result.begin(), ::toupper);               │
│         return result;                                          │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘
```

### 2. Functional Decorator
```
┌─────────────────────────────────────────────────────────────────┐
│                    FUNCTIONAL DECORATOR                       │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ using TextProcessor = std::function<std::string(const std::string&)>; │
│                                                                 │
│ class TextProcessorBuilder {                                    │
│ private:                                                        │
│     TextProcessor processor_;                                   │
│                                                                 │
│ public:                                                         │
│     TextProcessorBuilder() : processor_([](const std::string& text) { │
│         return text;                                            │
│     }) {}                                                       │
│                                                                 │
│     TextProcessorBuilder& toUpperCase() {                      │
│         auto prev = processor_;                                 │
│         processor_ = [prev](const std::string& text) {          │
│             std::string result = prev(text);                   │
│             std::transform(result.begin(), result.end(),       │
│                            result.begin(), ::toupper);          │
│             return result;                                      │
│         };                                                      │
│         return *this;                                           │
│     }                                                           │
│                                                                 │
│     TextProcessorBuilder& addPrefix(const std::string& prefix) { │
│         auto prev = processor_;                                  │
│         processor_ = [prev, prefix](const std::string& text) {   │
│             return prefix + prev(text);                         │
│         };                                                      │
│         return *this;                                           │
│     }                                                           │
│                                                                 │
│     TextProcessor build() {                                     │
│         return processor_;                                      │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘

Использование:
┌─────────────────────────────────────────────────────────────────┐
│ auto processor = TextProcessorBuilder()                         │
│     .toUpperCase()                                              │
│     .addPrefix("PROCESSED: ")                                   │
│     .build();                                                   │
│                                                                 │
│ std::string result = processor("hello world");                  │
│ // Результат: "PROCESSED: HELLO WORLD"                         │
└─────────────────────────────────────────────────────────────────┘
```

### 3. Template Decorator
```
┌─────────────────────────────────────────────────────────────────┐
│                    TEMPLATE DECORATOR                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ template<typename T>                                             │
│ class Decorator {                                               │
│ private:                                                        │
│     T component_;                                               │
│                                                                 │
│ public:                                                         │
│     Decorator(T component) : component_(std::move(component)) {} │
│                                                                 │
│     template<typename Func>                                     │
│     auto decorate(Func func) {                                  │
│         return [this, func](auto... args) {                     │
│             return func(component_(args...));                    │
│         };                                                      │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ // Использование                                               │
│ auto add = [](int a, int b) { return a + b; };                 │
│ auto multiply = [](int x) { return x * 2; };                   │
│                                                                 │
│ Decorator<decltype(add)> decorator(add);                        │
│ auto decoratedAdd = decorator.decorate(multiply);                │
│                                                                 │
│ int result = decoratedAdd(3, 4); // (3 + 4) * 2 = 14            │
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 Сравнение подходов

```
┌─────────────────────────────────────────────────────────────────┐
│                    СРАВНЕНИЕ ПОДХОДОВ                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│   Classic       │   Functional    │   Template      │   Mixin         │
│   Decorator     │   Decorator     │   Decorator     │   Decorator     │
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│ Простота        │ Средняя          │ Низкая          │ Высокая         │
│ Гибкость        │ Высокая          │ Очень высокая   │ Средняя         │
│ Производительность│ Высокая        │ Средняя         │ Высокая         │
│ Тестируемость   │ Высокая          │ Высокая         │ Средняя         │
│ Типобезопасность│ Средняя          │ Низкая          │ Высокая         │
│ Применимость    │ Стандартные      │ Функциональные  │ Шаблонные       │
│                 │ случаи          │ случаи          │ случаи          │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

## 🎯 Когда использовать Decorator

```
┌─────────────────────────────────────────────────────────────────┐
│                КОГДА ИСПОЛЬЗОВАТЬ DECORATOR                    │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Динамическое    │ • Нужно добавлять функциональность во время  │
│ расширение      │   выполнения                                  │
│                 │ • Различные комбинации функций                │
├─────────────────┼───────────────────────────────────────────────┤
│ Избежание       │ • Избежание взрыва классов                    │
│ наследования    │ • Композиция вместо наследования              │
├─────────────────┼───────────────────────────────────────────────┤
│ Модульность     │ • Функции должны быть независимыми            │
│                 │ • Возможность комбинирования функций          │
├─────────────────┼───────────────────────────────────────────────┤
│ Открытость      │ • Система должна быть открыта для расширения  │
│                 │ • Закрыта для модификации                     │
├─────────────────┼───────────────────────────────────────────────┤
│ Прозрачность    │ • Декораторы должны быть прозрачными         │
│                 │ • Клиент не должен знать о декораторах       │
└─────────────────┴───────────────────────────────────────────────┘

❌ ПЛОХИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Простые случаи  │ • Когда можно использовать простое наследование│
├─────────────────┼───────────────────────────────────────────────┤
│ Производительность│ • Критична производительность               │
├─────────────────┼───────────────────────────────────────────────┤
│ Сложность       │ • Добавляется ненужная сложность             │
├─────────────────┼───────────────────────────────────────────────┤
│ Альтернативы    │ • Есть лучшие альтернативы (Strategy)        │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🧪 Тестирование Decorator

```
┌─────────────────────────────────────────────────────────────────┐
│                    ТЕСТИРОВАНИЕ DECORATOR                     │
└─────────────────────────────────────────────────────────────────┘

Преимущества для тестирования:
┌─────────────────┬───────────────────────────────────────────────┐
│ Моки            │ ✅ Легко создавать моки для компонентов      │
│                 │ class MockCoffee : public Coffee {            │
│                 │     MOCK_METHOD(double, cost, ());           │
│                 │     MOCK_METHOD(std::string, description, ()); │
│                 │ };                                            │
├─────────────────┼───────────────────────────────────────────────┤
│ Изоляция        │ ✅ Легко изолировать тесты                   │
│                 │ auto mockCoffee = std::make_unique<MockCoffee>(); │
│                 │ MilkDecorator decorator(std::move(mockCoffee)); │
├─────────────────┼───────────────────────────────────────────────┤
│ Управление      │ ✅ Полный контроль над компонентами          │
│ зависимостями   │ EXPECT_CALL(*mockCoffee, cost())              │
│                 │     .WillOnce(Return(1.99));                 │
└─────────────────┴───────────────────────────────────────────────┘

Пример теста:
┌─────────────────────────────────────────────────────────────────┐
│ TEST(MilkDecoratorTest, AddMilkToCoffee) {                      │
│     auto mockCoffee = std::make_unique<MockCoffee>();            │
│     MilkDecorator decorator(std::move(mockCoffee));              │
│                                                                 │
│     EXPECT_CALL(*mockCoffee, cost()).WillOnce(Return(1.99));     │
│     EXPECT_CALL(*mockCoffee, description())                     │
│         .WillOnce(Return("Espresso"));                          │
│                                                                 │
│     EXPECT_EQ(decorator.cost(), 2.49);                          │
│     EXPECT_EQ(decorator.description(), "Espresso with Milk");   │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

## 🔗 Связь с другими паттернами

```
┌─────────────────────────────────────────────────────────────────┐
│              СВЯЗЬ С ДРУГИМИ ПАТТЕРНАМИ                        │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│ Adapter         │ • Decorator изменяет интерфейс               │
│                 │ • Adapter адаптирует интерфейс               │
│                 │ • Decorator - расширение                    │
│                 │ • Adapter - совместимость                   │
├─────────────────┼───────────────────────────────────────────────┤
│ Bridge          │ • Decorator добавляет функциональность      │
│                 │ • Bridge разделяет абстракцию и реализацию  │
│                 │ • Decorator - композиция                    │
│                 │ • Bridge - разделение                       │
├─────────────────┼───────────────────────────────────────────────┤
│ Composite       │ • Decorator оборачивает один объект          │
│                 │ • Composite управляет группой объектов       │
│                 │ • Decorator - обертка                       │
│                 │ • Composite - группа                        │
├─────────────────┼───────────────────────────────────────────────┤
│ Proxy           │ • Decorator добавляет функциональность       │
│                 │ • Proxy контролирует доступ к объекту       │
│                 │ • Decorator - расширение                    │
│                 │ • Proxy - контроль доступа                 │
├─────────────────┼───────────────────────────────────────────────┤
│ Strategy        │ • Decorator может использовать Strategy     │
│                 │ • Strategy для выбора алгоритма декорирования│
│                 │ • Decorator - композиция                    │
│                 │ • Strategy - выбор алгоритма                │
└─────────────────┴───────────────────────────────────────────────┘
```

## 💡 Практические рекомендации

```
┌─────────────────────────────────────────────────────────────────┐
│                  ПРАКТИЧЕСКИЕ РЕКОМЕНДАЦИИ                     │
└─────────────────────────────────────────────────────────────────┘

1. 🎯 Выбор реализации:
   • Classic Decorator - для большинства случаев
   • Functional Decorator - для функционального стиля
   • Template Decorator - для типизированных случаев
   • Mixin Decorator - для множественного наследования

2. 🔧 Принципы проектирования:
   • Соблюдайте Open/Closed Principle
   • Используйте композицию вместо наследования
   • Инкапсулируйте логику декорирования
   • Обеспечьте прозрачность декораторов

3. 🧪 Тестирование:
   • Создавайте интерфейсы для компонентов
   • Используйте моки в тестах
   • Тестируйте различные комбинации декораторов
   • Проверяйте корректность цепочки вызовов

4. ⚡ Производительность:
   • Рассмотрите кэширование результатов
   • Используйте move semantics
   • Избегайте ненужных копирований
   • Профилируйте критические участки

5. 📚 Документация:
   • Документируйте порядок применения декораторов
   • Описывайте совместимость декораторов
   • Приводите примеры использования
   • Объясняйте причины выбора паттерна

6. 🔄 Рефакторинг:
   • Начинайте с простых декораторов
   • Постепенно добавляйте сложность
   • Используйте интерфейсы для абстракции
   • Планируйте расширяемость
```

## 🎓 Ключевые выводы

```
┌─────────────────────────────────────────────────────────────────┐
│                      КЛЮЧЕВЫЕ ВЫВОДЫ                          │
└─────────────────────────────────────────────────────────────────┘

✅ Decorator - мощный инструмент:
   • Динамически добавляет функциональность
   • Избегает взрыва классов
   • Следует принципам SOLID
   • Обеспечивает гибкость

✅ Выбирайте подходящую реализацию:
   • Classic Decorator - для большинства случаев
   • Functional Decorator - для функционального стиля
   • Template Decorator - для типизированных случаев
   • Mixin Decorator - для множественного наследования

✅ Используйте правильно:
   • Когда нужно динамическое расширение
   • Когда важно избежать взрыва классов
   • Когда нужна модульность
   • Когда важна прозрачность

✅ Избегайте злоупотребления:
   • Не используйте для простых случаев
   • Не добавляйте сложность без необходимости
   • Не забывайте об обработке ошибок
   • Не нарушайте принципы SOLID

✅ Помните о компромиссах:
   • Гибкость vs производительность
   • Модульность vs сложность
   • Прозрачность vs функциональность
   • Тестируемость vs производительность
```

---
*Decorator - это инструмент для динамического добавления функциональности. 
Используйте его для создания гибких и расширяемых систем!*