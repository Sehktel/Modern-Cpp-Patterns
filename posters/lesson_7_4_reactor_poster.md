# 📊 Плакат: Reactor Pattern

## 🎯 Концепция Reactor

```
┌─────────────────────────────────────────────────────────────────┐
│                      REACTOR PATTERN                           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  ⚡ СОБЫТИЙНО-ОРИЕНТИРОВАННАЯ ОБРАБОТКА I/O                   │
│  🔄 ЕДИНЫЙ EVENT LOOP ДЛЯ МУЛЬТИПЛЕКСИРОВАНИЯ                │
│  📡 ДЕМУЛЬТИПЛЕКСИРОВАНИЕ СОБЫТИЙ НА ОБРАБОТЧИКИ              │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   ПРОБЛЕМА      │  • Множество I/O источников                   │
│                 │  • Блокирующие операции неэффективны          │
│                 │  • Сложное управление асинхронностью          │
├─────────────────┼───────────────────────────────────────────────┤
│   РЕШЕНИЕ       │  • Единый event loop                          │
│                 │  • select/poll/epoll для мультиплексирования  │
│                 │  • Event handlers для каждого источника       │
│                 │  • Неблокирующий I/O                          │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🏗️ Архитектура Reactor

```
┌─────────────────────────────────────────────────────────────────┐
│                   КОМПОНЕНТЫ REACTOR                           │
└─────────────────────────────────────────────────────────────────┘

                    ┌───────────────────┐
                    │   Event Sources   │
                    │  (File Descriptors)│
                    └───────────────────┘
                     │     │     │     │
              Socket1│ Sock2│ File│ Timer
                     ↓     ↓     ↓     ↓
            ┌────────────────────────────────────┐
            │    SYNCHRONOUS EVENT DEMUXER       │
            │    (select / poll / epoll)         │
            │  ┌──────────────────────────────┐  │
            │  │  Wait for events...          │  │
            │  │  • READ ready                │  │
            │  │  • WRITE ready               │  │
            │  │  • ERROR / TIMEOUT           │  │
            │  └──────────────────────────────┘  │
            └────────────────────────────────────┘
                            ↓
            ┌────────────────────────────────────┐
            │         REACTOR (Dispatcher)       │
            │  ┌──────────────────────────────┐  │
            │  │   Dispatch events to         │  │
            │  │   appropriate handlers       │  │
            │  └──────────────────────────────┘  │
            └────────────────────────────────────┘
              ↓           ↓           ↓         ↓
         ┌────────┐  ┌────────┐  ┌────────┐ ┌────────┐
         │Handler1│  │Handler2│  │Handler3│ │Handler4│
         │ READ   │  │ WRITE  │  │ ERROR  │ │TIMEOUT │
         └────────┘  └────────┘  └────────┘ └────────┘
```

## 🔄 Event Loop цикл

```
┌─────────────────────────────────────────────────────────────────┐
│                   REACTOR EVENT LOOP                           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ while (running) {                                               │
│     // 1. Регистрация обработчиков событий                      │
│     registerHandler(fd, handler, event_type);                   │
│                                                                 │
│     // 2. Ожидание событий (блокируется здесь)                  │
│     int ready = select(max_fd + 1, &read_fds,                  │
│                        &write_fds, &error_fds, &timeout);       │
│                                                                 │
│     // 3. Демультиплексирование событий                         │
│     for (each ready file descriptor) {                          │
│         if (FD_ISSET(fd, &read_fds)) {                         │
│             handler->handleRead();                              │
│         }                                                       │
│         if (FD_ISSET(fd, &write_fds)) {                        │
│             handler->handleWrite();                             │
│         }                                                       │
│         if (FD_ISSET(fd, &error_fds)) {                        │
│             handler->handleError();                             │
│         }                                                       │
│     }                                                           │
│                                                                 │
│     // 4. Обработка таймеров                                    │
│     processTimers();                                            │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘

  ┌────────┐
  │ SELECT │ ← Блокирует до события или таймаута
  └────────┘
      ↓
  ┌────────┐
  │DISPATCH│ ← Вызывает соответствующие обработчики
  └────────┘
      ↓
  ┌────────┐
  │PROCESS │ ← Обрабатывает события
  └────────┘
      ↓
  [Repeat]
```

## ⚡ Типы демультиплексоров

```
┌─────────────────────────────────────────────────────────────────┐
│              ТИПЫ EVENT DEMULTIPLEXERS                         │
└─────────────────────────────────────────────────────────────────┘

┌──────────┬──────────┬──────────────┬──────────────┬─────────────┐
│  SELECT  │  POLL    │    EPOLL     │    KQUEUE    │   IOCP      │
├──────────┼──────────┼──────────────┼──────────────┼─────────────┤
│ POSIX    │ POSIX    │ Linux        │ BSD/macOS    │ Windows     │
│          │          │              │              │             │
│ O(n)     │ O(n)     │ O(1)         │ O(1)         │ O(1)        │
│ linear   │ linear   │ constant     │ constant     │ constant    │
│          │          │              │              │             │
│ Лимит    │ Нет      │ Нет лимита   │ Нет лимита   │ Нет лимита  │
│ 1024 fd  │ лимита   │              │              │             │
│          │          │              │              │             │
│ Копирует │ Копирует │ Не копирует  │ Не копирует  │ Completion  │
│ fd_sets  │ pollfd   │ каждый раз   │ каждый раз   │ ports       │
│          │          │              │              │             │
│ Старый   │ Лучше    │ BEST для     │ BEST для     │ BEST для    │
│ API      │ чем      │ Linux        │ BSD/macOS    │ Windows     │
│          │ select   │              │              │             │
└──────────┴──────────┴──────────────┴──────────────┴─────────────┘
```

## 🌐 TCP Server с Reactor

```
┌─────────────────────────────────────────────────────────────────┐
│             TCP SERVER ИСПОЛЬЗУЯ REACTOR                       │
└─────────────────────────────────────────────────────────────────┘

    ┌────────────────────────────────────────────────┐
    │              SERVER SOCKET (Listener)          │
    │  fd = 3, port = 8080, state = LISTENING        │
    └────────────────────────────────────────────────┘
                        ↓ (accept)
            ┌───────────────────────────┐
            │   New connection arrives  │
            └───────────────────────────┘
                        ↓
    ┌────────────────────────────────────────────────┐
    │        CLIENT SOCKET 1 (fd = 4)                │
    │  Event: READ ready                             │
    │  Handler: AcceptHandler → ConnectionHandler    │
    └────────────────────────────────────────────────┘
    ┌────────────────────────────────────────────────┐
    │        CLIENT SOCKET 2 (fd = 5)                │
    │  Event: WRITE ready                            │
    │  Handler: ConnectionHandler                    │
    └────────────────────────────────────────────────┘
    ┌────────────────────────────────────────────────┐
    │        CLIENT SOCKET 3 (fd = 6)                │
    │  Event: READ ready                             │
    │  Handler: ConnectionHandler                    │
    └────────────────────────────────────────────────┘

                ┌──────────────────┐
                │   REACTOR LOOP   │
                │   select() all   │
                │   file descs     │
                └──────────────────┘
                        ↓
             Dispatches to handlers
                   concurrently
```

## 💡 Сравнение подходов

```
┌─────────────────────────────────────────────────────────────────┐
│           BLOCKING I/O vs NON-BLOCKING I/O REACTOR             │
└─────────────────────────────────────────────────────────────────┘

❌ BLOCKING I/O (Thread per connection):
┌─────────────────────────────────────────────────────────────────┐
│ void handleClient(int client_fd) {                             │
│     while (true) {                                              │
│         char buffer[1024];                                      │
│         ssize_t n = read(client_fd, buffer, 1024);             │
│         // ^^^^^ БЛОКИРУЕТСЯ ЗДЕСЬ! Поток простаивает          │
│                                                                 │
│         if (n <= 0) break;                                      │
│         write(client_fd, buffer, n);  // Echo                  │
│     }                                                           │
│ }                                                               │
│                                                                 │
│ // На каждое соединение - свой поток!                          │
│ while (true) {                                                  │
│     int client = accept(server_fd, ...);                       │
│     std::thread t(handleClient, client);                        │
│     t.detach();  // 10,000 connections = 10,000 threads! 💥   │
│ }                                                               │
│                                                                 │
│ ⚠️ ПРОБЛЕМЫ:                                                   │
│  • Один поток на соединение (не масштабируется)               │
│  • Огромный overhead памяти (каждый поток ~1-8 MB)            │
│  • Context switching при тысячах потоков                       │
│  • C10K problem (не справляется с 10,000 соединений)          │
└─────────────────────────────────────────────────────────────────┘

✅ NON-BLOCKING REACTOR:
┌─────────────────────────────────────────────────────────────────┐
│ class ConnectionHandler : public EventHandler {                 │
│     void handleRead() override {                                │
│         char buffer[1024];                                      │
│         ssize_t n = read(fd_, buffer, 1024);                   │
│         // НЕ блокируется! Читает доступные данные             │
│                                                                 │
│         if (n > 0) {                                            │
│             response_buffer_ = std::string(buffer, n);          │
│         }                                                       │
│     }                                                           │
│                                                                 │
│     void handleWrite() override {                               │
│         ssize_t n = write(fd_, response_buffer_.c_str(), ...); │
│         // НЕ блокируется! Записывает что может                │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ Reactor reactor;                                                │
│ reactor.registerHandler(server_fd, accept_handler, READ);       │
│ reactor.run();  // ОДИН поток обрабатывает ВСЕ соединения!    │
│                                                                 │
│ ✅ ПРЕИМУЩЕСТВА:                                               │
│  • Один поток → множество соединений                           │
│  • Минимальный overhead памяти                                 │
│  • Нет context switching между соединениями                    │
│  • Легко справляется с C10K+ (10,000+ соединений)             │
└─────────────────────────────────────────────────────────────────┘
```

## 🔧 Event Handler интерфейс

```
┌─────────────────────────────────────────────────────────────────┐
│                    EVENT HANDLER INTERFACE                     │
└─────────────────────────────────────────────────────────────────┘

class EventHandler {
public:
    virtual ~EventHandler() = default;
    
    // Вызывается когда данные доступны для чтения
    virtual void handleRead() = 0;
    
    // Вызывается когда можно записать данные
    virtual void handleWrite() = 0;
    
    // Вызывается при ошибке
    virtual void handleError() = 0;
    
    // Вызывается при таймауте
    virtual void handleTimeout() = 0;
    
    // Получить file descriptor
    virtual int getFileDescriptor() const = 0;
};

┌─────────────────────────────────────────────────────────────────┐
│ ПРИМЕРЫ ОБРАБОТЧИКОВ:                                           │
│                                                                 │
│ • AcceptHandler: принимает новые соединения                     │
│ • ConnectionHandler: обрабатывает данные от клиентов            │
│ • TimerHandler: обрабатывает таймеры                            │
│ • SignalHandler: обрабатывает сигналы POSIX                     │
│ • FileHandler: обрабатывает файловые операции                   │
└─────────────────────────────────────────────────────────────────┘
```

## ⏰ Таймеры в Reactor

```
┌─────────────────────────────────────────────────────────────────┐
│                    TIMER MANAGEMENT                            │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  TIMER HEAP (Priority Queue by expiration time)                │
│  ┌──────────────────────────────────────────────────────┐      │
│  │  Timer1: expires at 10:00:00 (100ms)                 │      │
│  │  Timer2: expires at 10:00:05 (500ms)                 │      │
│  │  Timer3: expires at 10:00:10 (1s)                    │      │
│  │  ...                                                  │      │
│  └──────────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────────┘
                        ↓
        ┌───────────────────────────────┐
        │   select() with timeout       │
        │   timeout = next_timer_expiry │
        └───────────────────────────────┘
                        ↓
    ┌──────────────────────────────────────┐
    │  When timer expires:                 │
    │  1. Pop from timer heap              │
    │  2. Call timer callback              │
    │  3. If repeating, re-add to heap     │
    └──────────────────────────────────────┘

ПРИМЕР:
reactor.addTimer(std::chrono::milliseconds(1000), []() {
    std::cout << "1 second passed!" << std::endl;
}, true);  // repeating = true
```

## ⚠️ Проблемы и решения

```
┌─────────────────────────────────────────────────────────────────┐
│                  ТИПИЧНЫЕ ПРОБЛЕМЫ И РЕШЕНИЯ                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   SINGLE        │  РЕШЕНИЕ:                                     │
│   THREAD        │  • Multi-Reactor pattern (один Reactor на CPU)│
│   BOTTLENECK    │  • Leader/Followers pattern                   │
│                 │  • Hybrid: Reactor + Thread Pool              │
│   Один поток не │  • Асинхронная обработка в handlers           │
│   справляется с │                                               │
│   нагрузкой     │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   LONG          │  РЕШЕНИЕ:                                     │
│   HANDLERS      │  • Offload к Thread Pool                      │
│                 │  • Chunked processing (обработка частями)     │
│   Handler       │  • Async I/O с completion callbacks           │
│   блокирует     │  • State machine для длительных операций      │
│   event loop    │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   FD            │  РЕШЕНИЕ:                                     │
│   EXHAUSTION    │  • Мониторинг открытых FD                     │
│                 │  • Graceful connection limiting               │
│   Закончились   │  • ulimit -n увеличение лимита                │
│   file          │  • Закрытие idle connections                  │
│   descriptors   │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   EVENT LOOP    │  РЕШЕНИЕ:                                     │
│   STARVATION    │  • Fair scheduling для handlers               │
│                 │  • Priority-based event processing            │
│   Некоторые     │  • Round-robin dispatch                       │
│   handlers не   │  • Timeout для обработки событий              │
│   получают CPU  │                                               │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🎓 Варианты Reactor Pattern

```
┌─────────────────────────────────────────────────────────────────┐
│                   ВАРИАНТЫ REACTOR                             │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  1. SINGLE-THREADED REACTOR                                     │
│     • Один event loop                                           │
│     • Простейшая реализация                                     │
│     • Ограничен одним CPU                                       │
│     • Подходит для небольших нагрузок                          │
├─────────────────────────────────────────────────────────────────┤
│  2. MULTI-THREADED REACTOR (Leader/Followers)                   │
│     • Несколько потоков ждут события                            │
│     • "Leader" обрабатывает событие                             │
│     • Другие потоки ждут                                        │
│     • Балансировка нагрузки между потоками                      │
├─────────────────────────────────────────────────────────────────┤
│  3. REACTOR + THREAD POOL                                       │
│     • Reactor для I/O multiplexing                              │
│     • Thread Pool для обработки                                 │
│     • Разделение I/O и вычислений                               │
│     • Масштабируется на много CPU                               │
├─────────────────────────────────────────────────────────────────┤
│  4. MULTIPLE REACTORS                                           │
│     • Один Reactor на CPU core                                  │
│     • Каждый Reactor независим                                  │
│     • Максимальный параллелизм                                  │
│     • Используется в nginx, Node.js cluster                     │
└─────────────────────────────────────────────────────────────────┘
```

## 📊 Reactor vs Proactor

```
┌─────────────────────────────────────────────────────────────────┐
│                   REACTOR vs PROACTOR                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────┬───────────────────────────────────────┐
│        REACTOR          │           PROACTOR                    │
├─────────────────────────┼───────────────────────────────────────┤
│ Синхронный I/O          │ Асинхронный I/O                       │
│ (select/poll/epoll)     │ (IOCP, io_uring, aio)                │
│                         │                                       │
│ Ждет READY              │ Ждет COMPLETION                       │
│ "Данные доступны"       │ "Операция завершена"                  │
│                         │                                       │
│ read() вызывает         │ OS вызывает read() и                  │
│ приложение              │ уведомляет о завершении               │
│                         │                                       │
│ POSIX, Linux, BSD       │ Windows (IOCP), Linux (io_uring)     │
│                         │                                       │
│ Проще реализовать       │ Сложнее, но эффективнее               │
└─────────────────────────┴───────────────────────────────────────┘

REACTOR:                    PROACTOR:
wait for READ ready  →      start async READ
    ↓                           ↓
handler->handleRead()       OS completes read
    ↓                           ↓
read data from socket       handler->handleCompletion(data)
```

## 🚀 Примеры использования

```
┌─────────────────────────────────────────────────────────────────┐
│                  ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ                         │
└─────────────────────────────────────────────────────────────────┘

✅ ПОДХОДИТ ДЛЯ:
  • Web серверы (nginx, lighttpd)
  • Application серверы (Node.js, Redis)
  • Network proxies и load balancers
  • Chat серверы и messaging systems
  • Game серверы с множеством соединений
  • IoT gateways с множеством устройств

❌ НЕ ПОДХОДИТ ДЛЯ:
  • CPU-intensive задачи (блокируют event loop)
  • Блокирующие операции (file I/O, database queries)
  • Real-time системы с жесткими гарантиями
  • Простые single-client приложения
```

## 📚 Связанные паттерны

```
┌─────────────────────────────────────────────────────────────────┐
│                   СВЯЗАННЫЕ ПАТТЕРНЫ                           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│  Proactor       │  • Асинхронная альтернатива Reactor           │
│                 │  • Completion-based вместо ready-based        │
│                 │  • IOCP на Windows                            │
├─────────────────┼───────────────────────────────────────────────┤
│  Half-Sync/     │  • Reactor для I/O (async)                    │
│  Half-Async     │  • Thread Pool для обработки (sync)           │
│                 │  • Разделение concerns                        │
├─────────────────┼───────────────────────────────────────────────┤
│  Leader/        │  • Множество потоков с одним event loop       │
│  Followers      │  • Динамическое назначение "лидера"           │
│                 │  • Балансировка нагрузки                      │
└─────────────────┴───────────────────────────────────────────────┘
```

---

**Автор**: Senior C++ Developer  
**Дата**: 2025-10-07  
**Версия**: 1.0
