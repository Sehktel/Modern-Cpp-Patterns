# 💾 Плакат: Cache-Aside Pattern

## 📋 Обзор паттерна

```
┌─────────────────────────────────────────────────────────────────┐
│                    CACHE-ASIDE PATTERN                         │
└─────────────────────────────────────────────────────────────────┘

🎯 ЦЕЛЬ: Оптимизация доступа к данным через кэширование
🔧 КОМПОНЕНТЫ: Cache + Data Source + Cache Strategy + Invalidation
📈 ПРИМЕНЕНИЕ: Web-приложения, базы данных, API, файловые системы
```

## 🏗️ Архитектура паттерна

```
┌─────────────────────────────────────────────────────────────────┐
│                    АРХИТЕКТУРА CACHE-ASIDE                    │
└─────────────────────────────────────────────────────────────────┘

    ┌─────────────┐    Cache Miss    ┌─────────────┐
    │ Application │ ────────────────▶│ Data Source │
    │             │                  │ (Database)  │
    │             │◀─────────────────│             │
    │             │   Load Data      └─────────────┘
    │             │
    │             │    Store Data
    │             │ ────────────────▶
    │             │                  ┌─────────────┐
    │             │◀─────────────────│    Cache    │
    │             │   Cache Hit      │   (Redis)   │
    └─────────────┘                  └─────────────┘

АЛГОРИТМ CACHE-ASIDE:
┌─────────────────────────────────────────────────────────────────┐
│  1. Проверить кэш на наличие данных                            │
│  2. Если Cache Hit - вернуть данные из кэша                   │
│  3. Если Cache Miss - загрузить данные из источника           │
│  4. Сохранить данные в кэш                                    │
│  5. Вернуть данные приложению                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 Жизненный цикл

```
┌─────────────────────────────────────────────────────────────────┐
│                    ЖИЗНЕННЫЙ ЦИКЛ КЭША                        │
└─────────────────────────────────────────────────────────────────┘

1. ИНИЦИАЛИЗАЦИЯ:
   ┌─────────────┐
   │ Создание    │
   │ кэша        │
   │ и стратегии │
   └─────────────┘
           │
           ▼

2. ОПЕРАЦИИ:
   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
   │ GET Request │    │ Cache      │    │ Data Source │
   │             │───▶│ Check      │───▶│ Load        │
   │             │    │            │    │             │
   └─────────────┘    └─────────────┘    └─────────────┘
           │                   │                   │
           ▼                   ▼                   ▼
   ┌─────────────┐    ┌─────────────┐    ┌─────────────┘
   │ Return      │◀───│ Store Data  │◀───│ Return Data │
   │ Data        │    │ in Cache    │    │             │
   └─────────────┘    └─────────────┘    └─────────────┘

3. ИНВАЛИДАЦИЯ:
   ┌─────────────┐
   │ Data        │
   │ Updated     │
   └─────────────┘
           │
           ▼
   ┌─────────────┐
   │ Invalidate  │
   │ Cache       │
   └─────────────┘
```

## 🛠️ Реализации

```
┌─────────────────────────────────────────────────────────────────┐
│                    ВАРИАНТЫ РЕАЛИЗАЦИИ                         │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│   LRU Cache     │   LFU Cache     │   Multi-Level   │   Smart Cache   │
│                 │                 │   Cache         │                 │
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│ ✅ Простота     │ ✅ Частота      │ ✅ Производи-   │ ✅ Теги         │
│ ✅ Производи-   │    использования│    тельность    │ ✅ Инвалидация  │
│    тельность    │ ✅ Оптимальная  │ ✅ Масштаби-    │ ✅ Гибкость     │
│ ❌ Не учитывает │    для частых   │    руемость     │ ❌ Сложность    │
│    частоту      │    запросов     │ ❌ Сложность    │ ❌ Overhead     │
│                 │ ❌ Overhead     │ ❌ Консистент-  │                 │
│                 │    подсчета     │    ность        │                 │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

## 📊 Алгоритмы кэширования

```
┌─────────────────────────────────────────────────────────────────┐
│                    АЛГОРИТМЫ КЭШИРОВАНИЯ                      │
└─────────────────────────────────────────────────────────────────┘

LRU (Least Recently Used):
┌─────────────────────────────────────────────────────────────────┐
│  [A] → [B] → [C] → [D]  (порядок использования)              │
│   ↑                    ↑                                      │
│  Most Recent          Least Recent                            │
│                                                               │
│  При переполнении удаляется D (самый старый)                 │
└─────────────────────────────────────────────────────────────────┘

LFU (Least Frequently Used):
┌─────────────────────────────────────────────────────────────────┐
│  A: 5 раз  B: 3 раза  C: 1 раз  D: 2 раза                     │
│                                                               │
│  При переполнении удаляется C (наименее используемый)         │
└─────────────────────────────────────────────────────────────────┘

TTL (Time To Live):
┌─────────────────────────────────────────────────────────────────┐
│  Item1: expires in 5min  Item2: expires in 2min               │
│                                                               │
│  Автоматическое удаление по истечении времени                 │
└─────────────────────────────────────────────────────────────────┘
```

## 🎯 Применения

```
┌─────────────────────────────────────────────────────────────────┐
│                    ОБЛАСТИ ПРИМЕНЕНИЯ                         │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Web-приложения  │ • Кэширование HTML страниц                   │
│                 │ • Кэширование API ответов                    │
├─────────────────┼───────────────────────────────────────────────┤
│ Базы данных     │ • Кэширование результатов запросов           │
│                 │ • Кэширование метаданных                     │
├─────────────────┼───────────────────────────────────────────────┤
│ Файловые системы│ • Кэширование файловых блоков                │
│                 │ • Кэширование метаданных файлов              │
├─────────────────┼───────────────────────────────────────────────┤
│ Игровые движки  │ • Кэширование текстур и моделей              │
│                 │ • Кэширование игровых объектов               │
├─────────────────┼───────────────────────────────────────────────┤
│ CDN             │ • Кэширование статического контента          │
│                 │ • Географическое распределение               │
└─────────────────┴───────────────────────────────────────────────┘

❌ ПЛОХИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Критичные данные│ • Когда консистентность важнее производительности│
│                 │ • Финансовые транзакции                     │
├─────────────────┼───────────────────────────────────────────────┤
│ Часто изменяемые│ • Когда данные изменяются чаще чем читаются  │
│ данные          │ • Реальное время                             │
├─────────────────┼───────────────────────────────────────────────┤
│ Большие объекты │ • Когда размер объекта больше размера кэша   │
│                 │ • Видео файлы, изображения высокого разрешения│
└─────────────────┴───────────────────────────────────────────────┘
```

## 🔧 Реализация в C++

```
┌─────────────────────────────────────────────────────────────────┐
│                    КЛЮЧЕВЫЕ КОМПОНЕНТЫ                         │
└─────────────────────────────────────────────────────────────────┘

1. БАЗОВЫЙ ИНТЕРФЕЙС КЭША:
```cpp
template<typename Key, typename Value>
class CacheInterface {
public:
    virtual ~CacheInterface() = default;
    virtual bool get(const Key& key, Value& value) = 0;
    virtual void put(const Key& key, const Value& value) = 0;
    virtual void remove(const Key& key) = 0;
    virtual void clear() = 0;
    virtual size_t size() const = 0;
    virtual bool contains(const Key& key) const = 0;
};
```

2. LRU КЭШ:
```cpp
template<typename Key, typename Value>
class LRUCache : public CacheInterface<Key, Value> {
private:
    size_t capacity_;
    std::list<std::pair<Key, Value>> items_;
    std::unordered_map<Key, typename std::list<std::pair<Key, Value>>::iterator> cache_map_;
    std::mutex mutex_;
    
public:
    bool get(const Key& key, Value& value) override {
        std::lock_guard<std::mutex> lock(mutex_);
        
        auto it = cache_map_.find(key);
        if (it == cache_map_.end()) {
            return false; // Cache miss
        }
        
        // Перемещаем в начало списка (самый недавно использованный)
        items_.splice(items_.begin(), items_, it->second);
        value = it->second->second;
        return true; // Cache hit
    }
    
    void put(const Key& key, const Value& value) override {
        std::lock_guard<std::mutex> lock(mutex_);
        
        auto it = cache_map_.find(key);
        if (it != cache_map_.end()) {
            // Обновляем существующий элемент
            it->second->second = value;
            items_.splice(items_.begin(), items_, it->second);
            return;
        }
        
        // Проверяем емкость
        if (items_.size() >= capacity_) {
            // Удаляем самый старый элемент
            auto last = items_.back();
            cache_map_.erase(last.first);
            items_.pop_back();
        }
        
        // Добавляем новый элемент
        items_.emplace_front(key, value);
        cache_map_[key] = items_.begin();
    }
};
```

3. МНОГОУРОВНЕВЫЙ КЭШ:
```cpp
template<typename Key, typename Value>
class MultiLevelCache : public CacheInterface<Key, Value> {
private:
    std::unique_ptr<CacheInterface<Key, Value>> l1_cache_;  // Быстрый, маленький
    std::unique_ptr<CacheInterface<Key, Value>> l2_cache_; // Медленный, большой
    
public:
    bool get(const Key& key, Value& value) override {
        // Проверяем L1 кэш
        if (l1_cache_->get(key, value)) {
            return true;
        }
        
        // Проверяем L2 кэш
        if (l2_cache_->get(key, value)) {
            // Продвигаем в L1 кэш
            l1_cache_->put(key, value);
            return true;
        }
        
        return false; // Cache miss
    }
};
```

## 🚀 Современные возможности C++17/20

```
┌─────────────────────────────────────────────────────────────────┐
│                    СОВРЕМЕННЫЕ ВОЗМОЖНОСТИ                     │
└─────────────────────────────────────────────────────────────────┘

1. STD::OPTIONAL:
```cpp
std::optional<Value> get(const Key& key) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = cache_map_.find(key);
    if (it == cache_map_.end()) {
        return std::nullopt; // Cache miss
    }
    
    // Обновляем порядок
    items_.splice(items_.begin(), items_, it->second);
    return std::make_optional(it->second->second);
}
```

2. STD::SHARED_MUTEX:
```cpp
class ReadWriteCache {
private:
    mutable std::shared_mutex mutex_;
    
public:
    // Множественные читатели
    std::optional<Value> get(const Key& key) const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        // ... чтение данных
    }
    
    // Единственный писатель
    void put(const Key& key, const Value& value) {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        // ... запись данных
    }
};
```

3. STD::ATOMIC:
```cpp
class AtomicCache {
private:
    std::atomic<size_t> hit_count_{0};
    std::atomic<size_t> miss_count_{0};
    
public:
    double getHitRate() const {
        size_t hits = hit_count_.load();
        size_t misses = miss_count_.load();
        size_t total = hits + misses;
        
        return total > 0 ? (double)hits / total : 0.0;
    }
};
```

## 📈 Статистика и мониторинг

```
┌─────────────────────────────────────────────────────────────────┐
│                    МОНИТОРИНГ ПРОИЗВОДИТЕЛЬНОСТИ               │
└─────────────────────────────────────────────────────────────────┘

КЛЮЧЕВЫЕ МЕТРИКИ:
┌─────────────────────────────────────────────────────────────────┐
│  • Hit Rate (процент попаданий в кэш)                         │
│  • Miss Rate (процент промахов кэша)                          │
│  • Cache Size (текущий размер кэша)                          │
│  • Eviction Rate (скорость вытеснения)                       │
│  • Response Time (время ответа)                               │
│  • Memory Usage (использование памяти)                        │
└─────────────────────────────────────────────────────────────────┘

СТАТИСТИКА В РЕАЛЬНОМ ВРЕМЕНИ:
┌─────────────────────────────────────────────────────────────────┐
│  [Cache Stats]                                                  │
│  Hit Rate: 85.6%                                               │
│  Miss Rate: 14.4%                                              │
│  Cache Size: 1,234/10,000                                      │
│  Evictions: 45/min                                             │
│  Avg Response Time: 1.2ms                                      │
│  Memory Usage: 256MB                                           │
└─────────────────────────────────────────────────────────────────┘
```

## 🧪 Тестирование

```
┌─────────────────────────────────────────────────────────────────┐
│                    ТЕСТИРОВАНИЕ КЭША                          │
└─────────────────────────────────────────────────────────────────┘

1. UNIT ТЕСТЫ:
```cpp
TEST(CacheTest, BasicOperations) {
    LRUCache<std::string, int> cache(3);
    
    EXPECT_TRUE(cache.empty());
    EXPECT_TRUE(cache.put("key1", 42));
    
    int value;
    EXPECT_TRUE(cache.get("key1", value));
    EXPECT_EQ(value, 42);
}
```

2. PERFORMANCE ТЕСТЫ:
```cpp
void performanceTest() {
    LRUCache<int, std::string> cache(1000);
    
    auto start = std::chrono::high_resolution_clock::now();
    
    // Заполняем кэш
    for (int i = 0; i < 10000; ++i) {
        cache.put(i, "value_" + std::to_string(i));
    }
    
    // Тестируем доступ
    for (int i = 0; i < 100000; ++i) {
        std::string value;
        cache.get(i % 1000, value);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    std::cout << "Performance test completed in " << duration.count() << " microseconds" << std::endl;
}
```

3. STRESS ТЕСТЫ:
```cpp
void stressTest() {
    const int NUM_THREADS = 8;
    const int OPERATIONS_PER_THREAD = 10000;
    
    LRUCache<int, std::string> cache(1000);
    std::atomic<int> operations{0};
    
    std::vector<std::thread> threads;
    
    for (int i = 0; i < NUM_THREADS; ++i) {
        threads.emplace_back([&, i]() {
            for (int j = 0; j < OPERATIONS_PER_THREAD; ++j) {
                int key = (i * OPERATIONS_PER_THREAD + j) % 1000;
                
                if (j % 2 == 0) {
                    cache.put(key, "value_" + std::to_string(key));
                } else {
                    std::string value;
                    cache.get(key, value);
                }
                
                operations.fetch_add(1);
            }
        });
    }
    
    for (auto& t : threads) t.join();
    
    EXPECT_EQ(operations.load(), NUM_THREADS * OPERATIONS_PER_THREAD);
}
```

## 🎯 Рекомендации по использованию

```
┌─────────────────────────────────────────────────────────────────┐
│                    ЛУЧШИЕ ПРАКТИКИ                             │
└─────────────────────────────────────────────────────────────────┘

1. 🎯 ВЫБОР СТРАТЕГИИ:
   • LRU - для большинства случаев
   • LFU - для частых повторных запросов
   • TTL - для данных с временными ограничениями
   • Multi-Level - для критичной производительности

2. 🔧 ПРИНЦИПЫ ПРОЕКТИРОВАНИЯ:
   • Определите оптимальный размер кэша
   • Выберите подходящую стратегию инвалидации
   • Мониторьте hit rate
   • Используйте thread-safe реализации

3. 🧪 ТЕСТИРОВАНИЕ:
   • Unit тесты для базовой функциональности
   • Performance тесты для производительности
   • Stress тесты для многопоточности
   • Memory leak тесты

4. ⚡ ПРОИЗВОДИТЕЛЬНОСТЬ:
   • Профилируйте критические участки
   • Оптимизируйте размер кэша
   • Используйте lock-free структуры где возможно
   • Минимизируйте время блокировок

5. 📚 ДОКУМЕНТАЦИЯ:
   • Документируйте стратегии кэширования
   • Описывайте политики инвалидации
   • Приводите примеры использования
   • Объясняйте trade-offs

6. 🔄 РЕФАКТОРИНГ:
   • Начинайте с простой реализации
   • Добавляйте оптимизации постепенно
   • Измеряйте производительность на каждом шаге
   • Рассматривайте альтернативы
```

## 🚨 Предупреждения

```
┌─────────────────────────────────────────────────────────────────┐
│                    ЧАСТЫЕ ОШИБКИ                               │
└─────────────────────────────────────────────────────────────────┘

❌ НЕ ДЕЛАЙТЕ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Забывать        │ • Проверять thread safety                    │
│ многопоточность │ • Использовать правильные мьютексы           │
├─────────────────┼───────────────────────────────────────────────┤
│ Игнорировать    │ • Мониторить hit rate                        │
│ производительность│ • Оптимизировать размер кэша               │
├─────────────────┼───────────────────────────────────────────────┤
│ Создавать       │ • Использовать RAII для ресурсов             │
│ утечки памяти   │ • Правильно освобождать память               │
├─────────────────┼───────────────────────────────────────────────┤
│ Игнорировать    │ • Реализовать стратегии инвалидации          │
│ консистентность │ • Обрабатывать race conditions               │
└─────────────────┴───────────────────────────────────────────────┘

✅ ДЕЛАЙТЕ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Используйте     │ • std::lock_guard для автоматического        │
│ RAII            │   освобождения мьютексов                     │
├─────────────────┼───────────────────────────────────────────────┤
│ Проверяйте      │ • Возвращаемые значения get/put              │
│ результаты      │ • Состояние кэша перед операциями            │
├─────────────────┼───────────────────────────────────────────────┤
│ Мониторьте      │ • Hit rate и miss rate                       │
│ производительность│ • Время ответа                               │
│                 │ • Использование памяти                        │
├─────────────────┼───────────────────────────────────────────────┤
│ Тестируйте      │ • Многопоточность тщательно                  │
│ тщательно       │ • Различные сценарии нагрузки                │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🔗 Связь с другими паттернами

```
┌─────────────────────────────────────────────────────────────────┐
│                    СВЯЗЬ С ДРУГИМИ ПАТТЕРНАМИ                 │
└─────────────────────────────────────────────────────────────────┘

Cache-Aside vs Write-Through:
┌─────────────────┬───────────────────────────────────────────────┐
│ Cache-Aside     │ • Приложение управляет кэшем                 │
│                 │ • Запись в источник, затем в кэш             │
│ Write-Through   │ • Кэш управляет записью                      │
│                 │ • Запись в кэш и источник одновременно       │
└─────────────────┴───────────────────────────────────────────────┘

Cache-Aside vs Write-Behind:
┌─────────────────┬───────────────────────────────────────────────┐
│ Cache-Aside     │ • Синхронная запись в источник               │
│                 │ • Простота реализации                         │
│ Write-Behind    │ • Асинхронная запись в источник             │
│                 │ • Высокая производительность записи          │
└─────────────────┴───────────────────────────────────────────────┘

Cache-Aside vs Object Pool:
┌─────────────────┬───────────────────────────────────────────────┐
│ Cache-Aside     │ • Кэширование данных                         │
│                 │ • Оптимизация доступа к данным                │
│ Object Pool     │ • Переиспользование объектов                 │
│                 │ • Оптимизация создания объектов              │
└─────────────────┴───────────────────────────────────────────────┘
```

## 📚 Дополнительные ресурсы

```
┌─────────────────────────────────────────────────────────────────┐
│                    ДОПОЛНИТЕЛЬНЫЕ РЕСУРСЫ                     │
└─────────────────────────────────────────────────────────────────┘

📖 КНИГИ:
• "Designing Data-Intensive Applications" - Martin Kleppmann
• "High Performance MySQL" - Baron Schwartz
• "Redis in Action" - Josiah Carlson

🌐 ОНЛАЙН РЕСУРСЫ:
• Redis Documentation - кэширование
• Memcached Documentation - распределенное кэширование
• Caffeine - высокопроизводительный кэш для Java

🛠️ ИНСТРУМЕНТЫ:
• Redis - in-memory кэш
• Memcached - распределенный кэш
• Caffeine - локальный кэш
• Ehcache - enterprise кэш

📝 СТАНДАРТЫ:
• HTTP Caching (RFC 7234)
• Cache-Control headers
• ETag и Last-Modified
• CDN кэширование
```

---

*Помните: Cache-Aside - это мощный паттерн для оптимизации производительности, но используйте его с пониманием trade-offs и тщательным мониторингом!* 🚀
