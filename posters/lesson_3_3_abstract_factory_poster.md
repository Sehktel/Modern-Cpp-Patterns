# 📊 Плакат: Abstract Factory Pattern (Абстрактная фабрика)

## 🎯 Назначение паттерна Abstract Factory

```
┌─────────────────────────────────────────────────────────────────┐
│                   ABSTRACT FACTORY PATTERN                     │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  🏭 СОЗДАЕТ СЕМЕЙСТВА СВЯЗАННЫХ ОБЪЕКТОВ                       │
│  🎨 ИНКАПСУЛИРУЕТ СОЗДАНИЕ КОНКРЕТНЫХ ПРОДУКТОВ                │
│  🔄 ОБЕСПЕЧИВАЕТ СОВМЕСТИМОСТЬ ОБЪЕКТОВ В СЕМЕЙСТВЕ            │
└─────────────────────────────────────────────────────────────────┘

Применение:
┌─────────────────┬───────────────────────────────────────────────┐
│   UI Framework  │ • Создание элементов интерфейса для разных   │
│                 │   операционных систем (Windows, macOS, Linux)  │
├─────────────────┼───────────────────────────────────────────────┤
│   Игровые движки│ • Создание персонажей, оружия, окружения для  │
│                 │   разных стилей игры (фэнтези, sci-fi, реализм)│
├─────────────────┼───────────────────────────────────────────────┤
│   Базы данных   │ • Создание подключений, запросов, транзакций  │
│                 │   для разных СУБД (MySQL, PostgreSQL, Oracle) │
├─────────────────┼───────────────────────────────────────────────┤
│   Документы     │ • Создание различных типов документов и       │
│                 │   их компонентов (заголовки, таблицы, графики) │
├─────────────────┼───────────────────────────────────────────────┤
│   Транспорт     │ • Создание автомобилей разных марок с их      │
│                 │   специфичными компонентами                   │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🔄 Проблема без Abstract Factory

```
┌─────────────────────────────────────────────────────────────────┐
│                    ПРОБЛЕМА: НЕСОВМЕСТИМОСТЬ                   │
└─────────────────────────────────────────────────────────────────┘

❌ ПЛОХО - Нарушение принципов:
┌─────────────────────────────────────────────────────────────────┐
│ class UIFramework {                                             │
│ public:                                                         │
│     void createUI(const std::string& os) {                     │
│         if (os == "Windows") {                                 │
│             WindowsButton button;      ← Несовместимость!      │
│             WindowsMenu menu;          ← Несовместимость!      │
│             WindowsDialog dialog;      ← Несовместимость!      │
│         } else if (os == "macOS") {                             │
│             MacOSButton button;        ← Несовместимость!      │
│             MacOSMenu menu;            ← Несовместимость!      │
│             MacOSDialog dialog;        ← Несовместимость!      │
│         }                                                       │
│         // Проблемы:                                            │
│         // • Нарушение Open/Closed Principle                   │
│         // • Сложно добавлять новые ОС                         │
│         // • Нарушение Dependency Inversion Principle          │
│         // • Несовместимость компонентов                       │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘
```

## ✅ Решение с Abstract Factory

```
┌─────────────────────────────────────────────────────────────────┐
│                    РЕШЕНИЕ: СЕМЕЙСТВА ОБЪЕКТОВ                 │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШО - Соблюдение принципов:
┌─────────────────────────────────────────────────────────────────┐
│ class UIFramework {                                             │
│ private:                                                        │
│     std::unique_ptr<UIFactory> factory_;                       │
│                                                                 │
│ public:                                                         │
│     UIFramework(std::unique_ptr<UIFactory> factory)             │
│         : factory_(std::move(factory)) {}                       │
│                                                                 │
│     void createUI() {                                           │
│         auto button = factory_->createButton();  ← Совместимость│
│         auto menu = factory_->createMenu();      ← Совместимость│
│         auto dialog = factory_->createDialog();  ← Совместимость│
│                                                                 │
│         // Все компоненты совместимы!                           │
│         button->render();                                       │
│         menu->addItem("File");                                  │
│         dialog->show();                                         │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘

Преимущества:
✅ Соблюдение Open/Closed Principle
✅ Легко добавлять новые семейства
✅ Соблюдение Dependency Inversion Principle
✅ Гарантированная совместимость компонентов
✅ Инкапсуляция логики создания семейств
```

## 🏗️ Структура Abstract Factory

```
┌─────────────────────────────────────────────────────────────────┐
│                    СТРУКТУРА ПАТТЕРНА                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Abstract Products (Абстрактные продукты)    │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class Button {                                              ││
│  │ public:                                                     ││
│  │     virtual void render() = 0;                             ││
│  │     virtual void onClick() = 0;                            ││
│  │ };                                                          ││
│  │                                                             ││
│  │ class Menu {                                                ││
│  │ public:                                                     ││
│  │     virtual void addItem(const std::string& item) = 0;     ││
│  │     virtual void show() = 0;                                ││
│  │ };                                                          ││
│  │                                                             ││
│  │ class Dialog {                                              ││
│  │ public:                                                     ││
│  │     virtual void show() = 0;                                ││
│  │     virtual void hide() = 0;                                ││
│  │ };                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Concrete Products (Конкретные продукты)     │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class WindowsButton : public Button {                     ││
│  │ public:                                                     ││
│  │     void render() override { /* Windows стиль */ }         ││
│  │     void onClick() override { /* Windows поведение */ }    ││
│  │ };                                                          ││
│  │                                                             ││
│  │ class WindowsMenu : public Menu {                         ││
│  │ public:                                                     ││
│  │     void addItem(const std::string& item) override {       ││
│  │         /* Windows меню */                                 ││
│  │     }                                                       ││
│  │     void show() override { /* Windows меню */ }            ││
│  │ };                                                          ││
│  │                                                             ││
│  │ class WindowsDialog : public Dialog {                      ││
│  │ public:                                                     ││
│  │     void show() override { /* Windows диалог */ }          ││
│  │     void hide() override { /* Windows диалог */ }           ││
│  │ };                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Abstract Factory (Абстрактная фабрика)     │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class UIFactory {                                            ││
│  │ public:                                                      ││
│  │     virtual ~UIFactory() = default;                         ││
│  │     virtual std::unique_ptr<Button> createButton() = 0;     ││
│  │     virtual std::unique_ptr<Menu> createMenu() = 0;          ││
│  │     virtual std::unique_ptr<Dialog> createDialog() = 0;     ││
│  │ };                                                           ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Concrete Factories (Конкретные фабрики)     │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class WindowsUIFactory : public UIFactory {                 ││
│  │ public:                                                      ││
│  │     std::unique_ptr<Button> createButton() override {        ││
│  │         return std::make_unique<WindowsButton>();             ││
│  │     }                                                        ││
│  │     std::unique_ptr<Menu> createMenu() override {            ││
│  │         return std::make_unique<WindowsMenu>();               ││
│  │     }                                                        ││
│  │     std::unique_ptr<Dialog> createDialog() override {        ││
│  │         return std::make_unique<WindowsDialog>();             ││
│  │     }                                                        ││
│  │ };                                                           ││
│  │                                                              ││
│  │ class MacOSUIFactory : public UIFactory {                   ││
│  │ public:                                                      ││
│  │     std::unique_ptr<Button> createButton() override {       ││
│  │         return std::make_unique<MacOSButton>();              ││
│  │     }                                                        ││
│  │     std::unique_ptr<Menu> createMenu() override {            ││
│  │         return std::make_unique<MacOSMenu>();                 ││
│  │     }                                                        ││
│  │     std::unique_ptr<Dialog> createDialog() override {        ││
│  │         return std::make_unique<MacOSDialog>();               ││
│  │     }                                                        ││
│  │ };                                                           ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 Последовательность взаимодействий

```
┌─────────────────────────────────────────────────────────────────┐
│                ПОСЛЕДОВАТЕЛЬНОСТЬ ВЗАИМОДЕЙСТВИЙ               │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   1. Клиент     │ UIFramework framework(factory);                │
│      создает     │                                               │
│      фабрику    │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   2. Клиент     │ framework.createUI();                          │
│      запрашивает│                                               │
│      создание   │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   3. Фабрика    │ factory->createButton() → WindowsButton       │
│      создает    │ factory->createMenu() → WindowsMenu            │
│      продукты   │ factory->createDialog() → WindowsDialog        │
├─────────────────┼───────────────────────────────────────────────┤
│   4. Клиент     │ button->render();                             │
│      использует │ menu->addItem("File");                         │
│      продукты   │ dialog->show();                               │
└─────────────────┴───────────────────────────────────────────────┘

Диаграмма взаимодействий:
┌─────────────────────────────────────────────────────────────────┐
│  Client ──┐                                                    │
│           │                                                    │
│           ▼                                                    │
│  UIFramework ──┐                                               │
│                 │                                               │
│                 ▼                                               │
│  UIFactory ──┐                                                  │
│               │                                                  │
│               ▼                                                  │
│  WindowsUIFactory ──┐                                           │
│                       │                                           │
│                       ▼                                           │
│  WindowsButton ──┐                                                 │
│  WindowsMenu ────┤                                                 │
│  WindowsDialog ──┘                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 🎨 Варианты реализации

### 1. Классическая Abstract Factory
```
┌─────────────────────────────────────────────────────────────────┐
│                КЛАССИЧЕСКАЯ ABSTRACT FACTORY                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ // Абстрактные продукты                                        │
│ class Document {                                                │
│ public:                                                         │
│     virtual void open() = 0;                                   │
│     virtual void save() = 0;                                   │
│ };                                                              │
│                                                                 │
│ class Spreadsheet : public Document {                           │
│ public:                                                         │
│     virtual void calculate() = 0;                              │
│ };                                                              │
│                                                                 │
│ // Абстрактная фабрика                                         │
│ class DocumentFactory {                                         │
│ public:                                                         │
│     virtual std::unique_ptr<Document> createDocument() = 0;     │
│     virtual std::unique_ptr<Spreadsheet> createSpreadsheet() = 0;│
│ };                                                              │
│                                                                 │
│ // Конкретные фабрики                                          │
│ class OfficeFactory : public DocumentFactory {                  │
│ public:                                                         │
│     std::unique_ptr<Document> createDocument() override {       │
│         return std::make_unique<OfficeDocument>();             │
│     }                                                           │
│     std::unique_ptr<Spreadsheet> createSpreadsheet() override {│
│         return std::make_unique<OfficeSpreadsheet>();           │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘
```

### 2. Template-based Abstract Factory
```
┌─────────────────────────────────────────────────────────────────┐
│                TEMPLATE-BASED ABSTRACT FACTORY                │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ template<typename ProductType>                                  │
│ class AbstractFactory {                                         │
│ public:                                                         │
│     virtual std::unique_ptr<ProductType> create() = 0;         │
│ };                                                              │
│                                                                 │
│ template<typename ConcreteProduct>                              │
│ class ConcreteFactory : public AbstractFactory<ConcreteProduct> {│
│ public:                                                         │
│     std::unique_ptr<ConcreteProduct> create() override {       │
│         return std::make_unique<ConcreteProduct>();             │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ // Использование                                               │
│ using ButtonFactory = AbstractFactory<Button>;                 │
│ using WindowsButtonFactory = ConcreteFactory<WindowsButton>;   │
│                                                                 │
│ auto factory = std::make_unique<WindowsButtonFactory>();        │
│ auto button = factory->create();                                │
└─────────────────────────────────────────────────────────────────┘
```

### 3. Registry-based Abstract Factory
```
┌─────────────────────────────────────────────────────────────────┐
│                REGISTRY-BASED ABSTRACT FACTORY                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ class FactoryRegistry {                                          │
│ private:                                                        │
│     std::map<std::string, std::function<std::unique_ptr<UIFactory>()>> │
│         factories_;                                             │
│                                                                 │
│ public:                                                         │
│     template<typename FactoryType>                              │
│     void registerFactory(const std::string& name) {            │
│         factories_[name] = []() {                               │
│             return std::make_unique<FactoryType>();             │
│         };                                                      │
│     }                                                           │
│                                                                 │
│     std::unique_ptr<UIFactory> createFactory(const std::string& name) {│
│         auto it = factories_.find(name);                        │
│         if (it != factories_.end()) {                           │
│             return it->second();                                │
│         }                                                       │
│         throw std::invalid_argument("Unknown factory: " + name);│
│     }                                                           │
│ };                                                              │
│                                                                 │
│ // Регистрация                                                  │
│ FactoryRegistry registry;                                       │
│ registry.registerFactory<WindowsUIFactory>("windows");          │
│ registry.registerFactory<MacOSUIFactory>("macos");              │
│                                                                 │
│ // Использование                                                │
│ auto factory = registry.createFactory("windows");               │
│ auto button = factory->createButton();                          │
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 Сравнение подходов

```
┌─────────────────────────────────────────────────────────────────┐
│                    СРАВНЕНИЕ ПОДХОДОВ                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│   Классическая  │   Template-based│   Registry-based│   Hybrid        │
│   Abstract      │   Abstract      │   Abstract      │   Abstract      │
│   Factory       │   Factory       │   Factory       │   Factory       │
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│ Простота        │ Средняя         │ Высокая         │ Низкая          │
│ Расширяемость   │ Высокая         │ Высокая         │ Очень высокая   │
│ Гибкость        │ Высокая         │ Средняя         │ Очень высокая   │
│ Производительность│ Высокая        │ Высокая         │ Средняя         │
│ Тестируемость   │ Высокая         │ Высокая         │ Высокая         │
│ Применимость    │ Стандартные     │ Шаблонные       │ Плагины         │
│                 │ семейства       │ семейства       │ системы         │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

## 🎯 Когда использовать Abstract Factory

```
┌─────────────────────────────────────────────────────────────────┐
│                КОГДА ИСПОЛЬЗОВАТЬ ABSTRACT FACTORY            │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Семейства       │ • Нужно создавать семейства связанных объектов│
│ объектов        │ • Объекты должны быть совместимы друг с другом│
├─────────────────┼───────────────────────────────────────────────┤
│ Платформы       │ • Разные реализации для разных платформ      │
│                 │ • Кроссплатформенные приложения              │
├─────────────────┼───────────────────────────────────────────────┤
│ Стили           │ • Разные стили оформления (темы)             │
│                 │ • Конфигурируемые интерфейсы                  │
├─────────────────┼───────────────────────────────────────────────┤
│ Конфигурации    │ • Разные конфигурации системы                 │
│                 │ • Переключение между режимами работы           │
├─────────────────┼───────────────────────────────────────────────┤
│ Тестирование    │ • Нужно легко создавать моки для тестов      │
│                 │ • Изоляция тестовых данных                    │
└─────────────────┴───────────────────────────────────────────────┘

❌ ПЛОХИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Простые объекты │ • Создание простых, несвязанных объектов      │
├─────────────────┼───────────────────────────────────────────────┤
│ Один тип        │ • Всегда создается один и тот же тип         │
├─────────────────┼───────────────────────────────────────────────┤
│ Производительность│ • Критична производительность создания     │
├─────────────────┼───────────────────────────────────────────────┤
│ Сложность       │ • Добавляется ненужная сложность             │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🧪 Тестирование Abstract Factory

```
┌─────────────────────────────────────────────────────────────────┐
│                ТЕСТИРОВАНИЕ ABSTRACT FACTORY                   │
└─────────────────────────────────────────────────────────────────┘

Преимущества для тестирования:
┌─────────────────┬───────────────────────────────────────────────┐
│ Моки            │ ✅ Легко создавать моки для фабрик           │
│                 │ class MockUIFactory : public UIFactory {      │
│                 │     MOCK_METHOD(std::unique_ptr<Button>,      │
│                 │                  createButton, ());           │
│                 │     MOCK_METHOD(std::unique_ptr<Menu>,         │
│                 │                  createMenu, ());             │
│                 │     MOCK_METHOD(std::unique_ptr<Dialog>,       │
│                 │                  createDialog, ());           │
│                 │ };                                            │
├─────────────────┼───────────────────────────────────────────────┤
│ Изоляция        │ ✅ Легко изолировать тесты                   │
│                 │ auto mockFactory = std::make_unique<MockUIFactory>(); │
│                 │ UIFramework framework(std::move(mockFactory)); │
├─────────────────┼───────────────────────────────────────────────┤
│ Управление      │ ✅ Полный контроль над создаваемыми объектами│
│ зависимостями   │ EXPECT_CALL(*mockFactory, createButton())     │
│                 │     .WillOnce(Return(ByMove(std::make_unique<MockButton>()))); │
└─────────────────┴───────────────────────────────────────────────┘

Пример теста:
┌─────────────────────────────────────────────────────────────────┐
│ TEST(UIFrameworkTest, CreateUI) {                               │
│     auto mockFactory = std::make_unique<MockUIFactory>();        │
│     auto mockButton = std::make_unique<MockButton>();            │
│     auto mockMenu = std::make_unique<MockMenu>();                 │
│     auto mockDialog = std::make_unique<MockDialog>();            │
│                                                                 │
│     EXPECT_CALL(*mockFactory, createButton())                    │
│         .WillOnce(Return(ByMove(std::move(mockButton))));       │
│     EXPECT_CALL(*mockFactory, createMenu())                      │
│         .WillOnce(Return(ByMove(std::move(mockMenu))));          │
│     EXPECT_CALL(*mockFactory, createDialog())                    │
│         .WillOnce(Return(ByMove(std::move(mockDialog))));        │
│                                                                 │
│     UIFramework framework(std::move(mockFactory));               │
│     framework.createUI();                                        │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

## 🔗 Связь с другими паттернами

```
┌─────────────────────────────────────────────────────────────────┐
│              СВЯЗЬ С ДРУГИМИ ПАТТЕРНАМИ                        │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│ Factory Method  │ • Abstract Factory использует Factory Method  │
│                 │ • Factory Method создает один тип объекта    │
│                 │ • Abstract Factory создает семейства объектов│
│                 │ • Abstract Factory - композиция Factory Method│
├─────────────────┼───────────────────────────────────────────────┤
│ Builder         │ • Abstract Factory создает объекты в один шаг│
│                 │ • Builder создает объекты пошагово           │
│                 │ • Abstract Factory - простые объекты         │
│                 │ • Builder - сложные объекты                  │
├─────────────────┼───────────────────────────────────────────────┤
│ Prototype       │ • Abstract Factory создает новые объекты     │
│                 │ • Prototype клонирует существующие объекты  │
│                 │ • Abstract Factory - стандартное создание    │
│                 │ • Prototype - копирование                    │
├─────────────────┼───────────────────────────────────────────────┤
│ Singleton       │ • Abstract Factory может использовать Singleton│
│                 │ • Singleton может быть фабрикой              │
│                 │ • Вместе обеспечивают глобальный доступ     │
├─────────────────┼───────────────────────────────────────────────┤
│ Facade          │ • Abstract Factory может быть частью Facade │
│                 │ • Facade упрощает работу с Abstract Factory  │
│                 │ • Abstract Factory - создание                │
│                 │ • Facade - упрощение интерфейса              │
└─────────────────┴───────────────────────────────────────────────┘
```

## 💡 Практические рекомендации

```
┌─────────────────────────────────────────────────────────────────┐
│                  ПРАКТИЧЕСКИЕ РЕКОМЕНДАЦИИ                     │
└─────────────────────────────────────────────────────────────────┘

1. 🎯 Выбор реализации:
   • Классическая Abstract Factory - для стандартных семейств
   • Template-based - для шаблонных семейств
   • Registry-based - для плагинной архитектуры
   • Hybrid - для сложных систем

2. 🔧 Принципы проектирования:
   • Соблюдайте Open/Closed Principle
   • Используйте Dependency Inversion
   • Инкапсулируйте логику создания семейств
   • Обеспечьте совместимость объектов

3. 🧪 Тестирование:
   • Создавайте интерфейсы для фабрик
   • Используйте моки в тестах
   • Тестируйте различные семейства объектов
   • Проверяйте совместимость компонентов

4. ⚡ Производительность:
   • Рассмотрите кэширование объектов
   • Используйте move semantics
   • Избегайте ненужных копирований
   • Профилируйте критические участки

5. 📚 Документация:
   • Документируйте поддерживаемые семейства
   • Описывайте совместимость компонентов
   • Приводите примеры использования
   • Объясняйте причины выбора паттерна

6. 🔄 Рефакторинг:
   • Начинайте с простых семейств
   • Постепенно добавляйте сложность
   • Используйте интерфейсы для абстракции
   • Планируйте расширяемость
```

## 🎓 Ключевые выводы

```
┌─────────────────────────────────────────────────────────────────┐
│                      КЛЮЧЕВЫЕ ВЫВОДЫ                          │
└─────────────────────────────────────────────────────────────────┘

✅ Abstract Factory - мощный инструмент:
   • Создает семейства связанных объектов
   • Обеспечивает совместимость компонентов
   • Следует принципам SOLID
   • Упрощает тестирование

✅ Выбирайте подходящую реализацию:
   • Классическая - для стандартных семейств
   • Template-based - для шаблонных семейств
   • Registry-based - для плагинов
   • Hybrid - для сложных систем

✅ Используйте правильно:
   • Когда нужны семейства связанных объектов
   • Когда важна совместимость компонентов
   • Когда нужна расширяемость
   • Когда важна тестируемость

✅ Избегайте злоупотребления:
   • Не используйте для простых объектов
   • Не добавляйте сложность без необходимости
   • Не забывайте об обработке ошибок
   • Не нарушайте принципы SOLID

✅ Помните о компромиссах:
   • Сложность vs гибкость
   • Производительность vs расширяемость
   • Простота vs функциональность
   • Тестируемость vs производительность
```

---
*Abstract Factory - это архитектурный паттерн для создания семейств связанных объектов. 
Используйте его для обеспечения совместимости и расширяемости ваших систем!*
