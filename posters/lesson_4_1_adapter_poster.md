# 📊 Плакат: Adapter Pattern (Адаптер)

## 🎯 Назначение паттерна Adapter

```
┌─────────────────────────────────────────────────────────────────┐
│                        ADAPTER PATTERN                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  🔌 ОБЕСПЕЧИВАЕТ СОВМЕСТИМОСТЬ НЕСОВМЕСТИМЫХ ИНТЕРФЕЙСОВ       │
│  🔄 ПРЕОБРАЗУЕТ ИНТЕРФЕЙС ОДНОГО КЛАССА В ИНТЕРФЕЙС ДРУГОГО     │
│  🎯 ПОЗВОЛЯЕТ КЛАССАМ РАБОТАТЬ ВМЕСТЕ, КОТОРЫЕ ИНАЧЕ НЕ МОГЛИ БЫ│
└─────────────────────────────────────────────────────────────────┘

Применение:
┌─────────────────┬───────────────────────────────────────────────┐
│   Legacy Code   │ • Интеграция старого кода с новыми системами │
├─────────────────┼───────────────────────────────────────────────┤
│   Third-party   │ • Использование внешних библиотек с           │
│   Libraries     │   несовместимыми интерфейсами                │
├─────────────────┼───────────────────────────────────────────────┤
│   API Integration│ • Интеграция различных API и сервисов         │
├─────────────────┼───────────────────────────────────────────────┤
│   Data Formats  │ • Преобразование данных между форматами       │
├─────────────────┼───────────────────────────────────────────────┤
│   Protocols     │ • Адаптация различных протоколов связи       │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🔄 Проблема без Adapter

```
┌─────────────────────────────────────────────────────────────────┐
│                    ПРОБЛЕМА: НЕСОВМЕСТИМОСТЬ                   │
└─────────────────────────────────────────────────────────────────┘

❌ ПЛОХО - Несовместимые интерфейсы:
┌─────────────────────────────────────────────────────────────────┐
│ // Старая система (Legacy)                                     │
│ class LegacyPrinter {                                           │
│ public:                                                          │
│     void printDocument(const std::string& doc) {               │
│         // Старый формат печати                                 │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ // Новая система                                                │
│ class ModernPrinter {                                           │
│ public:                                                         │
│     void print(const Document& doc) {                           │
│         // Новый формат печати                                  │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ // Клиентский код                                               │
│ class DocumentProcessor {                                        │
│ public:                                                         │
│     void processDocument(const Document& doc) {                 │
│         ModernPrinter printer;                                  │
│         printer.print(doc);                                     │
│                                                                 │
│         // Проблема: как использовать LegacyPrinter?           │
│         // LegacyPrinter legacyPrinter;                        │
│         // legacyPrinter.printDocument(???); ← Несовместимость!│
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘
```

## ✅ Решение с Adapter

```
┌─────────────────────────────────────────────────────────────────┐
│                    РЕШЕНИЕ: АДАПТАЦИЯ ИНТЕРФЕЙСА                │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШО - Совместимость через адаптер:
┌─────────────────────────────────────────────────────────────────┐
│ // Адаптер для LegacyPrinter                                   │
│ class LegacyPrinterAdapter : public Printer {                   │
│ private:                                                        │
│     LegacyPrinter legacyPrinter_;                               │
│                                                                 │
│ public:                                                         │
│     void print(const Document& doc) override {                 │
│         // Преобразуем Document в std::string                   │
│         std::string docString = doc.toString();                 │
│         legacyPrinter_.printDocument(docString);                │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ // Клиентский код                                               │
│ class DocumentProcessor {                                        │
│ public:                                                         │
│     void processDocument(const Document& doc) {                 │
│         // Теперь можем использовать любой принтер!             │
│         ModernPrinter modernPrinter;                            │
│         modernPrinter.print(doc);                               │
│                                                                 │
│         LegacyPrinterAdapter legacyAdapter;                     │
│         legacyAdapter.print(doc); ← Совместимость!             │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘

Преимущества:
✅ Совместимость несовместимых интерфейсов
✅ Переиспользование существующего кода
✅ Инкапсуляция логики преобразования
✅ Соблюдение принципов SOLID
```

## 🏗️ Структура Adapter

```
┌─────────────────────────────────────────────────────────────────┐
│                    СТРУКТУРА ПАТТЕРНА                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Target (Целевой интерфейс)                  │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class Printer {                                              ││
│  │ public:                                                      ││
│  │     virtual void print(const Document& doc) = 0;            ││
│  │     virtual ~Printer() = default;                           ││
│  │ };                                                           ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Adaptee (Адаптируемый класс)                │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class LegacyPrinter {                                        ││
│  │ public:                                                      ││
│  │     void printDocument(const std::string& doc) {             ││
│  │         // Старая реализация печати                         ││
│  │     }                                                        ││
│  │ };                                                           ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Adapter (Адаптер)                            │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class LegacyPrinterAdapter : public Printer {               ││
│  │ private:                                                     ││
│  │     LegacyPrinter legacyPrinter_;                            ││
│  │                                                              ││
│  │ public:                                                      ││
│  │     void print(const Document& doc) override {               ││
│  │         // Преобразование Document → std::string             ││
│  │         std::string docString = doc.toString();             ││
│  │         legacyPrinter_.printDocument(docString);            ││
│  │     }                                                        ││
│  │ };                                                           ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Client (Клиент)                              │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class DocumentProcessor {                                     ││
│  │ public:                                                      ││
│  │     void processDocument(const Document& doc) {             ││
│  │         Printer* printer = getPrinter();                     ││
│  │         printer->print(doc);                                 ││
│  │     }                                                        ││
│  │ };                                                           ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 Последовательность взаимодействий

```
┌─────────────────────────────────────────────────────────────────┐
│                ПОСЛЕДОВАТЕЛЬНОСТЬ ВЗАИМОДЕЙСТВИЙ               │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   1. Клиент     │ DocumentProcessor processor;                   │
│      создает     │                                               │
│      адаптер    │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   2. Клиент     │ processor.processDocument(doc);                │
│      вызывает    │                                               │
│      метод      │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   3. Адаптер    │ adapter.print(doc);                           │
│      получает    │                                               │
│      вызов      │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   4. Адаптер    │ docString = doc.toString();                   │
│      преобразует│ legacyPrinter.printDocument(docString);       │
│      данные     │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   5. Adaptee    │ legacyPrinter.printDocument(docString);        │
│      выполняет   │                                               │
│      работу     │                                               │
└─────────────────┴───────────────────────────────────────────────┘

Диаграмма взаимодействий:
┌─────────────────────────────────────────────────────────────────┐
│  Client ──┐                                                    │
│           │                                                    │
│           ▼                                                    │
│  Adapter ──┐                                                   │
│             │                                                   │
│             ▼                                                   │
│  Adaptee ──┐                                                    │
│             │                                                    │
│             ▼                                                    │
│  LegacyPrinter.printDocument()                                  │
└─────────────────────────────────────────────────────────────────┘
```

## 🎨 Варианты реализации

### 1. Object Adapter (Объектный адаптер)
```
┌─────────────────────────────────────────────────────────────────┐
│                    OBJECT ADAPTER                              │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ class LegacyPrinterAdapter : public Printer {                   │
│ private:                                                        │
│     LegacyPrinter legacyPrinter_;                               │
│                                                                 │
│ public:                                                         │
│     LegacyPrinterAdapter() : legacyPrinter_() {}               │
│                                                                 │
│     void print(const Document& doc) override {                 │
│         // Преобразование данных                               │
│         std::string docString = doc.toString();                 │
│         legacyPrinter_.printDocument(docString);                │
│     }                                                           │
│                                                                 │
│     // Дополнительные методы для адаптации                     │
│     void setLegacyOptions(const std::string& options) {        │
│         legacyPrinter_.setOptions(options);                     │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘

Преимущества:
✅ Композиция вместо наследования
✅ Более гибкая адаптация
✅ Можно адаптировать несколько объектов
✅ Легче тестировать

Недостатки:
❌ Дополнительный уровень косвенности
❌ Больше кода для простых случаев
```

### 2. Class Adapter (Классовый адаптер)
```
┌─────────────────────────────────────────────────────────────────┐
│                    CLASS ADAPTER                               │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ class LegacyPrinterAdapter : public Printer,                   │
│                                private LegacyPrinter {          │
│ public:                                                         │
│     void print(const Document& doc) override {                 │
│         // Преобразование данных                               │
│         std::string docString = doc.toString();                 │
│         printDocument(docString);  // Наследованный метод      │
│     }                                                           │
│                                                                 │
│     // Прямой доступ к методам LegacyPrinter                  │
│     void setLegacyOptions(const std::string& options) {        │
│         setOptions(options);                                    │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘

Преимущества:
✅ Меньше кода
✅ Прямой доступ к методам
✅ Нет дополнительного уровня косвенности

Недостатки:
❌ Множественное наследование
❌ Менее гибкая адаптация
❌ Сложнее тестировать
❌ Нарушение принципа единственного наследования
```

### 3. Two-way Adapter (Двунаправленный адаптер)
```
┌─────────────────────────────────────────────────────────────────┐
│                    TWO-WAY ADAPTER                             │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ class TwoWayPrinterAdapter : public Printer,                   │
│                                public LegacyPrinter {          │
│ public:                                                         │
│     // Адаптация к новому интерфейсу                            │
│     void print(const Document& doc) override {                 │
│         std::string docString = doc.toString();                 │
│         printDocument(docString);                              │
│     }                                                           │
│                                                                 │
│     // Адаптация к старому интерфейсу                          │
│     void printDocument(const std::string& doc) override {      │
│         Document document = Document::fromString(doc);          │
│         print(document);                                       │
│     }                                                           │
│                                                                 │
│     // Дополнительные методы для совместимости                │
│     void setOptions(const std::string& options) override {     │
│         // Адаптация опций                                     │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘

Преимущества:
✅ Работает в обе стороны
✅ Полная совместимость
✅ Плавная миграция

Недостатки:
❌ Сложная реализация
❌ Больше кода
❌ Потенциальные конфликты методов
```

## 🔄 Сравнение подходов

```
┌─────────────────────────────────────────────────────────────────┐
│                    СРАВНЕНИЕ ПОДХОДОВ                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│   Object        │   Class          │   Two-way       │   Template      │
│   Adapter       │   Adapter        │   Adapter       │   Adapter       │
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│ Простота        │ Средняя          │ Низкая          │ Высокая         │
│ Гибкость        │ Высокая          │ Средняя         │ Высокая         │
│ Производительность│ Средняя         │ Высокая         │ Высокая         │
│ Тестируемость   │ Высокая          │ Средняя         │ Низкая          │
│ Наследование    │ Композиция       │ Множественное   │ Шаблоны         │
│ Применимость    │ Стандартные      │ Простые случаи  │ Сложные случаи  │
│                 │ случаи           │                 │                 │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

## 🎯 Когда использовать Adapter

```
┌─────────────────────────────────────────────────────────────────┐
│                КОГДА ИСПОЛЬЗОВАТЬ ADAPTER                     │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Legacy Code     │ • Интеграция старого кода с новыми системами  │
│                 │ • Миграция с устаревших технологий             │
├─────────────────┼───────────────────────────────────────────────┤
│ Third-party     │ • Использование внешних библиотек             │
│ Libraries       │ • Интеграция с API сторонних сервисов         │
├─────────────────┼───────────────────────────────────────────────┤
│ Interface       │ • Несовместимые интерфейсы                    │
│ Incompatibility │ • Разные форматы данных                       │
├─────────────────┼───────────────────────────────────────────────┤
│ Reusability     │ • Переиспользование существующего кода       │
│                 │ • Адаптация готовых решений                    │
├─────────────────┼───────────────────────────────────────────────┤
│ Testing         │ • Создание моков для тестирования            │
│                 │ • Изоляция зависимостей                       │
└─────────────────┴───────────────────────────────────────────────┘

❌ ПЛОХИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Простые случаи  │ • Когда можно легко изменить интерфейс       │
├─────────────────┼───────────────────────────────────────────────┤
│ Производительность│ • Критична производительность               │
├─────────────────┼───────────────────────────────────────────────┤
│ Сложность       │ • Добавляется ненужная сложность             │
├─────────────────┼───────────────────────────────────────────────┤
│ Альтернативы    │ • Есть лучшие альтернативы (Facade, Bridge)  │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🧪 Тестирование Adapter

```
┌─────────────────────────────────────────────────────────────────┐
│                    ТЕСТИРОВАНИЕ ADAPTER                       │
└─────────────────────────────────────────────────────────────────┘

Преимущества для тестирования:
┌─────────────────┬───────────────────────────────────────────────┐
│ Моки            │ ✅ Легко создавать моки для адаптеров        │
│                 │ class MockLegacyPrinter : public LegacyPrinter {│
│                 │     MOCK_METHOD(void, printDocument, (const std::string&)); │
│                 │ };                                            │
├─────────────────┼───────────────────────────────────────────────┤
│ Изоляция        │ ✅ Легко изолировать тесты                   │
│                 │ auto mockLegacyPrinter = std::make_unique<MockLegacyPrinter>(); │
│                 │ LegacyPrinterAdapter adapter(std::move(mockLegacyPrinter)); │
├─────────────────┼───────────────────────────────────────────────┤
│ Управление      │ ✅ Полный контроль над адаптируемыми объектами│
│ зависимостями   │ EXPECT_CALL(*mockLegacyPrinter, printDocument("test")) │
│                 │     .Times(1);                               │
└─────────────────┴───────────────────────────────────────────────┘

Пример теста:
┌─────────────────────────────────────────────────────────────────┐
│ TEST(LegacyPrinterAdapterTest, PrintDocument) {                 │
│     auto mockLegacyPrinter = std::make_unique<MockLegacyPrinter>(); │
│     LegacyPrinterAdapter adapter(std::move(mockLegacyPrinter)); │
│                                                                 │
│     Document doc("test content");                               │
│                                                                 │
│     EXPECT_CALL(*mockLegacyPrinter, printDocument("test content")) │
│         .Times(1);                                              │
│                                                                 │
│     adapter.print(doc);                                        │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

## 🔗 Связь с другими паттернами

```
┌─────────────────────────────────────────────────────────────────┐
│              СВЯЗЬ С ДРУГИМИ ПАТТЕРНАМИ                        │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│ Facade          │ • Adapter адаптирует один интерфейс          │
│                 │ • Facade упрощает сложный интерфейс          │
│                 │ • Adapter - совместимость                   │
│                 │ • Facade - упрощение                         │
├─────────────────┼───────────────────────────────────────────────┤
│ Bridge          │ • Adapter адаптирует существующий интерфейс  │
│                 │ • Bridge разделяет абстракцию и реализацию  │
│                 │ • Adapter - совместимость                   │
│                 │ • Bridge - разделение                       │
├─────────────────┼───────────────────────────────────────────────┤
│ Decorator       │ • Adapter изменяет интерфейс                 │
│                 │ • Decorator добавляет функциональность      │
│                 │ • Adapter - совместимость                   │
│                 │ • Decorator - расширение                    │
├─────────────────┼───────────────────────────────────────────────┤
│ Proxy           │ • Adapter адаптирует интерфейс               │
│                 │ • Proxy контролирует доступ к объекту       │
│                 │ • Adapter - совместимость                   │
│                 │ • Proxy - контроль доступа                 │
├─────────────────┼───────────────────────────────────────────────┤
│ Strategy        │ • Adapter может использовать Strategy       │
│                 │ • Strategy для выбора алгоритма адаптации    │
│                 │ • Adapter - совместимость                   │
│                 │ • Strategy - выбор алгоритма                │
└─────────────────┴───────────────────────────────────────────────┘
```

## 💡 Практические рекомендации

```
┌─────────────────────────────────────────────────────────────────┐
│                  ПРАКТИЧЕСКИЕ РЕКОМЕНДАЦИИ                     │
└─────────────────────────────────────────────────────────────────┘

1. 🎯 Выбор реализации:
   • Object Adapter - для большинства случаев
   • Class Adapter - для простых случаев
   • Two-way Adapter - для двунаправленной совместимости
   • Template Adapter - для типизированных случаев

2. 🔧 Принципы проектирования:
   • Соблюдайте Single Responsibility Principle
   • Используйте композицию вместо наследования
   • Инкапсулируйте логику преобразования
   • Обеспечьте совместимость интерфейсов

3. 🧪 Тестирование:
   • Создавайте интерфейсы для адаптеров
   • Используйте моки в тестах
   • Тестируйте преобразование данных
   • Проверяйте совместимость интерфейсов

4. ⚡ Производительность:
   • Рассмотрите кэширование преобразований
   • Используйте move semantics
   • Избегайте ненужных копирований
   • Профилируйте критические участки

5. 📚 Документация:
   • Документируйте преобразования данных
   • Описывайте совместимость интерфейсов
   • Приводите примеры использования
   • Объясняйте причины выбора паттерна

6. 🔄 Рефакторинг:
   • Начинайте с простых адаптеров
   • Постепенно добавляйте сложность
   • Используйте интерфейсы для абстракции
   • Планируйте миграцию на новые интерфейсы
```

## 🎓 Ключевые выводы

```
┌─────────────────────────────────────────────────────────────────┐
│                      КЛЮЧЕВЫЕ ВЫВОДЫ                          │
└─────────────────────────────────────────────────────────────────┘

✅ Adapter - мощный инструмент:
   • Обеспечивает совместимость несовместимых интерфейсов
   • Позволяет переиспользовать существующий код
   • Инкапсулирует логику преобразования
   • Следует принципам SOLID

✅ Выбирайте подходящую реализацию:
   • Object Adapter - для большинства случаев
   • Class Adapter - для простых случаев
   • Two-way Adapter - для двунаправленной совместимости
   • Template Adapter - для типизированных случаев

✅ Используйте правильно:
   • Когда нужно интегрировать несовместимые интерфейсы
   • Когда важно переиспользовать существующий код
   • Когда нужна совместимость с legacy системами
   • Когда важна тестируемость

✅ Избегайте злоупотребления:
   • Не используйте для простых случаев
   • Не добавляйте сложность без необходимости
   • Не забывайте об обработке ошибок
   • Не нарушайте принципы SOLID

✅ Помните о компромиссах:
   • Совместимость vs производительность
   • Простота vs функциональность
   • Переиспользование vs сложность
   • Тестируемость vs производительность
```

---
*Adapter - это мост между несовместимыми интерфейсами. 
Используйте его для интеграции legacy кода и внешних библиотек!*