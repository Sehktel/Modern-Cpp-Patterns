# 📊 Плакат: State Pattern (Состояние)

## 🎯 Назначение State Pattern

```
┌─────────────────────────────────────────────────────────────────┐
│                    STATE PATTERN                                │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  🔄 ИЗМЕНЯЕТ ПОВЕДЕНИЕ ОБЪЕКТА В ЗАВИСИМОСТИ ОТ СОСТОЯНИЯ     │
│  🎯 ИНКАПСУЛИРУЕТ СОСТОЯНИЯ И ПЕРЕХОДЫ МЕЖДУ НИМИ             │
│  🚀 ДИНАМИЧЕСКОЕ ИЗМЕНЕНИЕ ПОВЕДЕНИЯ                          │
│  🛡️ СОБЛЮДЕНИЕ OPEN/CLOSED PRINCIPLE                          │
└─────────────────────────────────────────────────────────────────┘

Применение:
┌─────────────────┬───────────────────────────────────────────────┐
│   Game Engines  │ • Состояния персонажей и объектов           │
├─────────────────┼───────────────────────────────────────────────┤
│   UI Systems    │ • Состояния кнопок и элементов                │
├─────────────────┼───────────────────────────────────────────────┤
│   Workflow      │ • Состояния процессов и задач                │
├─────────────────┼───────────────────────────────────────────────┤
│   Network       │ • Состояния соединений                       │
├─────────────────┼───────────────────────────────────────────────┤
│   Media Players │ • Состояния воспроизведения                   │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🔄 Проблема без State

```
┌─────────────────────────────────────────────────────────────────┐
│                    ПРОБЛЕМА: ЖЕСТКИЕ УСЛОВИЯ                  │
└─────────────────────────────────────────────────────────────────┘

❌ ПЛОХОЙ ДИЗАЙН - Нарушение принципов:
┌─────────────────────────────────────────────────────────────────┐
│                    MediaPlayer (Нарушает OCP!)                 │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │              MediaPlayer                                   ││
│  │                                                             ││
│  │  enum class State {                                        ││
│  │      STOPPED, PLAYING, PAUSED, BUFFERING                   ││
│  │  };                                                         ││
│  │                                                             ││
│  │  State currentState = State::STOPPED;                      ││
│  │                                                             ││
│  │  void play() {                                             ││
│  │      switch(currentState) {                                ││
│  │          case State::STOPPED:                              ││
│  │              // Логика воспроизведения                     ││
│  │              currentState = State::PLAYING;                ││
│  │              break;                                        ││
│  │                                                             ││
│  │          case State::PAUSED:                               ││
│  │              // Логика возобновления                       ││
│  │              currentState = State::PLAYING;                ││
│  │              break;                                        ││
│  │                                                             ││
│  │          case State::PLAYING:                              ││
│  │              // Уже воспроизводится                        ││
│  │              break;                                        ││
│  │                                                             ││
│  │          case State::BUFFERING:                            ││
│  │              // Ожидание буферизации                        ││
│  │              break;                                        ││
│  │                                                             ││
│  │          // ❌ НОВОЕ СОСТОЯНИЕ ТРЕБУЕТ МОДИФИКАЦИИ!       ││
│  │      }                                                      ││
│  │  }                                                          ││
│  │                                                             ││
│  │  void pause() {                                            ││
│  │      switch(currentState) {                                ││
│  │          case State::PLAYING:                              ││
│  │              // Логика паузы                               ││
│  │              currentState = State::PAUSED;                 ││
│  │              break;                                        ││
│  │                                                             ││
│  │          case State::STOPPED:                              ││
│  │              // Нельзя поставить на паузу                 ││
│  │              break;                                        ││
│  │                                                             ││
│  │          // ❌ ДУБЛИРОВАНИЕ ЛОГИКИ!                       ││
│  │      }                                                      ││
│  │  }                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  Проблемы:                                                     │
│  ❌ Нарушение Open/Closed Principle                            │
│  ❌ Дублирование логики                                        │
│  ❌ Сложность добавления новых состояний                       │
│  ❌ Сложность тестирования                                     │
└─────────────────────────────────────────────────────────────────┘
```

## ✅ Решение с State

```
┌─────────────────────────────────────────────────────────────────┐
│                    РЕШЕНИЕ: STATE PATTERN                     │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    ХОРОШИЙ ДИЗАЙН                             │
│                                                                 │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐        │
│  │  Stopped    │    │  Playing    │    │  Paused     │        │
│  │   State     │    │   State     │    │   State     │        │
│  │             │    │             │    │             │        │
│  │ • play()    │    │ • play()    │    │ • play()    │        │
│  │ • pause()   │    │ • pause()   │    │ • pause()   │        │
│  │ • stop()    │    │ • stop()    │    │ • stop()    │        │
│  └─────────────┘    └─────────────┘    └─────────────┘        │
│         ▲                 ▲                 ▲                  │
│         │                 │                 │                  │
│  ┌──────┴─────────────────┴─────────────────┴──────────┐      │
│  │              MediaPlayerState                         │      │
│  │                                                     │      │
│  │  virtual void play() = 0;                            │      │
│  │  virtual void pause() = 0;                           │      │
│  │  virtual void stop() = 0;                            │      │
│  │  virtual void next() = 0;                            │      │
│  │  virtual void previous() = 0;                        │      │
│  └─────────────────────────────────────────────────────┘      │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │              MediaPlayer                                  ││
│  │                                                             ││
│  │  std::unique_ptr<MediaPlayerState> state;                 ││
│  │                                                             ││
│  │  void setState(std::unique_ptr<MediaPlayerState> newState) {││
│  │      state = std::move(newState);                          ││
│  │  }                                                          ││
│  │                                                             ││
│  │  void play() {                                             ││
│  │      state->play();                                        ││
│  │  }                                                          ││
│  │                                                             ││
│  │  void pause() {                                            ││
│  │      state->pause();                                       ││
│  │  }                                                          ││
│  │                                                             ││
│  │  void stop() {                                             ││
│  │      state->stop();                                        ││
│  │  }                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  Преимущества:                                                  │
│  ✅ Соблюдение Open/Closed Principle                           │
│  ✅ Инкапсуляция состояний                                     │
│  ✅ Легкость добавления новых состояний                       │
│  ✅ Легкость тестирования                                      │
└─────────────────────────────────────────────────────────────────┘
```

## 🏗️ Структура State Pattern

```
┌─────────────────────────────────────────────────────────────────┐
│                    СТРУКТУРА ПАТТЕРНА                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    State (Состояние)                           │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │                    State                                 ││
│  │                                                             ││
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        ││
│  │  │ Concrete    │  │ Concrete    │  │ Concrete    │        ││
│  │  │ StateA      │  │ StateB      │  │ StateC      │        ││
│  │  │             │  │             │  │             │        ││
│  │  │ • handle1() │  │ • handle1() │  │ • handle1() │        ││
│  │  │ • handle2() │  │ • handle2() │  │ • handle2() │        ││
│  │  │ • handle3() │  │ • handle3() │  │ • handle3() │        ││
│  │  └─────────────┘  └─────────────┘  └─────────────┘        ││
│  │         ▲                 ▲                 ▲              ││
│  │         │                 │                 │              ││
│  │  ┌──────┴─────────────────┴─────────────────┴──────────┐  ││
│  │  │              State                               │  ││
│  │  │                                                     │  ││
│  │  │  virtual void handle1() = 0;                       │  ││
│  │  │  virtual void handle2() = 0;                       │  ││
│  │  │  virtual void handle3() = 0;                       │  ││
│  │  └─────────────────────────────────────────────────────┘  ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Context (Контекст)                          │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │                    Context                                ││
│  │                                                             ││
│  │  ┌─────────────┐                                           ││
│  │  │ State       │                                           ││
│  │  │             │                                           ││
│  │  │ • handle1() │                                           ││
│  │  │ • handle2() │                                           ││
│  │  │ • handle3() │                                           ││
│  │  └─────────────┘                                           ││
│  │         ▲                                                   ││
│  │         │                                                   ││
│  │  ┌──────┴──────────────────────────────────────────────┐  ││
│  │  │              Context                               │  ││
│  │  │                                                     │  ││
│  │  │  std::unique_ptr<State> state;                     │  ││
│  │  │                                                     │  ││
│  │  │  void setState(std::unique_ptr<State> newState) {  │  ││
│  │  │      state = std::move(newState);                  │  ││
│  │  │  }                                                  │  ││
│  │  │                                                     │  ││
│  │  │  void request1() {                                 │  ││
│  │  │      state->handle1();                             │  ││
│  │  │  }                                                  │  ││
│  │  │                                                     │  ││
│  │  │  void request2() {                                 │  ││
│  │  │      state->handle2();                             │  ││
│  │  │  }                                                  │  ││
│  │  └─────────────────────────────────────────────────────┘  ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 Последовательность взаимодействий

```
┌─────────────────────────────────────────────────────────────────┐
│              ПОСЛЕДОВАТЕЛЬНОСТЬ ВЗАИМОДЕЙСТВИЙ                │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    1. ИЗМЕНЕНИЕ СОСТОЯНИЯ                      │
│                                                                 │
│  ┌─────────────┐              ┌─────────────┐                 │
│  │   Context   │              │   State     │                 │
│  │             │              │             │                 │
│  │ • setState │              │ • handle1() │                 │
│  │ • request1 │              │ • handle2() │                 │
│  │ • request2 │              │ • handle3() │                 │
│  └─────────────┘              └─────────────┘                 │
│         │                              ▲                      │
│         │                              │                      │
│         │      setState(newState)      │                      │
│         └──────────────────────────────┘                      │
│                                                                 │
│                    2. ВЫПОЛНЕНИЕ ЗАПРОСА                       │
│                                                                 │
│  ┌─────────────┐              ┌─────────────┐                 │
│  │   Context   │              │   State     │                 │
│  │             │              │             │                 │
│  │ • request1 │              │ • handle1() │                 │
│  │ • request2 │              │ • handle2() │                 │
│  │             │              │ • handle3() │                 │
│  └─────────────┘              └─────────────┘                 │
│         │                              ▲                      │
│         │                              │                      │
│         │      request1()              │                      │
│         └──────────────────────────────┘                      │
│                                                                 │
│                    3. ОБРАБОТКА В СОСТОЯНИИ                    │
│                                                                 │
│  ┌─────────────┐              ┌─────────────┐                 │
│  │   Context   │              │   State     │                 │
│  │             │              │             │                 │
│  │ • setState │              │ • handle1() │                 │
│  │ • request1 │              │ • handle2() │                 │
│  │ • request2 │              │ • handle3() │                 │
│  └─────────────┘              └─────────────┘                 │
│         ▲                              │                      │
│         │                              │                      │
│         │      setState(nextState)     │                      │
│         └──────────────────────────────┘                      │
└─────────────────────────────────────────────────────────────────┘
```

## 🎨 Варианты реализации

### 1. Классическая реализация
```
┌─────────────────────────────────────────────────────────────────┐
│                  КЛАССИЧЕСКАЯ РЕАЛИЗАЦИЯ                      │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ // Абстрактное состояние                                        │
│ class MediaPlayerState {                                        │
│ public:                                                          │
│     virtual ~MediaPlayerState() = default;                       │
│     virtual void play(MediaPlayer& player) = 0;                 │
│     virtual void pause(MediaPlayer& player) = 0;                │
│     virtual void stop(MediaPlayer& player) = 0;                 │
│     virtual void next(MediaPlayer& player) = 0;                │
│     virtual void previous(MediaPlayer& player) = 0;             │
│ };                                                               │
│                                                                  │
│ // Конкретное состояние - остановлен                            │
│ class StoppedState : public MediaPlayerState {                   │
│ public:                                                          │
│     void play(MediaPlayer& player) override {                   │
│         std::cout << "Starting playback..." << std::endl;       │
│         player.setState(std::make_unique<PlayingState>());      │
│     }                                                            │
│                                                                  │
│     void pause(MediaPlayer& player) override {                  │
│         std::cout << "Cannot pause when stopped" << std::endl;  │
│     }                                                            │
│                                                                  │
│     void stop(MediaPlayer& player) override {                   │
│         std::cout << "Already stopped" << std::endl;            │
│     }                                                            │
│                                                                  │
│     void next(MediaPlayer& player) override {                   │
│         std::cout << "Cannot skip when stopped" << std::endl;   │
│     }                                                            │
│                                                                  │
│     void previous(MediaPlayer& player) override {               │
│         std::cout << "Cannot skip when stopped" << std::endl;   │
│     }                                                            │
│ };                                                               │
│                                                                  │
│ // Конкретное состояние - воспроизведение                       │
│ class PlayingState : public MediaPlayerState {                   │
│ public:                                                          │
│     void play(MediaPlayer& player) override {                   │
│         std::cout << "Already playing" << std::endl;            │
│     }                                                            │
│                                                                  │
│     void pause(MediaPlayer& player) override {                  │
│         std::cout << "Pausing playback..." << std::endl;        │
│         player.setState(std::make_unique<PausedState>());       │
│     }                                                            │
│                                                                  │
│     void stop(MediaPlayer& player) override {                   │
│         std::cout << "Stopping playback..." << std::endl;        │
│         player.setState(std::make_unique<StoppedState>());      │
│     }                                                            │
│                                                                  │
│     void next(MediaPlayer& player) override {                   │
│         std::cout << "Skipping to next track..." << std::endl;  │
│     }                                                            │
│                                                                  │
│     void previous(MediaPlayer& player) override {               │
│         std::cout << "Skipping to previous track..." << std::endl;│
│     }                                                            │
│ };                                                               │
│                                                                  │
│ // Конкретное состояние - пауза                                  │
│ class PausedState : public MediaPlayerState {                    │
│ public:                                                          │
│     void play(MediaPlayer& player) override {                   │
│         std::cout << "Resuming playback..." << std::endl;       │
│         player.setState(std::make_unique<PlayingState>());      │
│     }                                                            │
│                                                                  │
│     void pause(MediaPlayer& player) override {                  │
│         std::cout << "Already paused" << std::endl;             │
│     }                                                            │
│                                                                  │
│     void stop(MediaPlayer& player) override {                   │
│         std::cout << "Stopping playback..." << std::endl;       │
│         player.setState(std::make_unique<StoppedState>());      │
│     }                                                            │
│                                                                  │
│     void next(MediaPlayer& player) override {                   │
│         std::cout << "Skipping to next track..." << std::endl;  │
│     }                                                            │
│                                                                  │
│     void previous(MediaPlayer& player) override {               │
│         std::cout << "Skipping to previous track..." << std::endl;│
│     }                                                            │
│ };                                                               │
│                                                                  │
│ // Контекст                                                      │
│ class MediaPlayer {                                              │
│ private:                                                         │
│     std::unique_ptr<MediaPlayerState> state;                     │
│                                                                  │
│ public:                                                          │
│     MediaPlayer() : state(std::make_unique<StoppedState>()) {}   │
│                                                                  │
│     void setState(std::unique_ptr<MediaPlayerState> newState) {  │
│         state = std::move(newState);                             │
│     }                                                            │
│                                                                  │
│     void play() {                                                │
│         state->play(*this);                                      │
│     }                                                            │
│                                                                  │
│     void pause() {                                               │
│         state->pause(*this);                                     │
│     }                                                            │
│                                                                  │
│     void stop() {                                                │
│         state->stop(*this);                                      │
│     }                                                            │
│                                                                  │
│     void next() {                                                │
│         state->next(*this);                                      │
│     }                                                            │
│                                                                  │
│     void previous() {                                            │
│         state->previous(*this);                                  │
│     }                                                            │
│ };                                                               │
└─────────────────────────────────────────────────────────────────┘
```

### 2. Реализация с переходами
```
┌─────────────────────────────────────────────────────────────────┐
│              РЕАЛИЗАЦИЯ С ПЕРЕХОДАМИ                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ class StateMachine {                                            │
│ private:                                                        │
│     std::unique_ptr<State> currentState;                       │
│     std::map<std::pair<State*, std::string>, State*> transitions;│
│                                                                 │
│ public:                                                         │
│     void addTransition(State* from, const std::string& event,   │
│                        State* to) {                            │
│         transitions[{from, event}] = to;                      │
│     }                                                           │
│                                                                 │
│     void handleEvent(const std::string& event) {               │
│         auto it = transitions.find({currentState.get(), event});│
│         if (it != transitions.end()) {                         │
│             currentState = std::unique_ptr<State>(it->second);  │
│         } else {                                                │
│             throw std::runtime_error("Invalid transition");     │
│         }                                                       │
│     }                                                           │
│                                                                 │
│     State* getCurrentState() const {                            │
│         return currentState.get();                              │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ // Использование                                                │
│ StateMachine sm;                                                │
│ auto stopped = std::make_unique<StoppedState>();               │
│ auto playing = std::make_unique<PlayingState>();               │
│ auto paused = std::make_unique<PausedState>();                 │
│                                                                 │
│ sm.addTransition(stopped.get(), "play", playing.get());        │
│ sm.addTransition(playing.get(), "pause", paused.get());        │
│ sm.addTransition(playing.get(), "stop", stopped.get());        │
│ sm.addTransition(paused.get(), "play", playing.get());          │
│ sm.addTransition(paused.get(), "stop", stopped.get());         │
└─────────────────────────────────────────────────────────────────┘
```

### 3. Реализация с лямбдами
```
┌─────────────────────────────────────────────────────────────────┐
│              РЕАЛИЗАЦИЯ С ЛЯМБДАМИ                            │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ class LambdaStateMachine {                                      │
│ private:                                                        │
│     std::string currentState;                                   │
│     std::map<std::pair<std::string, std::string>,              │
│              std::function<void()>> transitions;                │
│                                                                 │
│ public:                                                         │
│     void addTransition(const std::string& from,                │
│                        const std::string& event,                │
│                        const std::string& to,                   │
│                        std::function<void()> action) {          │
│         transitions[{from, event}] = [this, to, action] {      │
│             currentState = to;                                  │
│             action();                                           │
│         };                                                      │
│     }                                                           │
│                                                                 │
│     void handleEvent(const std::string& event) {               │
│         auto it = transitions.find({currentState, event});     │
│         if (it != transitions.end()) {                          │
│             it->second();                                      │
│         } else {                                                │
│             throw std::runtime_error("Invalid transition");     │
│         }                                                       │
│     }                                                           │
│                                                                 │
│     std::string getCurrentState() const {                      │
│         return currentState;                                    │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 Сравнение подходов

```
┌─────────────────────────────────────────────────────────────────┐
│                    СРАВНЕНИЕ ПОДХОДОВ                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│   Классический  │   Переходы       │    Лямбды       │   Enum + Switch │
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│ Простота        │ Средняя         │ Высокая         │ Низкая          │
│ Производительность│ Высокая        │ Высокая         │ Средняя         │
│ Безопасность    │ Высокая         │ Высокая         │ Высокая         │
│ Гибкость        │ Высокая         │ Очень высокая   │ Высокая         │
│ Тестируемость   │ Высокая         │ Высокая         │ Средняя         │
│ Применимость    │ Общие случаи    │ Сложные случаи  │ Простые случаи  │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

## 🎯 Когда использовать State

```
┌─────────────────────────────────────────────────────────────────┐
│                КОГДА ИСПОЛЬЗОВАТЬ STATE                       │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Game Engines    │ • Состояния персонажей и объектов            │
│                 │ • Игровые режимы                              │
│                 │ • Состояния AI                                │
├─────────────────┼───────────────────────────────────────────────┤
│ UI Systems      │ • Состояния кнопок и элементов               │
│                 │ • Состояния форм                              │
│                 │ • Состояния навигации                        │
├─────────────────┼───────────────────────────────────────────────┤
│ Workflow        │ • Состояния процессов и задач                │
│                 │ • Состояния заказов                           │
│                 │ • Состояния документов                       │
├─────────────────┼───────────────────────────────────────────────┤
│ Network         │ • Состояния соединений                        │
│                 │ • Состояния протоколов                        │
│                 │ • Состояния сессий                            │
├─────────────────┼───────────────────────────────────────────────┤
│ Media Players   │ • Состояния воспроизведения                  │
│                 │ • Состояния буферизации                      │
│                 │ • Состояния ошибок                            │
└─────────────────┴───────────────────────────────────────────────┘

❌ ПЛОХИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Простые случаи  │ • Когда поведение не меняется                 │
│                 │ • Когда нет необходимости в гибкости          │
├─────────────────┼───────────────────────────────────────────────┤
│ Производительность│ • Когда критична производительность          │
│                 │ • Когда накладные расходы недопустимы         │
├─────────────────┼───────────────────────────────────────────────┤
│ Сложность       │ • Когда усложнение не оправдано              │
│                 │ • Когда можно использовать простые решения    │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🧪 Тестирование State

```
┌─────────────────────────────────────────────────────────────────┐
│                    ТЕСТИРОВАНИЕ STATE                         │
└─────────────────────────────────────────────────────────────────┘

Тестирование состояний:
┌─────────────────────────────────────────────────────────────────┐
│ TEST(StateTest, StoppedState) {                               │
│     MediaPlayer player;                                        │
│     auto state = std::make_unique<StoppedState>();             │
│                                                                 │
│     // Тест воспроизведения из остановленного состояния        │
│     state->play(player);                                       │
│     EXPECT_EQ(typeid(PlayingState), typeid(*player.getState()));│
│                                                                 │
│     // Тест паузы из остановленного состояния                  │
│     state->pause(player);                                      │
│     EXPECT_EQ(typeid(StoppedState), typeid(*player.getState()));│
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘

Тестирование переходов:
┌─────────────────────────────────────────────────────────────────┐
│ TEST(StateTest, StateTransitions) {                           │
│     MediaPlayer player;                                        │
│                                                                 │
│     // Тест перехода из остановленного в воспроизведение        │
│     player.play();                                              │
│     EXPECT_EQ(typeid(PlayingState), typeid(*player.getState()));│
│                                                                 │
│     // Тест перехода из воспроизведения в паузу                 │
│     player.pause();                                             │
│     EXPECT_EQ(typeid(PausedState), typeid(*player.getState()));│
│                                                                 │
│     // Тест перехода из паузы в воспроизведение                 │
│     player.play();                                              │
│     EXPECT_EQ(typeid(PlayingState), typeid(*player.getState()));│
│                                                                 │
│     // Тест перехода из воспроизведения в остановленное         │
│     player.stop();                                              │
│     EXPECT_EQ(typeid(StoppedState), typeid(*player.getState()));│
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘

Тестирование машины состояний:
┌─────────────────────────────────────────────────────────────────┐
│ TEST(StateTest, StateMachine) {                                │
│     StateMachine sm;                                            │
│     auto stopped = std::make_unique<StoppedState>();           │
│     auto playing = std::make_unique<PlayingState>();           │
│                                                                 │
│     sm.addTransition(stopped.get(), "play", playing.get());    │
│                                                                 │
│     // Тест перехода                                            │
│     sm.handleEvent("play");                                     │
│     EXPECT_EQ(playing.get(), sm.getCurrentState());           │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

## 🔗 Связь с другими паттернами

```
┌─────────────────────────────────────────────────────────────────┐
│              СВЯЗЬ С ДРУГИМИ ПАТТЕРНАМИ                        │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│ Strategy        │ • State - изменение поведения                 │
│                 │ • Strategy - выбор алгоритма                  │
│                 │ • State - динамическое изменение              │
│                 │ • Strategy - статический выбор                │
├─────────────────┼───────────────────────────────────────────────┤
│ Command         │ • State может использовать Command           │
│                 │ • Инкапсуляция действий в состояниях        │
│                 │ • Отложенное выполнение                      │
├─────────────────┼───────────────────────────────────────────────┤
│ Observer        │ • State может быть Observer'ом              │
│                 │ • Уведомления о смене состояний              │
│                 │ • Отслеживание переходов                     │
├─────────────────┼───────────────────────────────────────────────┤
│ Memento         │ • State для сохранения состояния             │
│                 │ • Memento для восстановления состояния       │
│                 │ • State - текущее состояние                  │
│                 │ • Memento - сохраненное состояние            │
└─────────────────┴───────────────────────────────────────────────┘
```

## 💡 Практические рекомендации

```
┌─────────────────────────────────────────────────────────────────┐
│                  ПРАКТИЧЕСКИЕ РЕКОМЕНДАЦИИ                     │
└─────────────────────────────────────────────────────────────────┘

1. 🎯 Выбор реализации:
   • Классическая - для общих случаев
   • Переходы - для сложных случаев
   • Лямбды - для простых случаев
   • Enum + Switch - для производительности

2. 🔧 Принципы проектирования:
   • Слабая связанность между состояниями и контекстом
   • Абстракция через интерфейсы
   • Инкапсуляция поведения состояний
   • Разделение ответственности

3. 🧪 Тестирование:
   • Тестируйте каждое состояние отдельно
   • Тестируйте переходы между состояниями
   • Используйте моки для изоляции тестов
   • Тестируйте машину состояний

4. ⚠️ Типичные ошибки:
   • Создание слишком много состояний
   • Игнорирование производительности
   • Неправильное управление переходами
   • Отсутствие валидации состояний

5. 📚 Лучшие практики:
   • Используйте RAII для управления состояниями
   • Применяйте move semantics
   • Документируйте переходы состояний
   • Рассмотрите асинхронные переходы

6. 🚀 Оптимизация:
   • Кэшируйте часто используемые состояния
   • Используйте move semantics
   • Рассмотрите compile-time состояния
   • Профилируйте критические участки
```

## 🎓 Ключевые выводы

```
┌─────────────────────────────────────────────────────────────────┐
│                      КЛЮЧЕВЫЕ ВЫВОДЫ                          │
└─────────────────────────────────────────────────────────────────┘

✅ State - мощный паттерн для управления поведением:
   • Динамическое изменение поведения объекта
   • Инкапсуляция состояний и переходов
   • Соблюдение Open/Closed Principle
   • Упрощение сложной логики

✅ Выбирайте подходящую реализацию:
   • Классическая - общие случаи
   • Переходы - сложные случаи
   • Лямбды - простые случаи
   • Enum + Switch - производительность

✅ Используйте правильно:
   • Когда поведение зависит от состояния
   • Для упрощения сложной логики
   • Когда состояния часто меняются
   • Для соблюдения OCP

✅ Избегайте злоупотребления:
   • Не используйте для простых случаев
   • Не создавайте слишком много состояний
   • Не игнорируйте производительность
   • Не забывайте об управлении переходами

✅ Интеграция с паттернами:
   • Альтернатива Strategy
   • Комбинация с Command
   • Использование в Observer
   • Основа для Memento
```

---
*State Pattern - это ключ к гибкости и управляемости. Используйте его для создания адаптивных и предсказуемых систем!*
