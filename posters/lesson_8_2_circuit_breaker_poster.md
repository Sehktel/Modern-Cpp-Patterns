# 📊 Плакат: Circuit Breaker Pattern

## 🎯 Концепция Circuit Breaker

```
┌─────────────────────────────────────────────────────────────────┐
│                   CIRCUIT BREAKER PATTERN                      │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  🔌 ЗАЩИТА ОТ КАСКАДНЫХ ОТКАЗОВ                               │
│  ⚡ БЫСТРЫЙ ОТКАЗ ПРИ НЕДОСТУПНОСТИ СЕРВИСА                   │
│  🔄 АВТОМАТИЧЕСКОЕ ВОССТАНОВЛЕНИЕ                              │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   ПРОБЛЕМА      │  • Зависимый сервис падает                    │
│                 │  • Долгие таймауты блокируют потоки           │
│                 │  • Каскадные отказы по всей системе           │
│                 │  • Ресурсы тратятся на заведомо неудачные вызовы│
├─────────────────┼───────────────────────────────────────────────┤
│   РЕШЕНИЕ       │  • Мониторинг ошибок                          │
│                 │  • "Размыкание" при превышении порога         │
│                 │  • Быстрый отказ без вызова сервиса           │
│                 │  • Периодические попытки восстановления       │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🔄 Три состояния Circuit Breaker

```
┌─────────────────────────────────────────────────────────────────┐
│              СОСТОЯНИЯ CIRCUIT BREAKER                         │
└─────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────┐
│  1. CLOSED (Закрыт) - Нормальная работа                      │
│  ┌────────────────────────────────────────────────────┐      │
│  │  • Запросы проходят к сервису                      │      │
│  │  • Подсчет ошибок                                  │      │
│  │  • Если ошибки > threshold → переход в OPEN        │      │
│  └────────────────────────────────────────────────────┘      │
│         │                                                     │
│         │ Failures ≥ Threshold                                │
│         ↓                                                     │
│  ┌────────────────────────────────────────────────────┐      │
│  │  2. OPEN (Открыт) - Защитный режим                │      │
│  │  ┌──────────────────────────────────────────────┐ │      │
│  │  │  • Запросы НЕ идут к сервису                 │ │      │
│  │  │  • Немедленный возврат ошибки                │ │      │
│  │  │  • Таймер до попытки восстановления          │ │      │
│  │  │  • После timeout → переход в HALF_OPEN       │ │      │
│  │  └──────────────────────────────────────────────┘ │      │
│  └────────────────────────────────────────────────────┘      │
│         │                                                     │
│         │ Timeout expired                                     │
│         ↓                                                     │
│  ┌────────────────────────────────────────────────────┐      │
│  │  3. HALF_OPEN (Полуоткрыт) - Проверка              │      │
│  │  ┌──────────────────────────────────────────────┐ │      │
│  │  │  • Пробные запросы к сервису                 │ │      │
│  │  │  • Если успех → CLOSED                       │ │      │
│  │  │  • Если неудача → OPEN                       │ │      │
│  │  └──────────────────────────────────────────────┘ │      │
│  └────────────────────────────────────────────────────┘      │
│     │                                      │                  │
│     │ Success                              │ Failure          │
│     ↓                                      ↓                  │
│   CLOSED                                 OPEN                 │
└──────────────────────────────────────────────────────────────┘
```

## 📊 Диаграмма состояний

```
┌─────────────────────────────────────────────────────────────────┐
│                 STATE TRANSITION DIAGRAM                       │
└─────────────────────────────────────────────────────────────────┘

                    ┌─────────────┐
                    │   CLOSED    │
                    │  ✅ Normal  │
                    │  работа     │
                    └─────────────┘
                          │ │
          Success ────────┘ └──────── Failures ≥ Threshold
              ↓                              ↓
         [Continue]                   ┌─────────────┐
                                      │    OPEN     │
                                      │  ❌ Блокир. │
                                      │  запросы    │
                                      └─────────────┘
                                            │
                                    Timeout expired
                                            ↓
                                      ┌─────────────┐
                    ┌─────────────────│ HALF_OPEN   │──────────────┐
                    │                 │  🔄 Пробные │              │
                    │                 │  запросы    │              │
                    │                 └─────────────┘              │
            Successes ≥                                    Failure
            Threshold                                          ↓
                    ↓                                     [Back to OPEN]
              [Back to CLOSED]


┌─────────────────────────────────────────────────────────────────┐
│  МЕТРИКИ:                                                       │
│  • Failure rate: процент ошибок                                 │
│  • Failure threshold: порог для открытия (например, 5 ошибок)   │
│  • Timeout: время до попытки восстановления (например, 10s)     │
│  • Success threshold: успехов для закрытия (например, 2)        │
└─────────────────────────────────────────────────────────────────┘
```

## 💡 Сравнение подходов

```
┌─────────────────────────────────────────────────────────────────┐
│         БЕЗ CIRCUIT BREAKER vs С CIRCUIT BREAKER               │
└─────────────────────────────────────────────────────────────────┘

❌ БЕЗ CIRCUIT BREAKER:
┌─────────────────────────────────────────────────────────────────┐
│ while (true) {                                                  │
│     try {                                                       │
│         // Сервис упал, но мы продолжаем пытаться...          │
│         response = httpClient.get("http://api.example.com");   │
│         // ^^^^^ БЛОКИРУЕТСЯ на 30 секунд (timeout)!          │
│                                                                 │
│         processResponse(response);                              │
│     } catch (TimeoutException e) {                             │
│         // Ждали 30 секунд, получили timeout                   │
│         log.error("Request failed");                            │
│         // И снова пытаемся... ещё 30 секунд...               │
│     }                                                           │
│ }                                                               │
│                                                                 │
│ ⚠️ ПРОБЛЕМЫ:                                                   │
│  • Потоки блокируются на долгие таймауты                       │
│  • Ресурсы тратятся на заведомо неудачные запросы              │
│  • Пользователи ждут по 30 секунд на каждый запрос            │
│  • Каскадный отказ: один сервис тормозит всю систему          │
│  • Thread pool exhaustion: все потоки заняты ожиданием        │
└─────────────────────────────────────────────────────────────────┘

✅ С CIRCUIT BREAKER:
┌─────────────────────────────────────────────────────────────────┐
│ CircuitBreaker cb("APIService", config);                        │
│                                                                 │
│ while (true) {                                                  │
│     try {                                                       │
│         // Circuit Breaker проверяет состояние                  │
│         response = cb.execute([&]() {                           │
│             return httpClient.get("http://api.example.com");    │
│         });                                                     │
│                                                                 │
│         processResponse(response);                              │
│                                                                 │
│     } catch (CircuitBreakerOpenException e) {                  │
│         // Немедленный отказ! Не ждем 30 секунд               │
│         log.warn("Circuit breaker OPEN");                       │
│         return fallbackResponse();  // Быстрый fallback        │
│     }                                                           │
│ }                                                               │
│                                                                 │
│ ✅ ПРЕИМУЩЕСТВА:                                               │
│  • Быстрый отказ (fail-fast) без блокировки                    │
│  • Защита ресурсов (потоки не блокируются)                     │
│  • Пользователи получают ответ мгновенно                       │
│  • Предотвращение каскадных отказов                            │
│  • Время на восстановление упавшего сервиса                    │
│  • Автоматическое восстановление при успехе                    │
└─────────────────────────────────────────────────────────────────┘
```

## 🔧 Реализация с метриками

```
┌─────────────────────────────────────────────────────────────────┐
│              CIRCUIT BREAKER IMPLEMENTATION                    │
└─────────────────────────────────────────────────────────────────┘

class CircuitBreaker {
private:
    std::atomic<CircuitState> state_{CircuitState::CLOSED};
    std::atomic<size_t> failure_count_{0};
    std::atomic<size_t> success_count_{0};
    std::chrono::system_clock::time_point last_failure_time_;
    
    CircuitBreakerConfig config_;
    
    // Статистика
    std::atomic<size_t> total_requests_{0};
    std::atomic<size_t> successful_requests_{0};
    std::atomic<size_t> failed_requests_{0};
    std::atomic<size_t> rejected_requests_{0};
    
public:
    template<typename F>
    auto execute(F&& func) -> decltype(func()) {
        total_requests_.fetch_add(1);
        
        // 1. Проверяем состояние
        if (state_ == CircuitState::OPEN) {
            if (shouldAttemptReset()) {
                state_ = CircuitState::HALF_OPEN;
            } else {
                rejected_requests_.fetch_add(1);
                throw CircuitBreakerOpenException();
            }
        }
        
        // 2. Выполняем операцию
        try {
            auto result = func();
            onSuccess();
            return result;
        } catch (...) {
            onFailure();
            throw;
        }
    }
    
private:
    void onSuccess() {
        successful_requests_.fetch_add(1);
        
        if (state_ == CircuitState::HALF_OPEN) {
            if (++success_count_ >= config_.success_threshold) {
                state_ = CircuitState::CLOSED;
                failure_count_ = 0;
            }
        } else {
            failure_count_ = 0;
        }
    }
    
    void onFailure() {
        failed_requests_.fetch_add(1);
        last_failure_time_ = std::chrono::system_clock::now();
        
        if (state_ == CircuitState::HALF_OPEN) {
            state_ = CircuitState::OPEN;
        } else if (state_ == CircuitState::CLOSED) {
            if (++failure_count_ >= config_.failure_threshold) {
                state_ = CircuitState::OPEN;
            }
        }
    }
    
    bool shouldAttemptReset() {
        auto now = std::chrono::system_clock::now();
        auto elapsed = now - last_failure_time_;
        return elapsed >= config_.timeout;
    }
};
```

## 🔄 Интеграция с Retry Logic

```
┌─────────────────────────────────────────────────────────────────┐
│           CIRCUIT BREAKER + RETRY PATTERN                      │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  RETRY with EXPONENTIAL BACKOFF                                 │
│  ┌──────────────────────────────────────────────────────┐      │
│  │  Attempt 1: delay = 100ms                            │      │
│  │  Attempt 2: delay = 200ms (×2)                       │      │
│  │  Attempt 3: delay = 400ms (×2)                       │      │
│  │  ...                                                  │      │
│  └──────────────────────────────────────────────────────┘      │
│                          ↓                                      │
│  ┌──────────────────────────────────────────────────────┐      │
│  │  CIRCUIT BREAKER                                      │      │
│  │  • Если retry исчерпаны → увеличивает failure_count  │      │
│  │  • При threshold → переход в OPEN                     │      │
│  │  • В OPEN состоянии retry не выполняется             │      │
│  └──────────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────────┘

template<typename F>
auto retryWithCircuitBreaker(F&& func, RetryPolicy policy) {
    return circuit_breaker.execute([&]() {
        size_t attempts = 0;
        auto delay = policy.initial_delay;
        
        while (attempts < policy.max_attempts) {
            try {
                return func();
            } catch (...) {
                if (++attempts >= policy.max_attempts) {
                    throw;
                }
                std::this_thread::sleep_for(delay);
                delay *= policy.backoff_multiplier;
            }
        }
    });
}
```

## 🛡️ Fallback механизмы

```
┌─────────────────────────────────────────────────────────────────┐
│                    FALLBACK STRATEGIES                         │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  1. CACHE FALLBACK                                              │
│     ┌───────────────────────────────────────────────┐          │
│     │  try {                                         │          │
│     │      data = cb.execute(() -> api.getData());   │          │
│     │  } catch (CircuitBreakerOpenException e) {    │          │
│     │      return cache.get(key);  // Из кэша       │          │
│     │  }                                             │          │
│     └───────────────────────────────────────────────┘          │
├─────────────────────────────────────────────────────────────────┤
│  2. DEFAULT VALUE                                               │
│     ┌───────────────────────────────────────────────┐          │
│     │  try {                                         │          │
│     │      config = cb.execute(() -> api.getConfig());│         │
│     │  } catch (CircuitBreakerOpenException e) {    │          │
│     │      return DEFAULT_CONFIG;  // Дефолт        │          │
│     │  }                                             │          │
│     └───────────────────────────────────────────────┘          │
├─────────────────────────────────────────────────────────────────┤
│  3. DEGRADED SERVICE                                            │
│     ┌───────────────────────────────────────────────┐          │
│     │  try {                                         │          │
│     │      result = cb.execute(() -> api.search()); │          │
│     │  } catch (CircuitBreakerOpenException e) {    │          │
│     │      return simpleSearch();  // Упрощенный    │          │
│     │  }                                             │          │
│     └───────────────────────────────────────────────┘          │
├─────────────────────────────────────────────────────────────────┤
│  4. SECONDARY SERVICE                                           │
│     ┌───────────────────────────────────────────────┐          │
│     │  try {                                         │          │
│     │      data = cb_primary.execute(...);          │          │
│     │  } catch (CircuitBreakerOpenException e) {    │          │
│     │      return cb_secondary.execute(...);        │          │
│     │  }                                             │          │
│     └───────────────────────────────────────────────┘          │
└─────────────────────────────────────────────────────────────────┘
```

## ⚠️ Проблемы и решения

```
┌─────────────────────────────────────────────────────────────────┐
│                  ТИПИЧНЫЕ ПРОБЛЕМЫ И РЕШЕНИЯ                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   FLAPPING      │  РЕШЕНИЕ:                                     │
│   (Дрожание)    │  • Увеличить success_threshold                │
│                 │  • Exponential backoff для timeout            │
│   CLOSED ⟷ OPEN│  • Sliding window для подсчета ошибок         │
│   постоянно     │  • Hysteresis (разные пороги для open/close)  │
│   переключается │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   THUNDERING    │  РЕШЕНИЕ:                                     │
│   HERD          │  • Jitter в timeout (случайная задержка)      │
│                 │  • Rate limiting для HALF_OPEN запросов       │
│   Все запросы   │  • Постепенное увеличение нагрузки            │
│   одновременно  │  • Token bucket для контроля потока           │
│   после OPEN    │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   FALSE         │  РЕШЕНИЕ:                                     │
│   POSITIVES     │  • Правильная классификация ошибок            │
│                 │  • Игнорировать 4xx (client errors)           │
│   Открывается   │  • Считать только 5xx и timeouts              │
│   из-за client  │  • Whitelist/blacklist ошибок                 │
│   ошибок        │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   SHARED STATE  │  РЕШЕНИЕ:                                     │
│   ISSUES        │  • Один CB на инстанс сервиса                 │
│                 │  • Distributed CB (Redis, Consul)             │
│   Разные CB на  │  • Shared metrics aggregation                 │
│   разных серверах│ • Leader election для state management       │
└─────────────────┴───────────────────────────────────────────────┘
```

## 📊 Метрики и мониторинг

```
┌─────────────────────────────────────────────────────────────────┐
│                   КЛЮЧЕВЫЕ МЕТРИКИ                             │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  📈 ОПЕРАЦИОННЫЕ МЕТРИКИ                                        │
│  • State: текущее состояние (CLOSED/OPEN/HALF_OPEN)            │
│  • Failure rate: процент ошибок                                 │
│  • Success rate: процент успехов                                │
│  • Rejection rate: процент отклоненных запросов                 │
│  • State transitions: частота переключений состояний            │
├─────────────────────────────────────────────────────────────────┤
│  ⏱️ ПРОИЗВОДИТЕЛЬНОСТЬ                                          │
│  • Response time: время ответа (в CLOSED)                       │
│  • Timeout occurrences: количество таймаутов                    │
│  • Latency p50/p95/p99: процентили задержек                    │
│  • Throughput: запросов в секунду                               │
├─────────────────────────────────────────────────────────────────┤
│  🔍 ДИАГНОСТИКА                                                 │
│  • Time in OPEN: время в открытом состоянии                     │
│  • Time since last failure: время с последней ошибки            │
│  • Consecutive failures: последовательные ошибки                │
│  • HALF_OPEN attempts: количество пробных запросов              │
└─────────────────────────────────────────────────────────────────┘

ALERTS:
⚠️  Circuit Breaker OPEN > 5 minutes
⚠️  Failure rate > 50%
⚠️  State transitions > 10 per minute (flapping)
```

## 🎓 Best Practices

```
┌─────────────────────────────────────────────────────────────────┐
│                      ЛУЧШИЕ ПРАКТИКИ                           │
└─────────────────────────────────────────────────────────────────┘

✅ DO (Рекомендуется):
┌─────────────────────────────────────────────────────────────────┐
│ 1. Используйте для внешних зависимостей                        │
│    • HTTP API calls                                             │
│    • Database queries                                           │
│    • Message queue operations                                   │
│                                                                 │
│ 2. Настраивайте threshold индивидуально                        │
│    • Разные сервисы → разные пороги                            │
│    • A/B тестирование конфигурации                             │
│                                                                 │
│ 3. Логируйте переходы состояний                                │
│    log.warn("CB CLOSED → OPEN for {}", serviceName);           │
│                                                                 │
│ 4. Мониторьте метрики в реальном времени                       │
│    • Dashboards для каждого CB                                  │
│    • Alerts на критичные состояния                             │
│                                                                 │
│ 5. Реализуйте fallback стратегии                               │
│    • Cache                                                      │
│    • Default values                                             │
│    • Degraded functionality                                     │
└─────────────────────────────────────────────────────────────────┘

❌ DON'T (Не рекомендуется):
┌─────────────────────────────────────────────────────────────────┐
│ 1. НЕ используйте для локальных операций                       │
│    ❌ circuit_breaker.execute(() -> list.add(item));           │
│                                                                 │
│ 2. НЕ игнорируйте client errors (4xx)                          │
│    ❌ Считать 400 Bad Request как failure                      │
│                                                                 │
│ 3. НЕ используйте слишком низкие threshold                     │
│    ❌ failure_threshold = 1  // Слишком чувствительно         │
│                                                                 │
│ 4. НЕ забывайте про timeout в HALF_OPEN                        │
│    ❌ Бесконечные попытки восстановления                       │
│                                                                 │
│ 5. НЕ блокируйте основной поток                                │
│    ❌ while (cb.isOpen()) sleep(1s);                           │
└─────────────────────────────────────────────────────────────────┘
```

## 🚀 Когда использовать Circuit Breaker

```
┌─────────────────────────────────────────────────────────────────┐
│                    КОГДА ИСПОЛЬЗОВАТЬ                          │
└─────────────────────────────────────────────────────────────────┘

✅ ПОДХОДИТ ДЛЯ:
  • Вызовы внешних HTTP API
  • Запросы к удаленным базам данных
  • Операции с очередями сообщений
  • Microservices communication
  • Third-party сервисы (payment, email, SMS)
  • Любые операции с сетевыми таймаутами

❌ НЕ ПОДХОДИТ ДЛЯ:
  • Локальные операции (in-memory)
  • Операции с файловой системой
  • Критичные операции без fallback
  • Операции с гарантией доставки (exactly-once)
  • Идемпотентные операции с побочными эффектами
```

## 📚 Связанные паттерны

```
┌─────────────────────────────────────────────────────────────────┐
│                   СВЯЗАННЫЕ ПАТТЕРНЫ                           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│  Retry          │  • Повторные попытки при временных ошибках    │
│                 │  • Комбинируется с Circuit Breaker            │
│                 │  • Exponential backoff                        │
├─────────────────┼───────────────────────────────────────────────┤
│  Bulkhead       │  • Изоляция ресурсов                          │
│                 │  • Предотвращение полного отказа              │
│                 │  • Дополняет Circuit Breaker                  │
├─────────────────┼───────────────────────────────────────────────┤
│  Timeout        │  • Ограничение времени ожидания               │
│                 │  • Используется внутри Circuit Breaker        │
│                 │  • Критично для обнаружения медленных сервисов│
├─────────────────┼───────────────────────────────────────────────┤
│  Cache-Aside    │  • Кэширование для fallback                   │
│                 │  • Уменьшает нагрузку на сервис               │
│                 │  • Альтернативный источник данных             │
└─────────────────┴───────────────────────────────────────────────┘
```

---

**Автор**: Senior C++ Developer  
**Дата**: 2025-10-07  
**Версия**: 1.0
