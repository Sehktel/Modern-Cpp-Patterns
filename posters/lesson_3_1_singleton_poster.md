# 📊 Плакат: Singleton Pattern (Одиночка)

## 🎯 Назначение паттерна Singleton

```
┌─────────────────────────────────────────────────────────────────┐
│                    SINGLETON PATTERN                           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  🎯 ГАРАНТИРУЕТ ЕДИНСТВЕННЫЙ ЭКЗЕМПЛЯР КЛАССА                 │
│  🔒 КОНТРОЛИРУЕТ ДОСТУП К ГЛОБАЛЬНОМУ РЕСУРСУ                 │
│  🚫 ЗАПРЕЩАЕТ СОЗДАНИЕ ДОПОЛНИТЕЛЬНЫХ ЭКЗЕМПЛЯРОВ             │
└─────────────────────────────────────────────────────────────────┘

Применение:
┌─────────────────┬───────────────────────────────────────────────┐
│   Логгеры       │ • Один глобальный логгер на приложение       │
├─────────────────┼───────────────────────────────────────────────┤
│   Конфигурация  │ • Единая точка доступа к настройкам          │
├─────────────────┼───────────────────────────────────────────────┤
│   Соединения    │ • Одно подключение к базе данных             │
├─────────────────┼───────────────────────────────────────────────┤
│   Кэши          │ • Один глобальный кэш                        │
├─────────────────┼───────────────────────────────────────────────┤
│   Реестры       │ • Реестр объектов или сервисов               │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🔄 Эволюция Singleton в C++

```
┌─────────────────────────────────────────────────────────────────┐
│                 ЭВОЛЮЦИЯ РЕАЛИЗАЦИЙ                            │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│   Классический  │   Thread-Safe   │   Meyers        │   Современный   │
│   (проблемный)  │   (с мьютексом) │   (рекомендуемый)│   (альтернативы)│
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│ ❌ Не thread-safe│ ✅ Thread-safe  │ ✅ Thread-safe  │ ✅ Лучшие       │
│ ❌ Утечки памяти│ ❌ Накладные     │ ✅ Без накладных│   альтернативы  │
│ ❌ Сложно тест. │    расходы       │    расходов     │                 │
│ ❌ Нарушает     │ ✅ Автом. память │ ✅ Простота     │ • DI Container  │
│    принципы     │ ❌ Двойная       │ ✅ Ленивая      │ • Service Locator│
│                 │    проверка      │    инициализация│ • Global State  │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

## 🏗️ Структура Singleton

```
┌─────────────────────────────────────────────────────────────────┐
│                    СТРУКТУРА SINGLETON                         │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ class Singleton {                                               │
│ private:                                                        │
│     static Singleton* instance_;        ← Статическая переменная│
│     Singleton();                        ← Приватный конструктор │
│                                                                 │
│ public:                                                         │
│     static Singleton& getInstance();    ← Статический метод     │
│     Singleton(const Singleton&) = delete; ← Запрет копирования  │
│     Singleton& operator=(const Singleton&) = delete; ← Запрет   │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    ПОСЛЕДОВАТЕЛЬНОСТЬ ВЫЗОВОВ                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   1. Вызов      │ Singleton::getInstance()                      │
│      getInstance│                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   2. Проверка   │ if (instance_ == nullptr)                     │
│      существования│                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   3. Создание   │ instance_ = new Singleton()                   │
│      (если нет) │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   4. Возврат    │ return *instance_                             │
│      ссылки     │                                               │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🚨 Проблемы классического Singleton

```
┌─────────────────────────────────────────────────────────────────┐
│                    ПРОБЛЕМЫ SINGLETON                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   Thread Safety │ ❌ Race condition в getInstance()             │
│                 │ • Несколько потоков могут создать экземпляры  │
│                 │ • Необходимы мьютексы или атомарные операции │
├─────────────────┼───────────────────────────────────────────────┤
│   Утечки памяти │ ❌ Нет автоматического освобождения           │
│                 │ • delete никогда не вызывается               │
│                 │ • Память освобождается только при завершении │
├─────────────────┼───────────────────────────────────────────────┤
│   Тестирование  │ ❌ Сложно изолировать тесты                   │
│                 │ • Глобальное состояние влияет на все тесты    │
│                 │ • Невозможно создать моки                    │
├─────────────────┼───────────────────────────────────────────────┤
│   Принципы      │ ❌ Нарушает SOLID принципы                    │
│   проектирования│ • Single Responsibility Principle             │
│                 │ • Dependency Inversion Principle              │
└─────────────────┴───────────────────────────────────────────────┘
```

## ✅ Современные реализации

### Meyers Singleton (Рекомендуемый)
```
┌─────────────────────────────────────────────────────────────────┐
│                   MEYERS SINGLETON                             │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ class MeyersSingleton {                                         │
│ private:                                                        │
│     MeyersSingleton() = default;                                │
│                                                                 │
│ public:                                                         │
│     static MeyersSingleton& getInstance() {                     │
│         static MeyersSingleton instance;  ← Thread-safe с C++11│
│         return instance;                                        │
│     }                                                           │
│                                                                 │
│     MeyersSingleton(const MeyersSingleton&) = delete;           │
│     MeyersSingleton& operator=(const MeyersSingleton&) = delete;│
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘

Преимущества:
✅ Thread-safe с C++11 (гарантируется стандартом)
✅ Ленивая инициализация
✅ Автоматическое управление памятью
✅ Нет накладных расходов на блокировки
✅ Простая и элегантная реализация
```

### Template Singleton
```
┌─────────────────────────────────────────────────────────────────┐
│                   TEMPLATE SINGLETON                           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ template<typename T>                                            │
│ class Singleton {                                               │
│ protected:                                                      │
│     Singleton() = default;                                      │
│                                                                 │
│ public:                                                         │
│     static T& getInstance() {                                   │
│         static T instance;                                      │
│         return instance;                                        │
│     }                                                           │
│                                                                 │
│     Singleton(const Singleton&) = delete;                       │
│     Singleton& operator=(const Singleton&) = delete;            │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘

Использование:
┌─────────────────────────────────────────────────────────────────┐
│ class MyService : public Singleton<MyService> {                 │
│     friend class Singleton<MyService>;                          │
│ private:                                                        │
│     MyService() = default;                                      │
│ };                                                              │
│                                                                 │
│ auto& service = MyService::getInstance();                       │
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 Альтернативы Singleton

```
┌─────────────────────────────────────────────────────────────────┐
│                    АЛЬТЕРНАТИВЫ SINGLETON                      │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   Dependency    │ ✅ Явные зависимости                          │
│   Injection     │ • Передача через конструктор/методы          │
│                 │ • Легко тестировать с моками                 │
│                 │ • Следует принципам SOLID                    │
├─────────────────┼───────────────────────────────────────────────┤
│   Service       │ ✅ Реестр сервисов                            │
│   Locator       │ • Гибкое управление сервисами                │
│                 │ • Возможность замены реализаций               │
│                 │ • Явная регистрация зависимостей             │
├─────────────────┼───────────────────────────────────────────────┤
│   Global        │ ✅ Простые глобальные переменные              │
│   Variables     │ • Для простых случаев                         │
│                 │ • Меньше кода                                 │
│                 │ • Прямолинейный подход                        │
├─────────────────┼───────────────────────────────────────────────┤
│   Monostate     │ ✅ Несколько объектов с общим состоянием     │
│                 │ • Выглядит как обычный класс                  │
│                 │ • Все экземпляры разделяют состояние          │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🎨 Сравнение подходов

### Singleton vs Dependency Injection
```
┌─────────────────────────────────────────────────────────────────┐
│            SINGLETON vs DEPENDENCY INJECTION                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   Singleton     │ ❌ Скрытые зависимости                        │
│   (плохо)       │ class UserService {                           │
│                 │ public:                                       │
│                 │     void saveUser(const User& user) {         │
│                 │         Logger::getInstance().log(...); ← Скрытая│
│                 │     }                                         │
│                 │ };                                            │
├─────────────────┼───────────────────────────────────────────────┤
│   Dependency    │ ✅ Явные зависимости                          │
│   Injection     │ class UserService {                           │
│   (хорошо)      │ private:                                      │
│                 │     Logger& logger_;                          │
│                 │ public:                                       │
│                 │     UserService(Logger& logger) : logger_(logger) {}│
│                 │     void saveUser(const User& user) {         │
│                 │         logger_.log(...); ← Явная зависимость │
│                 │     }                                         │
│                 │ };                                            │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🧪 Тестирование

```
┌─────────────────────────────────────────────────────────────────┐
│                    ТЕСТИРОВАНИЕ SINGLETON                      │
└─────────────────────────────────────────────────────────────────┘

Проблемы с тестированием:
┌─────────────────┬───────────────────────────────────────────────┐
│   Глобальное    │ ❌ Тесты влияют друг на друга                 │
│   состояние     │ • Изменения в одном тесте влияют на другие    │
│                 │ • Невозможно изолировать тесты                │
├─────────────────┼───────────────────────────────────────────────┤
│   Порядок       │ ❌ Зависимость от порядка выполнения          │
│   выполнения    │ • Тесты могут падать в зависимости от порядка │
│                 │ • Непредсказуемое поведение                  │
├─────────────────┼───────────────────────────────────────────────┤
│   Моки          │ ❌ Сложно создавать моки                      │
│                 │ • Глобальное состояние не поддается мокированию│
│                 │ • Невозможно тестировать edge cases           │
└─────────────────┴───────────────────────────────────────────────┘

Решение через DI:
┌─────────────────┬───────────────────────────────────────────────┐
│   Явные         │ ✅ Легко создавать моки                       │
│   зависимости   │ class MockLogger : public Logger {            │
│                 │     void log(const std::string& msg) override {│
│                 │         // Мок-реализация                     │
│                 │     }                                         │
│                 │ };                                            │
│                 │                                               │
│                 │ TEST(UserServiceTest, SaveUser) {             │
│                 │     MockLogger mockLogger;                    │
│                 │     UserService service(mockLogger);          │
│                 │     // Легко тестировать                      │
│                 │ }                                             │
└─────────────────┴───────────────────────────────────────────────┘
```

## 💡 Практические рекомендации

```
┌─────────────────────────────────────────────────────────────────┐
│                  ПРАКТИЧЕСКИЕ РЕКОМЕНДАЦИИ                     │
└─────────────────────────────────────────────────────────────────┘

Когда ИСПОЛЬЗОВАТЬ Singleton:
✅ • Логгеры (один глобальный логгер)
✅ • Конфигурация приложения
✅ • Соединения с базой данных (connection pool)
✅ • Кэши (один глобальный кэш)
✅ • Реестры объектов

Когда НЕ использовать Singleton:
❌ • Когда нужны несколько экземпляров
❌ • Для объектов с состоянием
❌ • Когда нужно тестировать изоляцию
❌ • Для простых утилитарных функций
❌ • Когда можно использовать DI

Альтернативы по приоритету:
1. 🥇 Dependency Injection
2. 🥈 Service Locator  
3. 🥉 Global Variables
4. 🏅 Monostate
5. 🚫 Singleton (последний выбор)

Реализация:
1. 🎯 Используйте Meyers Singleton
2. 🛡️ Запрещайте копирование и присваивание
3. 📝 Документируйте причины использования
4. 🧪 Рассмотрите возможность тестирования
5. 🔄 Планируйте миграцию на DI в будущем
```

## 🎓 Ключевые выводы

```
┌─────────────────────────────────────────────────────────────────┐
│                      КЛЮЧЕВЫЕ ВЫВОДЫ                          │
└─────────────────────────────────────────────────────────────────┘

✅ Singleton - это глобальная переменная в маскировке:
   • Скрывает зависимости
   • Нарушает принципы SOLID
   • Усложняет тестирование

✅ Современные реализации:
   • Meyers Singleton - лучший выбор
   • Thread-safe с C++11
   • Автоматическое управление памятью

✅ Рассмотрите альтернативы:
   • Dependency Injection для тестируемости
   • Service Locator для гибкости
   • Global variables для простоты

✅ Используйте только когда действительно нужен единственный экземпляр:
   • Логгеры, конфигурации, кэши
   • Документируйте причины использования
   • Планируйте миграцию на DI

⚠️ Помните: Singleton часто является признаком плохого дизайна!
```

---
*Singleton - один из самых спорных паттернов. Используйте его осторожно 
и всегда рассматривайте альтернативы!*
