# 📊 Плакат: Bulkhead Pattern

## 🎯 Концепция Bulkhead

```
┌─────────────────────────────────────────────────────────────────┐
│                     BULKHEAD PATTERN                           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  🚢 ИЗОЛЯЦИЯ РЕСУРСОВ ПО ОТСЕКАМ (КАК НА КОРАБЛЕ)             │
│  🔒 ОГРАНИЧЕНИЕ РАСПРОСТРАНЕНИЯ ОТКАЗОВ                        │
│  ⚖️ ЗАЩИТА КРИТИЧНЫХ СЕРВИСОВ ОТ ПЕРЕГРУЗКИ                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   ПРОБЛЕМА      │  • Один сервис потребляет все ресурсы         │
│                 │  • Медленный сервис блокирует все потоки      │
│                 │  • Отказ одного компонента → отказ всей системы│
│                 │  • Нет приоритизации критичных операций       │
├─────────────────┼───────────────────────────────────────────────┤
│   РЕШЕНИЕ       │  • Изолированные пулы ресурсов                │
│                 │  • Ограничения на каждый сервис               │
│                 │  • Независимые Thread Pools                    │
│                 │  • Отказ одного отсека не топит весь корабль  │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🚢 Аналогия с кораблем

```
┌─────────────────────────────────────────────────────────────────┐
│                BULKHEAD НА КОРАБЛЕ (Ship Analogy)              │
└─────────────────────────────────────────────────────────────────┘

БЕЗ BULKHEADS:
┌─────────────────────────────────────────────────────────────────┐
│                         КОРАБЛЬ                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                                                          │  │
│  │              Единое пространство                         │  │
│  │                                                          │  │
│  │  💧 ПРОБОИНА → Вода заполняет весь корабль → 💀        │  │
│  │                                                          │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
         ⚠️ ОДНА ПРОБЛЕМА → ПОЛНЫЙ ОТКАЗ СИСТЕМЫ

С BULKHEADS:
┌─────────────────────────────────────────────────────────────────┐
│                         КОРАБЛЬ                                 │
│  ┌────────┬────────┬────────┬────────┬────────┐               │
│  │Отсек 1 │Отсек 2 │Отсек 3 │Отсек 4 │Отсек 5 │               │
│  │   ✅   │   ✅   │  💧    │   ✅   │   ✅   │               │
│  │        │        │ ЗАТОП  │        │        │               │
│  │ Работ. │ Работ. │  ЛЕН   │ Работ. │ Работ. │               │
│  └────────┴────────┴────────┴────────┴────────┘               │
└─────────────────────────────────────────────────────────────────┘
         ✅ ИЗОЛЯЦИЯ → 80% ФУНКЦИОНАЛЬНОСТИ СОХРАНЕНО
```

## 🏗️ Типы изоляции ресурсов

```
┌─────────────────────────────────────────────────────────────────┐
│                  ТИПЫ BULKHEAD ИЗОЛЯЦИИ                        │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  1. THREAD POOL BULKHEAD                                        │
│     ┌───────────────────────────────────────────────┐          │
│     │  Critical Service:  4 threads (max 10 tasks) │          │
│     │  Normal Service:    2 threads (max 5 tasks)  │          │
│     │  Batch Service:     1 thread  (max 20 tasks) │          │
│     └───────────────────────────────────────────────┘          │
│                                                                 │
│     • Отдельный Thread Pool для каждого сервиса                │
│     • Один сервис не блокирует другие                          │
│     • Bounded queue для контроля памяти                        │
├─────────────────────────────────────────────────────────────────┤
│  2. CONNECTION POOL BULKHEAD                                    │
│     ┌───────────────────────────────────────────────┐          │
│     │  Primary DB:     20 connections               │          │
│     │  Analytics DB:   5 connections                │          │
│     │  Cache:          10 connections               │          │
│     └───────────────────────────────────────────────┘          │
│                                                                 │
│     • Лимит соединений на каждую зависимость                   │
│     • Защита от connection exhaustion                          │
│     • Приоритизация критичных сервисов                         │
├─────────────────────────────────────────────────────────────────┤
│  3. MEMORY BULKHEAD                                             │
│     ┌───────────────────────────────────────────────┐          │
│     │  Service A: max 100 MB memory                 │          │
│     │  Service B: max 50 MB memory                  │          │
│     │  Service C: max 200 MB memory                 │          │
│     └───────────────────────────────────────────────┘          │
│                                                                 │
│     • Лимит памяти на каждый сервис                            │
│     • Предотвращение OOM (Out Of Memory)                       │
│     • Мониторинг использования памяти                          │
├─────────────────────────────────────────────────────────────────┤
│  4. SEMAPHORE BULKHEAD                                          │
│     ┌───────────────────────────────────────────────┐          │
│     │  Semaphore limit: 10 concurrent requests      │          │
│     │  Acquire → Execute → Release                  │          │
│     └───────────────────────────────────────────────┘          │
│                                                                 │
│     • Ограничение параллельных запросов                        │
│     • Легковесная альтернатива Thread Pool                     │
│     • Минимальный overhead                                     │
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 Thread Pool Bulkhead архитектура

```
┌─────────────────────────────────────────────────────────────────┐
│            THREAD POOL BULKHEAD ARCHITECTURE                   │
└─────────────────────────────────────────────────────────────────┘

            ┌───────────────────────────────────┐
            │    APPLICATION REQUEST HANDLER    │
            └───────────────────────────────────┘
                          │
                          ↓
      ┌───────────────────────────────────────────────┐
      │         BULKHEAD MANAGER (Dispatcher)         │
      └───────────────────────────────────────────────┘
        │                  │                  │
        ↓                  ↓                  ↓
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│  CRITICAL    │  │   NORMAL     │  │    BATCH     │
│  BULKHEAD    │  │  BULKHEAD    │  │  BULKHEAD    │
│              │  │              │  │              │
│ Thread Pool  │  │ Thread Pool  │  │ Thread Pool  │
│ Size: 4      │  │ Size: 2      │  │ Size: 1      │
│ Queue: 10    │  │ Queue: 5     │  │ Queue: 20    │
│              │  │              │  │              │
│ ┌──┐┌──┐    │  │ ┌──┐         │  │ ┌──┐         │
│ │T1││T2│... │  │ │T1│...      │  │ │T1│...      │
│ └──┘└──┘    │  │ └──┘         │  │ └──┘         │
└──────────────┘  └──────────────┘  └──────────────┘
       │                 │                 │
       ↓                 ↓                 ↓
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│   Payment    │  │   Search     │  │  Analytics   │
│   Service    │  │   Service    │  │   Service    │
└──────────────┘  └──────────────┘  └──────────────┘

⚠️ Если Analytics Service упал или медленный:
   • Блокируется только BATCH bulkhead
   • CRITICAL и NORMAL bulkheads работают нормально
   • Система продолжает обслуживать важные запросы
```

## 💡 Сравнение подходов

```
┌─────────────────────────────────────────────────────────────────┐
│          БЕЗ BULKHEAD vs С BULKHEAD ИЗОЛЯЦИЕЙ                  │
└─────────────────────────────────────────────────────────────────┘

❌ БЕЗ BULKHEAD (Shared Thread Pool):
┌─────────────────────────────────────────────────────────────────┐
│ ThreadPoolExecutor pool = new ThreadPoolExecutor(10, ...);      │
│                                                                 │
│ // Все сервисы используют один пул!                            │
│ pool.submit(() -> criticalService.process());  // Критичный    │
│ pool.submit(() -> normalService.process());    // Обычный      │
│ pool.submit(() -> slowService.process());      // Медленный 🐌│
│                                                                 │
│ // Медленный сервис забирает все 10 потоков!                   │
│ // Критичные запросы ждут в очереди... 😱                     │
│                                                                 │
│ ⚠️ ПРОБЛЕМЫ:                                                   │
│  • Медленный сервис блокирует все потоки                       │
│  • Критичные операции не имеют приоритета                      │
│  • Один плохой сервис → весь pool недоступен                   │
│  • Thread starvation для важных операций                       │
│  • Cascading failure по всей системе                           │
└─────────────────────────────────────────────────────────────────┘

✅ С BULKHEAD (Isolated Thread Pools):
┌─────────────────────────────────────────────────────────────────┐
│ // Отдельные пулы для каждого типа сервиса                     │
│ ThreadPool criticalPool = new ThreadPool(4, 10);               │
│ ThreadPool normalPool = new ThreadPool(2, 5);                  │
│ ThreadPool batchPool = new ThreadPool(1, 20);                  │
│                                                                 │
│ // Каждый сервис изолирован                                    │
│ criticalPool.submit(() -> criticalService.process());          │
│ normalPool.submit(() -> normalService.process());              │
│ batchPool.submit(() -> slowService.process()); // 🐌 Изолирован│
│                                                                 │
│ // Медленный сервис блокирует только свой bulkhead             │
│ // Критичные операции продолжают работать! ✅                  │
│                                                                 │
│ ✅ ПРЕИМУЩЕСТВА:                                               │
│  • Изоляция отказов (fault isolation)                          │
│  • Гарантированные ресурсы для критичных сервисов              │
│  • Один плохой сервис не влияет на другие                      │
│  • Graceful degradation (постепенная деградация)               │
│  • Контролируемое использование ресурсов                       │
└─────────────────────────────────────────────────────────────────┘
```

## 🔧 Реализация Bulkhead Manager

```
┌─────────────────────────────────────────────────────────────────┐
│              BULKHEAD MANAGER IMPLEMENTATION                   │
└─────────────────────────────────────────────────────────────────┘

enum class ServiceType {
    CRITICAL,    // Высший приоритет
    NORMAL,      // Обычный приоритет
    BATCH        // Фоновые задачи
};

class BulkheadManager {
private:
    std::unordered_map<ServiceType, 
                      std::shared_ptr<ThreadPoolBulkhead>> bulkheads_;
    
public:
    void registerBulkhead(ServiceType type, 
                         size_t num_threads, 
                         size_t max_queue_size) {
        auto bulkhead = std::make_shared<ThreadPoolBulkhead>(
            serviceTypeToString(type), 
            type, 
            num_threads, 
            max_queue_size
        );
        bulkheads_[type] = bulkhead;
    }
    
    bool execute(ServiceType type, Task task) {
        auto it = bulkheads_.find(type);
        if (it != bulkheads_.end()) {
            return it->second->enqueue(std::move(task));
        }
        return false;
    }
    
    void printAllStats() const {
        for (const auto& [type, bulkhead] : bulkheads_) {
            bulkhead->printStats();
        }
    }
};

ИСПОЛЬЗОВАНИЕ:
┌─────────────────────────────────────────────────────────────────┐
│ BulkheadManager manager;                                        │
│                                                                 │
│ // Регистрируем bulkheads                                       │
│ manager.registerBulkhead(ServiceType::CRITICAL, 4, 10);        │
│ manager.registerBulkhead(ServiceType::NORMAL, 2, 5);           │
│ manager.registerBulkhead(ServiceType::BATCH, 1, 20);           │
│                                                                 │
│ // Выполняем задачи через соответствующий bulkhead             │
│ manager.execute(ServiceType::CRITICAL, criticalTask);          │
│ manager.execute(ServiceType::BATCH, batchTask);                │
└─────────────────────────────────────────────────────────────────┘
```

## 🛡️ Bulkhead + Circuit Breaker

```
┌─────────────────────────────────────────────────────────────────┐
│          КОМБИНАЦИЯ BULKHEAD + CIRCUIT BREAKER                 │
└─────────────────────────────────────────────────────────────────┘

                    ┌──────────────┐
                    │   Request    │
                    └──────────────┘
                           │
                           ↓
                 ┌──────────────────┐
                 │ Circuit Breaker  │
                 │   (Проверка)     │
                 └──────────────────┘
                    │            │
              CLOSED│            │OPEN
                    ↓            ↓
           ┌────────────┐   ┌────────────┐
           │  Bulkhead  │   │  Fast Fail │
           │  (Execute) │   │  (Reject)  │
           └────────────┘   └────────────┘
                │
                ↓
          ┌──────────┐
          │ Service  │
          └──────────┘

ПРИМЕР:
┌─────────────────────────────────────────────────────────────────┐
│ auto result = circuitBreaker.execute([&]() {                   │
│     return bulkhead.execute(ServiceType::CRITICAL, [&]() {     │
│         return externalService.call();                          │
│     });                                                         │
│ });                                                             │
│                                                                 │
│ ЗАЩИТА НА ДВУХ УРОВНЯХ:                                        │
│  1. Circuit Breaker: быстрый отказ если сервис недоступен      │
│  2. Bulkhead: изоляция ресурсов от медленных сервисов          │
└─────────────────────────────────────────────────────────────────┘
```

## ⚠️ Проблемы и решения

```
┌─────────────────────────────────────────────────────────────────┐
│                  ТИПИЧНЫЕ ПРОБЛЕМЫ И РЕШЕНИЯ                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   RESOURCE      │  РЕШЕНИЕ:                                     │
│   WASTE         │  • Динамическое масштабирование пулов         │
│                 │  • Shared pool с приоритетами (fallback)      │
│   Idle потоки в │  • Мониторинг утилизации                      │
│   некоторых     │  • Автоподстройка размеров пулов              │
│   bulkheads     │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   QUEUE         │  РЕШЕНИЕ:                                     │
│   OVERFLOW      │  • Bounded queue с rejection policy           │
│                 │  • Backpressure механизм                      │
│   Задачи        │  • Priority-based dropping                    │
│   переполняют   │  • Метрики queue size                         │
│   очередь       │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   PRIORITY      │  РЕШЕНИЕ:                                     │
│   INVERSION     │  • Правильная классификация задач             │
│                 │  • Dedicated pools для разных приоритетов     │
│   Низкоприори-  │  • SLA monitoring                             │
│   тетные задачи │  • Dynamic priority adjustment                │
│   блокируют     │                                               │
│   высокоприори- │                                               │
│   тетные        │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   CONFIGURATION │  РЕШЕНИЕ:                                     │
│   COMPLEXITY    │  • Start simple, optimize later               │
│                 │  • Load testing для определения размеров      │
│   Сложно опре-  │  • Adaptive bulkhead sizes                    │
│   делить раз-   │  • Canary deployments для тестирования        │
│   меры пулов    │                                               │
└─────────────────┴───────────────────────────────────────────────┘
```

## 📊 Метрики и мониторинг

```
┌─────────────────────────────────────────────────────────────────┐
│                   КЛЮЧЕВЫЕ МЕТРИКИ BULKHEAD                    │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  📈 УТИЛИЗАЦИЯ РЕСУРСОВ                                         │
│  • Active threads: активных потоков / макс                      │
│  • Idle threads: простаивающих потоков                          │
│  • Queue size: размер очереди / макс                            │
│  • Thread pool saturation: % заполнения пула                    │
│  • Memory usage: использование памяти                           │
├─────────────────────────────────────────────────────────────────┤
│  ⏱️ ПРОИЗВОДИТЕЛЬНОСТЬ                                          │
│  • Tasks throughput: задач в секунду                            │
│  • Queue wait time: время ожидания в очереди                    │
│  • Task execution time: время выполнения задачи                 │
│  • Rejected tasks: количество отклоненных задач                 │
├─────────────────────────────────────────────────────────────────┤
│  🔍 ДИАГНОСТИКА                                                 │
│  • Tasks queued: всего в очереди                                │
│  • Tasks completed: завершенных задач                           │
│  • Tasks failed: неудачных задач                                │
│  • Average utilization: средняя утилизация                      │
└─────────────────────────────────────────────────────────────────┘

ALERTS:
⚠️  Queue size > 80% capacity
⚠️  Thread pool saturation > 90% for > 5 minutes
⚠️  Rejection rate > 10%
⚠️  Average wait time > 1 second
```

## 🎓 Sizing Guidelines

```
┌─────────────────────────────────────────────────────────────────┐
│              РЕКОМЕНДАЦИИ ПО РАЗМЕРАМ BULKHEAD                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  THREAD POOL SIZE:                                              │
│                                                                 │
│  • CPU-bound задачи:                                            │
│    pool_size = num_cores + 1                                    │
│                                                                 │
│  • I/O-bound задачи:                                            │
│    pool_size = num_cores * (1 + wait_time / compute_time)     │
│                                                                 │
│  • Смешанные задачи:                                            │
│    Начать с num_cores * 2, затем tune по метрикам              │
├─────────────────────────────────────────────────────────────────┤
│  QUEUE SIZE:                                                    │
│                                                                 │
│  • queue_size = thread_pool_size * avg_task_time / request_rate│
│                                                                 │
│  • Минимум: thread_pool_size                                    │
│  • Максимум: не более 100-200 задач (memory overhead)          │
│                                                                 │
│  • Для критичных сервисов: меньшая очередь (fast fail)         │
│  • Для batch: большая очередь (накопление)                     │
├─────────────────────────────────────────────────────────────────┤
│  ПРИМЕРЫ КОНФИГУРАЦИИ:                                          │
│                                                                 │
│  Critical Service (Payment):                                    │
│    threads = 8, queue = 16                                      │
│                                                                 │
│  Normal Service (Search):                                       │
│    threads = 4, queue = 10                                      │
│                                                                 │
│  Batch Service (Analytics):                                     │
│    threads = 2, queue = 100                                     │
└─────────────────────────────────────────────────────────────────┘
```

## 🎓 Best Practices

```
┌─────────────────────────────────────────────────────────────────┐
│                      ЛУЧШИЕ ПРАКТИКИ                           │
└─────────────────────────────────────────────────────────────────┘

✅ DO (Рекомендуется):
┌─────────────────────────────────────────────────────────────────┐
│ 1. Изолируйте критичные от некритичных сервисов                │
│    • Платежи ≠ Аналитика                                       │
│                                                                 │
│ 2. Используйте bounded queues                                   │
│    • Предотвращает OOM                                          │
│    • Fast fail лучше чем медленный ответ                       │
│                                                                 │
│ 3. Мониторьте метрики в реальном времени                       │
│    • Dashboard для каждого bulkhead                             │
│    • Alerts на saturation                                       │
│                                                                 │
│ 4. Load testing перед продакшеном                              │
│    • Определите оптимальные размеры                            │
│    • Проверьте поведение под нагрузкой                         │
│                                                                 │
│ 5. Комбинируйте с Circuit Breaker                              │
│    • Двойная защита                                             │
│    • Быстрый отказ + изоляция                                  │
└─────────────────────────────────────────────────────────────────┘

❌ DON'T (Не рекомендуется):
┌─────────────────────────────────────────────────────────────────┐
│ 1. НЕ делайте слишком много bulkheads                          │
│    ❌ Один bulkhead на каждый метод                            │
│                                                                 │
│ 2. НЕ используйте unbounded queues                             │
│    ❌ queue_size = Integer.MAX_VALUE                           │
│                                                                 │
│ 3. НЕ игнорируйте rejected tasks                               │
│    ❌ catch (RejectedExecutionException e) {}                  │
│                                                                 │
│ 4. НЕ делайте пулы слишком маленькими                          │
│    ❌ thread_pool_size = 1 для критичного сервиса             │
│                                                                 │
│ 5. НЕ забывайте про graceful shutdown                          │
│    ❌ pool.shutdownNow(); // Теряем задачи в очереди          │
└─────────────────────────────────────────────────────────────────┘
```

## 🚀 Когда использовать Bulkhead

```
┌─────────────────────────────────────────────────────────────────┐
│                    КОГДА ИСПОЛЬЗОВАТЬ                          │
└─────────────────────────────────────────────────────────────────┘

✅ ПОДХОДИТ ДЛЯ:
  • Microservices с разными SLA
  • Критичные vs некритичные операции
  • Медленные внешние зависимости
  • Multi-tenant системы (изоляция клиентов)
  • CPU vs I/O bound задачи
  • Batch vs real-time обработка

❌ НЕ ПОДХОДИТ ДЛЯ:
  • Простые приложения с одним сервисом
  • Системы с равномерной нагрузкой
  • Когда все операции критичны
  • Ресурсы не являются bottleneck
  • Overhead bulkhead > выгода от изоляции
```

## 📚 Связанные паттерны

```
┌─────────────────────────────────────────────────────────────────┐
│                   СВЯЗАННЫЕ ПАТТЕРНЫ                           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│  Circuit        │  • Защита от каскадных отказов                │
│  Breaker        │  • Комбинируется с Bulkhead                   │
│                 │  • Fast fail + Isolation                      │
├─────────────────┼───────────────────────────────────────────────┤
│  Rate Limiting  │  • Ограничение входящего трафика              │
│                 │  • Дополняет Bulkhead                         │
│                 │  • Защита от перегрузки                       │
├─────────────────┼───────────────────────────────────────────────┤
│  Retry          │  • Повторные попытки при отказе               │
│                 │  • Может вызывать queue overflow              │
│                 │  • Требует осторожности с Bulkhead            │
├─────────────────┼───────────────────────────────────────────────┤
│  Timeout        │  • Ограничение времени выполнения             │
│                 │  • Освобождает ресурсы                        │
│                 │  • Критично для Bulkhead эффективности        │
└─────────────────┴───────────────────────────────────────────────┘
```

---

**Автор**: Senior C++ Developer  
**Дата**: 2025-10-07  
**Версия**: 1.0
