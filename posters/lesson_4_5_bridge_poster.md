# 📊 Плакат: Bridge Pattern (Мост)

## 🎯 Назначение паттерна Bridge

```
┌─────────────────────────────────────────────────────────────────┐
│                        BRIDGE PATTERN                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  🌉 РАЗДЕЛЯЕТ АБСТРАКЦИЮ И РЕАЛИЗАЦИЮ                          │
│  🔄 ПОЗВОЛЯЕТ ИЗМЕНЯТЬ ИХ НЕЗАВИСИМО ДРУГ ОТ ДРУГА             │
│  🎯 ИЗБЕГАЕТ ПОСТОЯННОГО НАСЛЕДОВАНИЯ                           │
└─────────────────────────────────────────────────────────────────┘

Применение:
┌─────────────────┬───────────────────────────────────────────────┐
│   UI Framework  │ • Разделение элементов интерфейса и их       │
│                 │   рендеринга (Windows, macOS, Linux)          │
├─────────────────┼───────────────────────────────────────────────┤
│   Базы данных   │ • Разделение SQL запросов и драйверов БД     │
├─────────────────┼───────────────────────────────────────────────┤
│   Драйверы      │ • Разделение высокоуровневого API и          │
│                 │   низкоуровневых драйверов устройств          │
├─────────────────┼───────────────────────────────────────────────┤
│   Форматы       │ • Разделение данных и их сериализации        │
├─────────────────┼───────────────────────────────────────────────┤
│   Платформы     │ • Разделение бизнес-логики и платформенных   │
│                 │   особенностей                                │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🔄 Проблема без Bridge

```
┌─────────────────────────────────────────────────────────────────┐
│                    ПРОБЛЕМА: ВЗРЫВ НАСЛЕДОВАНИЯ               │
└─────────────────────────────────────────────────────────────────┘

❌ ПЛОХО - Постоянное наследование:
┌─────────────────────────────────────────────────────────────────┐
│ class Shape {                                                   │
│ public:                                                         │
│     virtual void draw() = 0;                                   │
│ };                                                              │
│                                                                 │
│ class Circle : public Shape {                                  │
│ public:                                                         │
│     void draw() override { /* рисование круга */ }             │
│ };                                                              │
│                                                                 │
│ class WindowsCircle : public Circle {                          │
│ public:                                                         │
│     void draw() override { /* Windows API для круга */ }       │
│ };                                                              │
│                                                                 │
│ class MacOSCircle : public Circle {                            │
│ public:                                                         │
│     void draw() override { /* macOS API для круга */ }         │
│ };                                                              │
│                                                                 │
│ class LinuxCircle : public Circle {                            │
│ public:                                                         │
│     void draw() override { /* Linux API для круга */ }         │
│ };                                                              │
│                                                                 │
│ // Проблемы:                                                    │
│ // • Взрыв классов (n × m комбинаций)                          │
│ // • Дублирование кода                                         │
│ // • Нарушение Open/Closed Principle                           │
│ // • Сложность добавления новых платформ/фигур                 │
└─────────────────────────────────────────────────────────────────┘
```

## ✅ Решение с Bridge

```
┌─────────────────────────────────────────────────────────────────┐
│                    РЕШЕНИЕ: РАЗДЕЛЕНИЕ                         │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШО - Разделение абстракции и реализации:
┌─────────────────────────────────────────────────────────────────┐
│ // Абстракция                                                   │
│ class Shape {                                                   │
│ protected:                                                      │
│     std::unique_ptr<Renderer> renderer_;                        │
│                                                                 │
│ public:                                                         │
│     Shape(std::unique_ptr<Renderer> renderer)                   │
│         : renderer_(std::move(renderer)) {}                     │
│                                                                 │
│     virtual void draw() = 0;                                   │
│     virtual ~Shape() = default;                                 │
│ };                                                              │
│                                                                 │
│ class Circle : public Shape {                                  │
│ private:                                                        │
│     double x_, y_, radius_;                                     │
│                                                                 │
│ public:                                                         │
│     Circle(double x, double y, double radius,                   │
│            std::unique_ptr<Renderer> renderer)                  │
│         : Shape(std::move(renderer)), x_(x), y_(y), radius_(radius) {} │
│                                                                 │
│     void draw() override {                                      │
│         renderer_->drawCircle(x_, y_, radius_);                 │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ // Реализация                                                   │
│ class Renderer {                                                │
│ public:                                                         │
│     virtual void drawCircle(double x, double y, double radius) = 0; │
│     virtual ~Renderer() = default;                              │
│ };                                                              │
│                                                                 │
│ class WindowsRenderer : public Renderer {                      │
│ public:                                                         │
│     void drawCircle(double x, double y, double radius) override { │
│         // Windows API для рисования круга                     │
│         std::cout << "Windows: Drawing circle at ("            │
│                   << x << ", " << y << ") with radius "         │
│                   << radius << std::endl;                       │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ class MacOSRenderer : public Renderer {                        │
│ public:                                                         │
│     void drawCircle(double x, double y, double radius) override { │
│         // macOS API для рисования круга                        │
│         std::cout << "macOS: Drawing circle at ("              │
│                   << x << ", " << y << ") with radius "         │
│                   << radius << std::endl;                       │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘

Использование:
┌─────────────────────────────────────────────────────────────────┐
│ // Создание круга с Windows рендерером                         │
│ auto windowsRenderer = std::make_unique<WindowsRenderer>();      │
│ auto circle1 = std::make_unique<Circle>(10, 20, 5,             │
│                                        std::move(windowsRenderer)); │
│ circle1->draw();                                                │
│                                                                 │
│ // Создание круга с macOS рендерером                           │
│ auto macRenderer = std::make_unique<MacOSRenderer>();           │
│ auto circle2 = std::make_unique<Circle>(30, 40, 8,             │
│                                        std::move(macRenderer)); │
│ circle2->draw();                                               │
└─────────────────────────────────────────────────────────────────┘

Преимущества:
✅ Разделение абстракции и реализации
✅ Избежание взрыва классов
✅ Соблюдение Open/Closed Principle
✅ Независимое изменение абстракции и реализации
```

## 🏗️ Структура Bridge

```
┌─────────────────────────────────────────────────────────────────┐
│                    СТРУКТУРА ПАТТЕРНА                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Abstraction (Абстракция)                    │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class Shape {                                               ││
│  │ protected:                                                  ││
│  │     std::unique_ptr<Renderer> renderer_;                    ││
│  │                                                             ││
│  │ public:                                                     ││
│  │     Shape(std::unique_ptr<Renderer> renderer);             ││
│  │     virtual void draw() = 0;                               ││
│  │     virtual ~Shape() = default;                            ││
│  │ };                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    RefinedAbstraction (Уточненная абстракция)   │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class Circle : public Shape {                              ││
│  │ private:                                                    ││
│  │     double x_, y_, radius_;                                 ││
│  │                                                             ││
│  │ public:                                                     ││
│  │     Circle(double x, double y, double radius,               ││
│  │            std::unique_ptr<Renderer> renderer);            ││
│  │     void draw() override;                                  ││
│  │ };                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Implementor (Реализатор)                     │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class Renderer {                                            ││
│  │ public:                                                     ││
│  │     virtual void drawCircle(double x, double y, double radius) = 0; ││
│  │     virtual void drawRectangle(double x, double y,          ││
│  │                              double width, double height) = 0; ││
│  │     virtual ~Renderer() = default;                          ││
│  │ };                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    ConcreteImplementor (Конкретный реализатор)  │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class WindowsRenderer : public Renderer {                 ││
│  │ public:                                                     ││
│  │     void drawCircle(double x, double y, double radius) override; ││
│  │     void drawRectangle(double x, double y,                 ││
│  │                          double width, double height) override; ││
│  │ };                                                          ││
│  │                                                             ││
│  │ class MacOSRenderer : public Renderer {                    ││
│  │ public:                                                     ││
│  │     void drawCircle(double x, double y, double radius) override; ││
│  │     void drawRectangle(double x, double y,                 ││
│  │                          double width, double height) override; ││
│  │ };                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 Последовательность взаимодействий

```
┌─────────────────────────────────────────────────────────────────┐
│                ПОСЛЕДОВАТЕЛЬНОСТЬ ВЗАИМОДЕЙСТВИЙ               │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   1. Клиент     │ auto renderer = std::make_unique<WindowsRenderer>(); │
│      создает     │ auto circle = std::make_unique<Circle>(10, 20, 5,  │
│      объекты     │     std::move(renderer));                    │
├─────────────────┼───────────────────────────────────────────────┤
│   2. Клиент     │ circle->draw();                               │
│      вызывает    │                                               │
│      метод      │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   3. Абстракция│ Circle::draw() вызывает                       │
│      делегирует  │ renderer_->drawCircle(x_, y_, radius_);       │
│      реализатору│                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   4. Реализатор │ WindowsRenderer::drawCircle() выполняет       │
│      выполняет   │ конкретное рисование                         │
│      работу     │                                               │
└─────────────────┴───────────────────────────────────────────────┘

Диаграмма взаимодействий:
┌─────────────────────────────────────────────────────────────────┐
│  Client ──┐                                                    │
│           │                                                    │
│           ▼                                                    │
│  Circle ──┐                                                    │
│            │                                                    │
│            ▼                                                    │
│  WindowsRenderer.drawCircle()                                   │
└─────────────────────────────────────────────────────────────────┘
```

## 🎨 Варианты реализации

### 1. Classic Bridge (Классический)
```
┌─────────────────────────────────────────────────────────────────┐
│                    CLASSIC BRIDGE                              │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ class Database {                                                │
│ protected:                                                      │
│     std::unique_ptr<Driver> driver_;                            │
│                                                                 │
│ public:                                                         │
│     Database(std::unique_ptr<Driver> driver)                    │
│         : driver_(std::move(driver)) {}                         │
│                                                                 │
│     virtual void connect() = 0;                                │
│     virtual void executeQuery(const std::string& query) = 0;    │
│     virtual ~Database() = default;                              │
│ };                                                              │
│                                                                 │
│ class MySQLDatabase : public Database {                        │
│ public:                                                         │
│     MySQLDatabase(std::unique_ptr<Driver> driver)                │
│         : Database(std::move(driver)) {}                        │
│                                                                 │
│     void connect() override {                                   │
│         driver_->connect("mysql://localhost:3306");             │
│     }                                                           │
│                                                                 │
│     void executeQuery(const std::string& query) override {     │
│         driver_->execute(query);                                │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ class Driver {                                                  │
│ public:                                                         │
│     virtual void connect(const std::string& connectionString) = 0; │
│     virtual void execute(const std::string& query) = 0;        │
│     virtual ~Driver() = default;                                │
│ };                                                              │
│                                                                 │
│ class MySQLDriver : public Driver {                            │
│ public:                                                         │
│     void connect(const std::string& connectionString) override { │
│         std::cout << "Connecting to MySQL: " << connectionString << std::endl; │
│     }                                                           │
│                                                                 │
│     void execute(const std::string& query) override {          │
│         std::cout << "Executing MySQL query: " << query << std::endl; │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘
```

### 2. Template Bridge
```
┌─────────────────────────────────────────────────────────────────┐
│                    TEMPLATE BRIDGE                             │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ template<typename Implementor>                                  │
│ class Shape {                                                   │
│ private:                                                        │
│     Implementor implementor_;                                   │
│                                                                 │
│ public:                                                         │
│     Shape(Implementor implementor) : implementor_(implementor) {} │
│                                                                 │
│     void draw() {                                               │
│         implementor_.draw();                                    │
│     }                                                           │
│                                                                 │
│     void resize(double factor) {                               │
│         implementor_.resize(factor);                            │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ class CircleRenderer {                                          │
│ public:                                                         │
│     void draw() {                                               │
│         std::cout << "Drawing circle" << std::endl;             │
│     }                                                           │
│                                                                 │
│     void resize(double factor) {                               │
│         std::cout << "Resizing circle by " << factor << std::endl; │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ class RectangleRenderer {                                       │
│ public:                                                         │
│     void draw() {                                               │
│         std::cout << "Drawing rectangle" << std::endl;           │
│     }                                                           │
│                                                                 │
│     void resize(double factor) {                               │
│         std::cout << "Resizing rectangle by " << factor << std::endl; │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ // Использование                                               │
│ Shape<CircleRenderer> circle(CircleRenderer{});                │
│ Shape<RectangleRenderer> rectangle(RectangleRenderer{});       │
│                                                                 │
│ circle.draw();                                                  │
│ rectangle.draw();                                               │
└─────────────────────────────────────────────────────────────────┘
```

### 3. Functional Bridge
```
┌─────────────────────────────────────────────────────────────────┐
│                    FUNCTIONAL BRIDGE                           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ class Shape {                                                   │
│ private:                                                        │
│     std::function<void()> drawFunc_;                           │
│     std::function<void(double)> resizeFunc_;                   │
│                                                                 │
│ public:                                                         │
│     Shape(std::function<void()> drawFunc,                       │
│           std::function<void(double)> resizeFunc)                │
│         : drawFunc_(drawFunc), resizeFunc_(resizeFunc) {}       │
│                                                                 │
│     void draw() {                                               │
│         drawFunc_();                                            │
│     }                                                           │
│                                                                 │
│     void resize(double factor) {                               │
│         resizeFunc_(factor);                                    │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ // Использование                                               │
│ auto circleDraw = []() {                                        │
│     std::cout << "Drawing circle" << std::endl;                 │
│ };                                                              │
│                                                                 │
│ auto circleResize = [](double factor) {                        │
│     std::cout << "Resizing circle by " << factor << std::endl;  │
│ };                                                              │
│                                                                 │
│ Shape circle(circleDraw, circleResize);                        │
│ circle.draw();                                                  │
│ circle.resize(2.0);                                            │
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 Сравнение подходов

```
┌─────────────────────────────────────────────────────────────────┐
│                    СРАВНЕНИЕ ПОДХОДОВ                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│   Classic       │   Template      │   Functional    │   Hybrid        │
│   Bridge        │   Bridge        │   Bridge        │   Bridge        │
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│ Простота        │ Средняя          │ Высокая         │ Низкая          │
│ Гибкость        │ Высокая          │ Средняя         │ Очень высокая   │
│ Производительность│ Высокая        │ Высокая         │ Средняя         │
│ Тестируемость   │ Высокая          │ Средняя         │ Высокая         │
│ Типобезопасность│ Средняя          │ Высокая         │ Низкая          │
│ Применимость    │ Стандартные      │ Шаблонные       │ Функциональные  │
│                 │ случаи          │ случаи          │ случаи          │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

## 🎯 Когда использовать Bridge

```
┌─────────────────────────────────────────────────────────────────┐
│                КОГДА ИСПОЛЬЗОВАТЬ BRIDGE                       │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Разделение      │ • Нужно разделить абстракцию и реализацию    │
│ ответственности │ • Избежать постоянного наследования          │
├─────────────────┼───────────────────────────────────────────────┤
│ Платформы       │ • Разные реализации для разных платформ      │
│                 │ • Кроссплатформенные приложения              │
├─────────────────┼───────────────────────────────────────────────┤
│ Драйверы        │ • Разделение высокоуровневого API и          │
│                 │   низкоуровневых драйверов                   │
├─────────────────┼───────────────────────────────────────────────┤
│ Расширяемость   │ • Система должна быть расширяемой            │
│                 │ • Независимое изменение абстракции и реализации│
├─────────────────┼───────────────────────────────────────────────┤
│ Тестирование    │ • Нужно легко создавать моки для тестов      │
│                 │ • Изоляция компонентов                        │
└─────────────────┴───────────────────────────────────────────────┘

❌ ПЛОХИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Простые случаи  │ • Когда можно использовать простое наследование│
├─────────────────┼───────────────────────────────────────────────┤
│ Производительность│ • Критична производительность               │
├─────────────────┼───────────────────────────────────────────────┤
│ Сложность       │ • Добавляется ненужная сложность             │
├─────────────────┼───────────────────────────────────────────────┤
│ Альтернативы    │ • Есть лучшие альтернативы (Strategy)        │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🧪 Тестирование Bridge

```
┌─────────────────────────────────────────────────────────────────┐
│                    ТЕСТИРОВАНИЕ BRIDGE                        │
└─────────────────────────────────────────────────────────────────┘

Преимущества для тестирования:
┌─────────────────┬───────────────────────────────────────────────┐
│ Моки            │ ✅ Легко создавать моки для реализаторов     │
│                 │ class MockRenderer : public Renderer {        │
│                 │     MOCK_METHOD(void, drawCircle, (double, double, double)); │
│                 │     MOCK_METHOD(void, drawRectangle, (double, double, double, double)); │
│                 │ };                                            │
├─────────────────┼───────────────────────────────────────────────┤
│ Изоляция        │ ✅ Легко изолировать тесты                   │
│                 │ auto mockRenderer = std::make_unique<MockRenderer>(); │
│                 │ Circle circle(10, 20, 5, std::move(mockRenderer)); │
├─────────────────┼───────────────────────────────────────────────┤
│ Управление      │ ✅ Полный контроль над реализаторами         │
│ зависимостями   │ EXPECT_CALL(*mockRenderer, drawCircle(10, 20, 5)) │
│                 │     .Times(1);                               │
└─────────────────┴───────────────────────────────────────────────┘

Пример теста:
┌─────────────────────────────────────────────────────────────────┐
│ TEST(CircleTest, DrawCircle) {                                  │
│     auto mockRenderer = std::make_unique<MockRenderer>();        │
│     Circle circle(10, 20, 5, std::move(mockRenderer));          │
│                                                                 │
│     EXPECT_CALL(*mockRenderer, drawCircle(10, 20, 5))           │
│         .Times(1);                                              │
│                                                                 │
│     circle.draw();                                             │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

## 🔗 Связь с другими паттернами

```
┌─────────────────────────────────────────────────────────────────┐
│              СВЯЗЬ С ДРУГИМИ ПАТТЕРНАМИ                        │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│ Adapter         │ • Bridge разделяет абстракцию и реализацию  │
│                 │ • Adapter адаптирует интерфейс               │
│                 │ • Bridge - разделение                       │
│                 │ • Adapter - совместимость                   │
├─────────────────┼───────────────────────────────────────────────┤
│ Strategy        │ • Bridge может использовать Strategy        │
│                 │ • Strategy для выбора реализации            │
│                 │ • Bridge - разделение                       │
│                 │ • Strategy - выбор алгоритма                │
├─────────────────┼───────────────────────────────────────────────┤
│ Abstract Factory│ • Bridge может использовать Abstract Factory│
│                 │ • Abstract Factory для создания реализаторов │
│                 │ • Bridge - разделение                       │
│                 │ • Abstract Factory - создание семейств      │
├─────────────────┼───────────────────────────────────────────────┤
│ Decorator       │ • Bridge разделяет абстракцию и реализацию  │
│                 │ • Decorator добавляет функциональность      │
│                 │ • Bridge - разделение                       │
│                 │ • Decorator - расширение                    │
├─────────────────┼───────────────────────────────────────────────┤
│ Facade          │ • Bridge может быть частью Facade          │
│                 │ • Facade упрощает работу с Bridge           │
│                 │ • Bridge - разделение                       │
│                 │ • Facade - упрощение интерфейса             │
└─────────────────┴───────────────────────────────────────────────┘
```

## 💡 Практические рекомендации

```
┌─────────────────────────────────────────────────────────────────┐
│                  ПРАКТИЧЕСКИЕ РЕКОМЕНДАЦИИ                     │
└─────────────────────────────────────────────────────────────────┘

1. 🎯 Выбор реализации:
   • Classic Bridge - для большинства случаев
   • Template Bridge - для типизированных случаев
   • Functional Bridge - для функционального стиля
   • Hybrid Bridge - для сложных систем

2. 🔧 Принципы проектирования:
   • Соблюдайте Single Responsibility Principle
   • Используйте композицию вместо наследования
   • Инкапсулируйте логику реализации
   • Обеспечьте независимость абстракции и реализации

3. 🧪 Тестирование:
   • Создавайте интерфейсы для реализаторов
   • Используйте моки в тестах
   • Тестируйте различные комбинации абстракций и реализаций
   • Проверяйте корректность делегирования

4. ⚡ Производительность:
   • Рассмотрите кэширование реализаторов
   • Используйте move semantics
   • Избегайте ненужных копирований
   • Профилируйте критические участки

5. 📚 Документация:
   • Документируйте разделение абстракции и реализации
   • Описывайте совместимость компонентов
   • Приводите примеры использования
   • Объясняйте причины выбора паттерна

6. 🔄 Рефакторинг:
   • Начинайте с простых bridge'ей
   • Постепенно добавляйте сложность
   • Используйте интерфейсы для абстракции
   • Планируйте расширяемость
```

## 🎓 Ключевые выводы

```
┌─────────────────────────────────────────────────────────────────┐
│                      КЛЮЧЕВЫЕ ВЫВОДЫ                          │
└─────────────────────────────────────────────────────────────────┘

✅ Bridge - мощный инструмент:
   • Разделяет абстракцию и реализацию
   • Избегает взрыва классов
   • Следует принципам SOLID
   • Обеспечивает независимость компонентов

✅ Выбирайте подходящую реализацию:
   • Classic Bridge - для большинства случаев
   • Template Bridge - для типизированных случаев
   • Functional Bridge - для функционального стиля
   • Hybrid Bridge - для сложных систем

✅ Используйте правильно:
   • Когда нужно разделить абстракцию и реализацию
   • Когда важно избежать постоянного наследования
   • Когда нужна расширяемость
   • Когда важна независимость компонентов

✅ Избегайте злоупотребления:
   • Не используйте для простых случаев
   • Не добавляйте сложность без необходимости
   • Не забывайте об обработке ошибок
   • Не нарушайте принципы SOLID

✅ Помните о компромиссах:
   • Разделение vs сложность
   • Гибкость vs производительность
   • Независимость vs связанность
   • Тестируемость vs производительность
```

---
*Bridge - это мост между абстракцией и реализацией. 
Используйте его для создания гибких и расширяемых систем!*
