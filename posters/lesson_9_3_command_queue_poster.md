# 📊 Плакат: Command Queue Pattern

## 🎯 Концепция Command Queue

```
┌─────────────────────────────────────────────────────────────────┐
│                   COMMAND QUEUE PATTERN                        │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  📋 ОЧЕРЕДЬ КОМАНД ДЛЯ АСИНХРОННОГО ВЫПОЛНЕНИЯ                │
│  🎯 БАТЧИНГ ДЛЯ ОПТИМИЗАЦИИ ПРОИЗВОДИТЕЛЬНОСТИ                │
│  🔄 РАЗДЕЛЕНИЕ ПРОИЗВОДИТЕЛЕЙ И ПОТРЕБИТЕЛЕЙ                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   ПРОБЛЕМА      │  • Команды выполняются синхронно              │
│                 │  • Производитель блокируется на выполнении    │
│                 │  • Нет оптимизации групповых операций         │
│                 │  • Сложно управлять нагрузкой                 │
├─────────────────┼───────────────────────────────────────────────┤
│   РЕШЕНИЕ       │  • Очередь команд (Producer-Consumer)         │
│                 │  • Асинхронное выполнение                     │
│                 │  • Батчинг похожих команд                     │
│                 │  • Сглаживание пиковых нагрузок               │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🏗️ Архитектура Command Queue

```
┌─────────────────────────────────────────────────────────────────┐
│                 COMMAND QUEUE ARCHITECTURE                     │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                        PRODUCERS                                │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐      │
│  │Thread 1  │  │Thread 2  │  │Thread 3  │  │Thread 4  │      │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘      │
│       │             │             │             │              │
│       └─────────────┴─────────────┴─────────────┘              │
│                          ↓                                      │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              COMMAND QUEUE                                │  │
│  │  ┌────┐ ┌────┐ ┌────┐ ┌────┐ ┌────┐                     │  │
│  │  │Cmd1│→│Cmd2│→│Cmd3│→│Cmd4│→│Cmd5│→ ...                │  │
│  │  └────┘ └────┘ └────┘ └────┘ └────┘                     │  │
│  │                                                           │  │
│  │  Capacity: 100 commands                                   │  │
│  │  Size: 5 commands                                         │  │
│  └──────────────────────────────────────────────────────────┘  │
│                          ↓                                      │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              BATCH PROCESSOR                              │  │
│  │  • Группировка команд по типу                             │  │
│  │  • Flush на таймауте или размере                          │  │
│  │  • Приоритизация                                          │  │
│  └──────────────────────────────────────────────────────────┘  │
│                          ↓                                      │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                CONSUMERS / WORKERS                        │  │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐               │  │
│  │  │Worker 1  │  │Worker 2  │  │Worker 3  │               │  │
│  │  └──────────┘  └──────────┘  └──────────┘               │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 Жизненный цикл команды

```
┌─────────────────────────────────────────────────────────────────┐
│              ЖИЗНЕННЫЙ ЦИКЛ КОМАНДЫ В QUEUE                    │
└─────────────────────────────────────────────────────────────────┘

1. CREATE         2. ENQUEUE         3. BATCH          4. EXECUTE
┌──────────┐     ┌──────────┐      ┌──────────┐      ┌──────────┐
│ Producer │     │ Команда  │      │ Батч из  │      │ Worker   │
│ создает  │ ──> │ добав-   │ ──>  │ похожих  │ ──>  │ выполняет│
│ команду  │     │ лена в   │      │ команд   │      │ батч     │
│          │     │ очередь  │      │ собран   │      │          │
└──────────┘     └──────────┘      └──────────┘      └──────────┘
                                                           ↓
                                                     5. COMPLETE
                                                    ┌──────────┐
                                                    │ Результат│
                                                    │ (опц.)   │
                                                    └──────────┘

TIMING:
• Создание: instant
• Ожидание в очереди: 0-100ms (зависит от нагрузки)
• Батчинг: каждые 10-50ms или при достижении размера
• Выполнение: зависит от команды
```

## ⚡ Батчинг команд

```
┌─────────────────────────────────────────────────────────────────┐
│                   BATCHING STRATEGY                            │
└─────────────────────────────────────────────────────────────────┘

БЕЗ БАТЧИНГА (Выполнение каждой команды отдельно):
┌─────────────────────────────────────────────────────────────────┐
│  Команда 1: DB Write (overhead 5ms + work 1ms) = 6ms           │
│  Команда 2: DB Write (overhead 5ms + work 1ms) = 6ms           │
│  Команда 3: DB Write (overhead 5ms + work 1ms) = 6ms           │
│  Команда 4: DB Write (overhead 5ms + work 1ms) = 6ms           │
│  Команда 5: DB Write (overhead 5ms + work 1ms) = 6ms           │
│  ─────────────────────────────────────────────────────────────  │
│  Итого: 5 × 6ms = 30ms                                          │
│                                                                 │
│  ⚠️ ПРОБЛЕМЫ:                                                  │
│  • Высокий overhead на каждую команду                          │
│  • Множество отдельных операций                                │
│  • Плохая утилизация ресурсов                                  │
└─────────────────────────────────────────────────────────────────┘

С БАТЧИНГОМ (Группировка команд):
┌─────────────────────────────────────────────────────────────────┐
│  Batch [Cmd1, Cmd2, Cmd3, Cmd4, Cmd5]:                         │
│    overhead 5ms + work 5 × 1ms = 10ms                           │
│  ─────────────────────────────────────────────────────────────  │
│  Итого: 10ms                                                     │
│                                                                 │
│  ✅ ПРЕИМУЩЕСТВА:                                              │
│  • 3x ускорение! (30ms → 10ms)                                 │
│  • Один overhead на весь батч                                   │
│  • Оптимизация групповых операций                              │
│  • Лучшая утилизация ресурсов                                  │
└─────────────────────────────────────────────────────────────────┘

ПРИМЕР: DATABASE BATCH INSERT
┌─────────────────────────────────────────────────────────────────┐
│ БЕЗ батчинга:                                                   │
│   INSERT INTO users VALUES (1, 'Alice');                        │
│   INSERT INTO users VALUES (2, 'Bob');                          │
│   INSERT INTO users VALUES (3, 'Charlie');                      │
│   // 3 отдельных запроса                                       │
│                                                                 │
│ С батчингом:                                                    │
│   INSERT INTO users VALUES                                      │
│     (1, 'Alice'),                                               │
│     (2, 'Bob'),                                                 │
│     (3, 'Charlie');                                             │
│   // 1 запрос                                                   │
└─────────────────────────────────────────────────────────────────┘
```

## 🎯 Flush стратегии

```
┌─────────────────────────────────────────────────────────────────┐
│                   FLUSH TRIGGERS                               │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  1. SIZE-BASED FLUSH                                            │
│     ┌───────────────────────────────────────────────┐          │
│     │  if (batch.size() >= MAX_BATCH_SIZE) {        │          │
│     │      flush();                                  │          │
│     │  }                                             │          │
│     └───────────────────────────────────────────────┘          │
│                                                                 │
│     • Батч достиг максимального размера                        │
│     • Оптимально для high-throughput систем                    │
│     • Пример: MAX_BATCH_SIZE = 100                             │
├─────────────────────────────────────────────────────────────────┤
│  2. TIME-BASED FLUSH                                            │
│     ┌───────────────────────────────────────────────┐          │
│     │  if (time_since_last_flush > FLUSH_INTERVAL) {│          │
│     │      flush();                                  │          │
│     │  }                                             │          │
│     └───────────────────────────────────────────────┘          │
│                                                                 │
│     • Периодический flush по таймеру                           │
│     • Гарантирует низкую latency                               │
│     • Пример: FLUSH_INTERVAL = 50ms                            │
├─────────────────────────────────────────────────────────────────┤
│  3. HYBRID FLUSH                                                │
│     ┌───────────────────────────────────────────────┐          │
│     │  if (batch.size() >= MAX_SIZE ||               │          │
│     │      time_since_last_flush > INTERVAL) {       │          │
│     │      flush();                                  │          │
│     │  }                                             │          │
│     └───────────────────────────────────────────────┘          │
│                                                                 │
│     • Комбинация size и time                                   │
│     • Баланс throughput и latency                              │
│     • BEST PRACTICE для большинства случаев                    │
├─────────────────────────────────────────────────────────────────┤
│  4. PRIORITY FLUSH                                              │
│     ┌───────────────────────────────────────────────┐          │
│     │  if (has_high_priority_command()) {            │          │
│     │      flush();                                  │          │
│     │  }                                             │          │
│     └───────────────────────────────────────────────┘          │
│                                                                 │
│     • Немедленный flush для критичных команд                   │
│     • Обход ожидания батчинга                                  │
│     • Для real-time операций                                   │
└─────────────────────────────────────────────────────────────────┘
```

## 💡 Сравнение подходов

```
┌─────────────────────────────────────────────────────────────────┐
│       БЕЗ COMMAND QUEUE vs С COMMAND QUEUE + BATCHING          │
└─────────────────────────────────────────────────────────────────┘

❌ БЕЗ COMMAND QUEUE (Синхронное выполнение):
┌─────────────────────────────────────────────────────────────────┐
│ // Игровой движок: рендеринг спрайтов                          │
│ for (auto& sprite : sprites) {                                  │
│     // Каждый спрайт - отдельный draw call                     │
│     renderer.drawSprite(sprite);  // 0.5ms overhead            │
│ }                                                               │
│                                                                 │
│ // 1000 спрайтов × 0.5ms = 500ms                               │
│ // При 60 FPS: 16.6ms бюджет → 500ms = 💥 LAG!                │
│                                                                 │
│ ⚠️ ПРОБЛЕМЫ:                                                   │
│  • Блокирование game loop                                      │
│  • Огромный overhead на каждый draw call                       │
│  • Невозможно достичь 60 FPS                                   │
│  • CPU-GPU synchronization overhead                            │
└─────────────────────────────────────────────────────────────────┘

✅ С COMMAND QUEUE + BATCHING:
┌─────────────────────────────────────────────────────────────────┐
│ // Игровой движок с Command Queue                              │
│ for (auto& sprite : sprites) {                                  │
│     // Добавляем в очередь (instant)                           │
│     commandQueue.submit(RenderSpriteCommand(sprite));           │
│ }                                                               │
│                                                                 │
│ // Worker thread батчует и выполняет:                          │
│ // Batch 1: 500 спрайтов с texture "player.png"                │
│ //   overhead 0.5ms + 500 × 0.001ms = 1ms                      │
│ // Batch 2: 500 спрайтов с texture "enemy.png"                 │
│ //   overhead 0.5ms + 500 × 0.001ms = 1ms                      │
│ // Итого: 2ms вместо 500ms!                                    │
│                                                                 │
│ ✅ ПРЕИМУЩЕСТВА:                                               │
│  • 250x ускорение!                                             │
│  • Game loop не блокируется                                    │
│  • Стабильные 60 FPS                                           │
│  • Оптимальная утилизация GPU                                  │
└─────────────────────────────────────────────────────────────────┘
```

## 🔧 Реализация Command Queue с батчингом

```
┌─────────────────────────────────────────────────────────────────┐
│          COMMAND QUEUE WITH BATCHING IMPLEMENTATION            │
└─────────────────────────────────────────────────────────────────┘

class BatchProcessor {
private:
    std::queue<std::shared_ptr<Command>> queue_;
    std::mutex mutex_;
    std::condition_variable cv_;
    
    size_t max_batch_size_;
    std::chrono::milliseconds flush_interval_;
    std::chrono::system_clock::time_point last_flush_;
    
    std::atomic<bool> running_{true};
    std::thread processor_thread_;
    
public:
    BatchProcessor(size_t max_batch = 100,
                  std::chrono::milliseconds interval = std::chrono::milliseconds(50))
        : max_batch_size_(max_batch), 
          flush_interval_(interval),
          last_flush_(std::chrono::system_clock::now()) {
        
        processor_thread_ = std::thread([this]() {
            processingLoop();
        });
    }
    
    void submit(std::shared_ptr<Command> cmd) {
        {
            std::lock_guard<std::mutex> lock(mutex_);
            queue_.push(std::move(cmd));
        }
        cv_.notify_one();
    }
    
private:
    void processingLoop() {
        while (running_) {
            std::unique_lock<std::mutex> lock(mutex_);
            
            // Ждем с таймаутом
            cv_.wait_for(lock, flush_interval_, [this] {
                return !queue_.empty() || !running_;
            });
            
            auto now = std::chrono::system_clock::now();
            auto elapsed = now - last_flush_;
            
            // Проверяем условия flush
            bool should_flush = 
                queue_.size() >= max_batch_size_ ||
                elapsed >= flush_interval_;
            
            if (should_flush && !queue_.empty()) {
                // Собираем батчи по типу команд
                auto batches = groupByBatchKey();
                
                lock.unlock();
                
                // Выполняем батчи
                for (auto& batch : batches) {
                    executeBatch(batch);
                }
                
                last_flush_ = now;
            }
        }
    }
    
    std::unordered_map<std::string, std::vector<std::shared_ptr<Command>>>
    groupByBatchKey() {
        std::unordered_map<std::string, 
                          std::vector<std::shared_ptr<Command>>> batches;
        
        while (!queue_.empty()) {
            auto cmd = queue_.front();
            queue_.pop();
            
            std::string key = cmd->getBatchKey();
            batches[key].push_back(cmd);
        }
        
        return batches;
    }
    
    void executeBatch(const std::vector<std::shared_ptr<Command>>& batch) {
        std::cout << "[BATCH] Выполнение " << batch.size() 
                  << " команд" << std::endl;
        
        for (auto& cmd : batch) {
            cmd->execute();
        }
    }
};

ИСПОЛЬЗОВАНИЕ:
┌─────────────────────────────────────────────────────────────────┐
│ BatchProcessor processor(100, std::chrono::milliseconds(50));   │
│                                                                 │
│ // Добавляем команды                                            │
│ for (int i = 0; i < 1000; ++i) {                               │
│     processor.submit(                                           │
│         std::make_shared<DatabaseWriteCommand>("users", i)      │
│     );                                                          │
│ }                                                               │
│                                                                 │
│ // Команды батчуются и выполняются асинхронно                  │
└─────────────────────────────────────────────────────────────────┘
```

## 🎮 Применение в игровом движке

```
┌─────────────────────────────────────────────────────────────────┐
│              GAME ENGINE COMMAND QUEUE                         │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  FRAME STRUCTURE:                                               │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  GAME LOOP (Main Thread)                     16.6ms      │  │
│  │  ┌────────────────────────────────────────────────────┐  │  │
│  │  │  1. Input           (1ms)                          │  │  │
│  │  │  2. Update Logic    (5ms)                          │  │  │
│  │  │  3. Physics         (3ms)                          │  │  │
│  │  │  4. Submit Render Commands (instant!)              │  │  │
│  │  │     • 1000 sprites → queue                         │  │  │
│  │  │     • Lights → queue                               │  │  │
│  │  │     • Effects → queue                              │  │  │
│  │  │  5. Audio           (1ms)                          │  │  │
│  │  └────────────────────────────────────────────────────┘  │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  RENDER THREAD                                           │  │
│  │  ┌────────────────────────────────────────────────────┐  │  │
│  │  │  Process Command Queue:                            │  │  │
│  │  │                                                     │  │  │
│  │  │  Batch 1: Draw 500 sprites (texture: player.png)   │  │  │
│  │  │  Batch 2: Draw 500 sprites (texture: enemy.png)    │  │  │
│  │  │  Batch 3: Draw 50 lights                           │  │  │
│  │  │  Batch 4: Draw 100 particles (effect: fire)        │  │  │
│  │  │                                                     │  │  │
│  │  │  Total: 2ms (vs 500ms без батчинга!)              │  │  │
│  │  └────────────────────────────────────────────────────┘  │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  RESULT: Smooth 60 FPS! ✅                                     │
└─────────────────────────────────────────────────────────────────┘
```

## ⚠️ Проблемы и решения

```
┌─────────────────────────────────────────────────────────────────┐
│                  ТИПИЧНЫЕ ПРОБЛЕМЫ И РЕШЕНИЯ                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   LATENCY       │  РЕШЕНИЕ:                                     │
│   INCREASE      │  • Меньший flush interval (trade-off)         │
│                 │  • Priority queue для критичных команд        │
│   Батчинг       │  • Hybrid flush strategy                      │
│   добавляет     │  • Мониторинг p99 latency                     │
│   задержку      │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   QUEUE         │  РЕШЕНИЕ:                                     │
│   OVERFLOW      │  • Bounded queue с backpressure               │
│                 │  • Rate limiting на producer side             │
│   Команды       │  • Rejection policy (drop oldest/newest)      │
│   добавляются   │  • Monitoring queue depth                     │
│   быстрее чем   │                                               │
│   выполняются   │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   ORDERING      │  РЕШЕНИЕ:                                     │
│   ISSUES        │  • Sequence numbers                           │
│                 │  • Dependency tracking                        │
│   Команды       │  • Separate queues по типу                    │
│   выполняются   │  • Transaction boundaries                     │
│   в неправильном│                                               │
│   порядке       │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   BATCH TOO     │  РЕШЕНИЕ:                                     │
│   SMALL         │  • Dynamic batch sizing                       │
│                 │  • Adaptive flush intervals                   │
│   Мало команд   │  • Monitoring batch sizes                     │
│   в батче →     │  • Tuning based on metrics                    │
│   overhead не   │                                               │
│   окупается     │                                               │
└─────────────────┴───────────────────────────────────────────────┘
```

## 📊 Метрики и мониторинг

```
┌─────────────────────────────────────────────────────────────────┐
│                   КЛЮЧЕВЫЕ МЕТРИКИ                             │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  📈 ПРОИЗВОДИТЕЛЬНОСТЬ                                          │
│  • Commands/sec: команд в секунду                               │
│  • Batches/sec: батчей в секунду                                │
│  • Avg batch size: средний размер батча                         │
│  • Batching efficiency: commands/sec / batches/sec              │
│  • Queue depth: текущий размер очереди                          │
├─────────────────────────────────────────────────────────────────┤
│  ⏱️ LATENCY                                                     │
│  • Queue wait time p50/p95/p99: время в очереди                │
│  • Batch execution time: время выполнения батча                 │
│  • End-to-end latency: от submit до complete                   │
│  • Flush frequency: частота flush                               │
├─────────────────────────────────────────────────────────────────┤
│  ⚠️ ПРОБЛЕМЫ                                                    │
│  • Queue overflow count: переполнения очереди                   │
│  • Rejected commands: отклоненные команды                       │
│  • Failed batches: неудачные батчи                              │
│  • Flush timeouts: таймауты flush                               │
└─────────────────────────────────────────────────────────────────┘

ALERTS:
⚠️  Queue depth > 80% capacity
⚠️  Average batch size < 10 (inefficient batching)
⚠️  p99 latency > 100ms
⚠️  Rejection rate > 1%
```

## 🎓 Best Practices

```
┌─────────────────────────────────────────────────────────────────┐
│                      ЛУЧШИЕ ПРАКТИКИ                           │
└─────────────────────────────────────────────────────────────────┘

✅ DO (Рекомендуется):
┌─────────────────────────────────────────────────────────────────┐
│ 1. Используйте hybrid flush strategy                           │
│    • Size-based И time-based                                    │
│    • Баланс throughput и latency                                │
│                                                                 │
│ 2. Группируйте команды по типу для батчинга                    │
│    • DB writes по таблицам                                      │
│    • Render commands по текстурам                               │
│                                                                 │
│ 3. Мониторьте метрики в реальном времени                       │
│    • Queue depth, batch size, latency                           │
│    • Tune параметры на основе метрик                            │
│                                                                 │
│ 4. Используйте bounded queue                                    │
│    • Предотвращает OOM                                          │
│    • Backpressure на producers                                  │
│                                                                 │
│ 5. Делайте команды идемпотентными                              │
│    • Можно безопасно повторить                                  │
│    • Упрощает error handling                                    │
└─────────────────────────────────────────────────────────────────┘

❌ DON'T (Не рекомендуется):
┌─────────────────────────────────────────────────────────────────┐
│ 1. НЕ делайте слишком большой flush interval                   │
│    ❌ 1 second → слишком высокая latency                       │
│                                                                 │
│ 2. НЕ используйте unbounded queue                              │
│    ❌ Может привести к OOM                                     │
│                                                                 │
│ 3. НЕ батчуйте несовместимые команды                           │
│    ❌ Разные типы операций в одном батче                       │
│                                                                 │
│ 4. НЕ игнорируйте ordering requirements                        │
│    ❌ Критичные зависимости между командами                    │
│                                                                 │
│ 5. НЕ забывайте про error handling                             │
│    ❌ Один failed command не должен ломать весь батч           │
└─────────────────────────────────────────────────────────────────┘
```

## 🚀 Когда использовать Command Queue

```
┌─────────────────────────────────────────────────────────────────┐
│                    КОГДА ИСПОЛЬЗОВАТЬ                          │
└─────────────────────────────────────────────────────────────────┘

✅ ПОДХОДИТ ДЛЯ:
  • Игровые движки (render commands)
  • Batch processing (DB writes, API calls)
  • Event-driven systems
  • High-throughput системы
  • Асинхронная обработка
  • Операции с high overhead (network, I/O)
  • Сглаживание пиковых нагрузок

❌ НЕ ПОДХОДИТ ДЛЯ:
  • Real-time системы с strict latency requirements
  • Операции требующие немедленного ответа
  • Простые синхронные операции
  • Операции с сильными ordering constraints
  • Low-overhead операции (батчинг не окупается)
```

## 📚 Связанные паттерны

```
┌─────────────────────────────────────────────────────────────────┐
│                   СВЯЗАННЫЕ ПАТТЕРНЫ                           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│  Command        │  • Инкапсуляция операций                      │
│                 │  • Command Queue использует Command pattern   │
│                 │  • Undo/Redo через queue                      │
├─────────────────┼───────────────────────────────────────────────┤
│  Producer-      │  • Producers добавляют в queue                │
│  Consumer       │  • Consumers обрабатывают из queue            │
│                 │  • Command Queue - специализация P-C          │
├─────────────────┼───────────────────────────────────────────────┤
│  Thread Pool    │  • Workers выполняют команды                  │
│                 │  • Параллельная обработка батчей              │
│                 │  • Комбинируется с Command Queue              │
├─────────────────┼───────────────────────────────────────────────┤
│  Event Sourcing │  • Commands как events                        │
│                 │  • Replay commands                            │
│                 │  • Audit trail через queue                    │
└─────────────────┴───────────────────────────────────────────────┘
```

## 💼 Реальные примеры

```
┌─────────────────────────────────────────────────────────────────┐
│                  ПРИМЕРЫ ИЗ РЕАЛЬНОГО МИРА                     │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  GAME ENGINE (Unity, Unreal)                                    │
│  • Render commands queue                                        │
│  • Batching по материалам/текстурам                            │
│  • ~1000 draw calls → 10-50 батчей                             │
│  • 100x ускорение рендеринга                                   │
├─────────────────────────────────────────────────────────────────┤
│  DATABASE (Batch Inserts)                                       │
│  • Очередь INSERT команд                                        │
│  • Батчинг в один multi-row INSERT                             │
│  • Flush каждые 100 records или 50ms                            │
│  • 10-50x ускорение записи                                     │
├─────────────────────────────────────────────────────────────────┤
│  MESSAGE QUEUE (Kafka, RabbitMQ)                                │
│  • Producer buffer для messages                                 │
│  • Батчинг перед отправкой                                     │
│  • Compression на батч уровне                                   │
│  • Увеличение throughput в разы                                │
├─────────────────────────────────────────────────────────────────┤
│  LOGGING SYSTEM                                                 │
│  • Асинхронная очередь log events                              │
│  • Батчинг перед записью в файл/БД                             │
│  • Flush каждые 500 events или 1s                               │
│  • Не блокирует application thread                             │
└─────────────────────────────────────────────────────────────────┘
```

---

**Автор**: Senior C++ Developer  
**Дата**: 2025-10-07  
**Версия**: 1.0
