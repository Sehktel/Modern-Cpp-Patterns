# 🎭 Плакат: Actor Model Pattern

## 📋 Обзор паттерна

```
┌─────────────────────────────────────────────────────────────────┐
│                      ACTOR MODEL PATTERN                      │
└─────────────────────────────────────────────────────────────────┘

🎯 ЦЕЛЬ: Изоляция состояния и асинхронное общение через сообщения
🔧 КОМПОНЕНТЫ: Actor + Message + Mailbox + Actor System
📈 ПРИМЕНЕНИЕ: Распределенные системы, игровые движки, микросервисы
```

## 🏗️ Архитектура Actor Model

```
┌─────────────────────────────────────────────────────────────────┐
│                    АРХИТЕКТУРА ACTOR MODEL                    │
└─────────────────────────────────────────────────────────────────┘

    ┌─────────────┐              ┌─────────────┐              ┌─────────────┐
    │   Actor A   │              │   Actor B   │              │   Actor C   │
    │             │              │             │              │             │
    │ ┌─────────┐ │              │ ┌─────────┐ │              │ ┌─────────┐ │
    │ │ State   │ │              │ │ State   │ │              │ │ State   │ │
    │ └─────────┘ │              │ └─────────┘ │              │ └─────────┘ │
    │             │              │             │              │             │
    │ ┌─────────┐ │              │ ┌─────────┐ │              │ ┌─────────┐ │
    │ │Mailbox  │ │              │ │Mailbox  │ │              │ │Mailbox  │ │
    │ │         │ │              │ │         │ │              │ │         │ │
    │ │[msg1]   │ │              │ │[msg2]   │ │              │ │[msg3]   │ │
    │ │[msg2]   │ │              │ │[msg4]   │ │              │ │[msg5]   │ │
    │ │[msg3]   │ │              │ │         │ │              │ │         │ │
    │ └─────────┘ │              │ └─────────┘ │              │ └─────────┘ │
    └─────────────┘              └─────────────┘              └─────────────┘
           │                             │                             │
           │         ┌─────────────┐     │                             │
           └─────────│  Message    │─────┼─────────────────────────────┘
                     │  Passing    │     │
                     └─────────────┘     │
                                         │
                     ┌─────────────┐     │
                     │ Actor System│─────┘
                     │  Manager    │
                     └─────────────┘

ПРИНЦИПЫ:
┌─────────────────────────────────────────────────────────────────┐
│  • Изоляция состояния - каждый Actor имеет свое состояние      │
│  • Асинхронные сообщения - общение только через сообщения      │
│  • Локальность - один поток на Actor, одно сообщение за раз    │
│  • Без совместного состояния - нет разделяемых переменных      │
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 Жизненный цикл Actor

```
┌─────────────────────────────────────────────────────────────────┐
│                    ЖИЗНЕННЫЙ ЦИКЛ ACTOR                       │
└─────────────────────────────────────────────────────────────────┘

1. СОЗДАНИЕ:
   ┌─────────────┐
   │ Actor       │
   │ Constructor │
   └─────────────┘
           │
           ▼

2. ЗАПУСК:
   ┌─────────────┐    ┌─────────────┐
   │ start()     │───▶│ Worker      │
   │             │    │ Thread      │
   └─────────────┘    └─────────────┘
           │                   │
           ▼                   ▼
   ┌─────────────┐    ┌─────────────┐
   │ Message     │    │ Message     │
   │ Loop        │◀───│ Processing  │
   └─────────────┘    └─────────────┘

3. РАБОТА:
   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
   │ Receive     │───▶│ Process     │───▶│ Send        │
   │ Message     │    │ Message     │    │ Response    │
   └─────────────┘    └─────────────┘    └─────────────┘
           │                   │                   │
           ▼                   ▼                   ▼
   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
   │ Update      │    │ Execute     │    │ Notify      │
   │ State       │    │ Logic       │    │ Other       │
   └─────────────┘    └─────────────┘    └─────────────┘

4. ОСТАНОВКА:
   ┌─────────────┐
   │ stop()      │
   └─────────────┘
           │
           ▼
   ┌─────────────┐
   │ Cleanup     │
   │ Resources   │
   └─────────────┘
```

## 🛠️ Реализации

```
┌─────────────────────────────────────────────────────────────────┐
│                    ВАРИАНТЫ РЕАЛИЗАЦИИ                         │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│   Базовая       │   С обработкой  │   С мониторингом│   Распределенная│
│   реализация    │   ошибок        │   и статистикой │   реализация    │
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│ ✅ Простота     │ ✅ Надежность   │ ✅ Мониторинг   │ ✅ Масштабируем.│
│ ✅ Быстрый      │ ✅ Обработка    │ ✅ Статистика   │ ✅ Распределение│
│    старт        │    исключений   │ ✅ Отладка      │ ✅ Отказоуст.   │
│ ❌ Нет обработки│ ✅ Логирование  │ ✅ Профилир.    │ ❌ Сложность    │
│    ошибок       │ ❌ Производит.  │ ❌ Накладные    │ ❌ Сетевая      │
│ ❌ Нет мониторинга│   расходы     │    расходы      │    задержка     │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

## 📊 Сравнение с другими паттернами

```
┌─────────────────────────────────────────────────────────────────┐
│                    СРАВНЕНИЕ ПАТТЕРНОВ                         │
└─────────────────────────────────────────────────────────────────┘

Actor Model vs Thread Pool:
┌─────────────────┬───────────────────────────────────────────────┐
│ Actor Model     │ • Изоляция состояния                         │
│                 │ • Асинхронные сообщения                      │
│                 │ • Простота отладки                           │
│ Thread Pool     │ • Общие ресурсы                             │
│                 │ • Синхронные задачи                          │
│                 │ • Сложность синхронизации                    │
└─────────────────┴───────────────────────────────────────────────┘

Actor Model vs Observer:
┌─────────────────┬───────────────────────────────────────────────┐
│ Actor Model     │ • Асинхронное общение                        │
│                 │ • Изолированное состояние                     │
│                 │ • Масштабируемость                           │
│ Observer        │ • Синхронные уведомления                     │
│                 │ • Связанное состояние                        │
│                 │ • Ограниченная масштабируемость              │
└─────────────────┴───────────────────────────────────────────────┘

Actor Model vs Producer-Consumer:
┌─────────────────┬───────────────────────────────────────────────┐
│ Actor Model     │ • Изолированные актеры                       │
│                 │ • Типизированные сообщения                    │
│                 │ • Сложная логика                             │
│ Producer-Consumer│ • Общий буфер                               │
│                 │ • Простые данные                             │
│                 │ • Простая логика                             │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🎯 Применения

```
┌─────────────────────────────────────────────────────────────────┐
│                    ОБЛАСТИ ПРИМЕНЕНИЯ                         │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Игровые движки  │ • Управление игровыми объектами              │
│                 │ • Физика и анимация                          │
│                 │ • Сетевая игра                               │
├─────────────────┼───────────────────────────────────────────────┤
│ Микросервисы    │ • Независимые сервисы                        │
│                 │ • Обработка запросов                         │
│                 │ • Управление состоянием                      │
├─────────────────┼───────────────────────────────────────────────┤
│ Распределенные  │ • Отказоустойчивость                         │
│ системы         │ • Масштабируемость                           │
│                 │ • Изоляция отказов                           │
├─────────────────┼───────────────────────────────────────────────┤
│ Системы         │ • Обработка событий                          │
│ реального       │ • Контроль времени                           │
│ времени         │ • Предсказуемость                            │
└─────────────────┴───────────────────────────────────────────────┘

❌ ПЛОХИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Синхронные      │ • Когда нужна немедленная обработка           │
│ операции        │ • Критичные по времени задачи                │
├─────────────────┼───────────────────────────────────────────────┤
│ Простые задачи  │ • Когда overhead превышает пользу            │
│                 │ • Одиночные операции                         │
├─────────────────┼───────────────────────────────────────────────┤
│ Ограниченные    │ • Когда нет дополнительных потоков           │
│ ресурсы         │ • Ограниченная память                        │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🔧 Реализация в C++

```
┌─────────────────────────────────────────────────────────────────┐
│                    КЛЮЧЕВЫЕ КОМПОНЕНТЫ                         │
└─────────────────────────────────────────────────────────────────┘

1. БАЗОВЫЙ ACTOR:
```cpp
class BaseActor {
private:
    std::string name_;
    std::queue<Message> mailbox_;
    std::mutex mailboxMutex_;
    std::condition_variable condition_;
    std::thread workerThread_;
    std::atomic<bool> running_{false};
    
public:
    void start() {
        running_.store(true);
        workerThread_ = std::thread(&BaseActor::messageLoop, this);
    }
    
    void send(const Message& message) {
        {
            std::lock_guard<std::mutex> lock(mailboxMutex_);
            mailbox_.push(message);
        }
        condition_.notify_one();
    }
    
    virtual void receive(const Message& message) = 0;
    
private:
    void messageLoop() {
        while (running_.load()) {
            Message message;
            {
                std::unique_lock<std::mutex> lock(mailboxMutex_);
                condition_.wait(lock, [this] { return !mailbox_.empty() || !running_.load(); });
                
                if (!mailbox_.empty()) {
                    message = std::move(mailbox_.front());
                    mailbox_.pop();
                }
            }
            
            if (!message.empty()) {
                receive(message);
            }
        }
    }
};
```

2. СООБЩЕНИЯ:
```cpp
struct Message {
    std::string type;
    std::any data;
    std::string sender;
    std::chrono::system_clock::time_point timestamp;
    
    Message(const std::string& msgType, const std::any& msgData, const std::string& msgSender = "")
        : type(msgType), data(msgData), sender(msgSender), 
          timestamp(std::chrono::system_clock::now()) {}
};
```

3. СИСТЕМА УПРАВЛЕНИЯ:
```cpp
class ActorSystem {
private:
    std::unordered_map<std::string, std::unique_ptr<Actor>> actors_;
    std::mutex actorsMutex_;
    
public:
    template<typename ActorType, typename... Args>
    ActorType& createActor(const std::string& name, Args&&... args) {
        std::lock_guard<std::mutex> lock(actorsMutex_);
        
        auto actor = std::make_unique<ActorType>(std::forward<Args>(args)...);
        ActorType& actorRef = *actor;
        
        actors_[name] = std::move(actor);
        actorRef.start();
        
        return actorRef;
    }
    
    void sendMessage(const std::string& actorName, const Message& message) {
        Actor* actor = getActor(actorName);
        if (actor) {
            actor->send(message);
        }
    }
};
```
```

## 📈 Статистика и мониторинг

```
┌─────────────────────────────────────────────────────────────────┐
│                    МОНИТОРИНГ ACTOR MODEL                     │
└─────────────────────────────────────────────────────────────────┘

КЛЮЧЕВЫЕ МЕТРИКИ:
┌─────────────────────────────────────────────────────────────────┐
│  • Количество актеров                                          │
│  • Размер очереди сообщений                                    │
│  • Количество обработанных сообщений                           │
│  • Время обработки сообщений                                   │
│  • Количество ошибок                                           │
│  • Использование памяти                                        │
└─────────────────────────────────────────────────────────────────┘

СТАТИСТИКА В РЕАЛЬНОМ ВРЕМЕНИ:
┌─────────────────────────────────────────────────────────────────┐
│  [Actor System Stats]                                          │
│  Total Actors: 15                                              │
│  Active Actors: 12                                             │
│  Messages in Queue: 45                                         │
│  Messages Processed: 1,234                                     │
│  Average Processing Time: 2.3ms                               │
│  Error Rate: 0.1%                                             │
│  Memory Usage: 45MB                                           │
└─────────────────────────────────────────────────────────────────┘
```

## 🧪 Тестирование

```
┌─────────────────────────────────────────────────────────────────┐
│                    ТЕСТИРОВАНИЕ ACTOR MODEL                   │
└─────────────────────────────────────────────────────────────────┘

1. UNIT ТЕСТЫ:
```cpp
TEST(ActorModelTest, BasicMessagePassing) {
    ActorSystem system;
    CalculatorActor& calculator = system.createActor<CalculatorActor>("Calculator");
    
    calculator.send(Message("ADD", 5.0));
    
    // Проверяем результат
    EXPECT_EQ(calculator.getResult(), 5.0);
}
```

2. INTEGRATION ТЕСТЫ:
```cpp
void testActorInteraction() {
    ActorSystem system;
    
    CalculatorActor& calc = system.createActor<CalculatorActor>("Calculator");
    UserManagerActor& userMgr = system.createActor<UserManagerActor>("UserManager");
    
    // Тестируем взаимодействие между актерами
    calc.sendTo(userMgr, "CREATE_USER", std::make_tuple("user1", "Alice", "alice@example.com"));
    
    // Ждем обработки
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    // Проверяем результат
    EXPECT_TRUE(userMgr.hasUser("user1"));
}
```

3. STRESS ТЕСТЫ:
```cpp
void stressTest() {
    ActorSystem system;
    CalculatorActor& calculator = system.createActor<CalculatorActor>("Calculator");
    
    const int NUM_MESSAGES = 10000;
    
    // Отправляем много сообщений
    for (int i = 0; i < NUM_MESSAGES; ++i) {
        calculator.send(Message("ADD", 1.0));
    }
    
    // Ждем обработки
    while (calculator.getQueueSize() > 0) {
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
    
    EXPECT_EQ(calculator.getResult(), NUM_MESSAGES);
}
```
```

## 🎯 Рекомендации по использованию

```
┌─────────────────────────────────────────────────────────────────┐
│                    ЛУЧШИЕ ПРАКТИКИ                             │
└─────────────────────────────────────────────────────────────────┘

1. 🎯 ПРОЕКТИРОВАНИЕ:
   • Используйте неизменяемые сообщения
   • Изолируйте состояние в актерах
   • Определите четкие интерфейсы сообщений
   • Избегайте блокирующих операций

2. 🔧 РЕАЛИЗАЦИЯ:
   • Реализуйте graceful shutdown
   • Обрабатывайте исключения правильно
   • Мониторьте производительность
   • Используйте пулы потоков для актеров

3. 🧪 ТЕСТИРОВАНИЕ:
   • Тестируйте изоляцию состояния
   • Проверяйте обработку сообщений
   • Тестируйте взаимодействие актеров
   • Используйте детерминированные тесты

4. ⚡ ПРОИЗВОДИТЕЛЬНОСТЬ:
   • Оптимизируйте размер сообщений
   • Используйте batch обработку
   • Мониторьте размер очередей
   • Избегайте memory leaks

5. 📚 ДОКУМЕНТАЦИЯ:
   • Документируйте типы сообщений
   • Описывайте поведение актеров
   • Приводите примеры использования
   • Объясняйте архитектурные решения

6. 🔄 РЕФАКТОРИНГ:
   • Начинайте с простых актеров
   • Добавляйте сложность постепенно
   • Рефакторите общие паттерны
   • Измеряйте производительность
```

## 🚨 Предупреждения

```
┌─────────────────────────────────────────────────────────────────┐
│                    ЧАСТЫЕ ОШИБКИ                               │
└─────────────────────────────────────────────────────────────────┘

❌ НЕ ДЕЛАЙТЕ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Разделяемое     │ • Используйте глобальные переменные          │
│ состояние       │ • Создавайте статические переменные           │
├─────────────────┼───────────────────────────────────────────────┤
│ Блокирующие     │ • Выполняйте долгие операции в receive()     │
│ операции        │ • Блокируйте потоки актеров                  │
├─────────────────┼───────────────────────────────────────────────┤
│ Большие         │ • Отправляйте большие объекты в сообщениях   │
│ сообщения       │ • Копируйте данные вместо ссылок             │
├─────────────────┼───────────────────────────────────────────────┤
│ Бесконечные     │ • Создавайте актеров без остановки           │
│ актеры          │ • Забывайте вызывать stop()                  │
└─────────────────┴───────────────────────────────────────────────┘

✅ ДЕЛАЙТЕ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Неизменяемые    │ • Используйте const для сообщений            │
│ сообщения       │ • Передавайте данные по значению             │
├─────────────────┼───────────────────────────────────────────────┤
│ Асинхронные     │ • Используйте callback'и для долгих операций │
│ операции        │ • Делайте операции неблокирующими            │
├─────────────────┼───────────────────────────────────────────────┤
│ Маленькие       │ • Отправляйте только необходимые данные      │
│ сообщения       │ • Используйте ссылки на большие объекты      │
├─────────────────┼───────────────────────────────────────────────┤
│ Управление      │ • Правильно завершайте актеров               │
│ жизненным циклом│ • Очищайте ресурсы в деструкторе             │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🔗 Связь с другими паттернами

```
┌─────────────────────────────────────────────────────────────────┐
│                    СВЯЗЬ С ДРУГИМИ ПАТТЕРНАМИ                 │
└─────────────────────────────────────────────────────────────────┘

Actor Model + Command Pattern:
┌─────────────────┬───────────────────────────────────────────────┐
│ Actor Model     │ • Обработка команд как сообщений             │
│                 │ • Изоляция состояния команд                   │
│ Command Pattern │ • Инкапсуляция операций                      │
│                 │ • Undo/Redo функциональность                 │
└─────────────────┴───────────────────────────────────────────────┘

Actor Model + Observer Pattern:
┌─────────────────┬───────────────────────────────────────────────┐
│ Actor Model     │ • Актеры как наблюдатели                     │
│                 │ • Асинхронные уведомления                    │
│ Observer Pattern│ • Слабая связанность                         │
│                 │ • Динамическая подписка                      │
└─────────────────┴───────────────────────────────────────────────┘

Actor Model + State Pattern:
┌─────────────────┬───────────────────────────────────────────────┐
│ Actor Model     │ • Состояние актера                           │
│                 │ • Изменение поведения через сообщения        │
│ State Pattern   │ • Инкапсуляция состояний                     │
│                 │ • Переходы между состояниями                 │
└─────────────────┴───────────────────────────────────────────────┘
```

## 📚 Дополнительные ресурсы

```
┌─────────────────────────────────────────────────────────────────┐
│                    ДОПОЛНИТЕЛЬНЫЕ РЕСУРСЫ                     │
└─────────────────────────────────────────────────────────────────┘

📖 КНИГИ:
• "Programming Erlang" - Joe Armstrong
• "Reactive Messaging Patterns with the Actor Model" - Vaughn Vernon
• "Actor Model of Computation" - Carl Hewitt

🌐 ОНЛАЙН РЕСУРСЫ:
• Akka Documentation (Scala/Java)
• Orleans Documentation (C#)
• Erlang/OTP Documentation
• Actor Model Wikipedia

🛠️ ФРЕЙМВОРКИ:
• Akka (Scala/Java)
• Orleans (C#)
• Erlang/OTP
• CAF (C++ Actor Framework)

📝 СТАНДАРТЫ:
• Actor Model Theory
• Message Passing Interface (MPI)
• Communicating Sequential Processes (CSP)
• Reactive Streams
```

---

*Помните: Actor Model - это мощный паттерн для создания масштабируемых и отказоустойчивых систем, но используйте его с пониманием принципов изоляции и асинхронности!* 🎭
