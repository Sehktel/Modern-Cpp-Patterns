# 📊 Плакат: Smart Pointers (Умные указатели)

## 🎯 Назначение Smart Pointers

```
┌─────────────────────────────────────────────────────────────────┐
│                    SMART POINTERS                               │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  🛡️ АВТОМАТИЧЕСКОЕ УПРАВЛЕНИЕ ПАМЯТЬЮ                         │
│  🔒 ИСКЛЮЧЕНИЯ БЕЗОПАСНОСТЬ ИЗ КОРОБКИ                        │
│  🚫 ПРЕДОТВРАЩЕНИЕ УТЕЧЕК ПАМЯТИ                              │
│  🎯 RAII ПРИНЦИП В ДЕЙСТВИИ                                   │
└─────────────────────────────────────────────────────────────────┘

Типы Smart Pointers:
┌─────────────────┬───────────────────────────────────────────────┐
│   unique_ptr    │ • Единоличное владение                        │
│                 │ • Невозможно копировать                       │
│                 │ • Можно перемещать                            │
├─────────────────┼───────────────────────────────────────────────┤
│   shared_ptr    │ • Разделяемое владение                        │
│                 │ • Счетчик ссылок                              │
│                 │ • Автоматическое освобождение                 │
├─────────────────┼───────────────────────────────────────────────┤
│   weak_ptr      │ • Слабые ссылки                               │
│                 │ • Не влияет на время жизни                    │
│                 │ • Предотвращение циклических ссылок           │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🔄 Сравнение с Raw Pointers

```
┌─────────────────────────────────────────────────────────────────┐
│                    СРАВНЕНИЕ ПОДХОДОВ                          │
└─────────────────────────────────────────────────────────────────┘

❌ ПЛОХО (Raw Pointers):
┌─────────────────────────────────────────────────────────────────┐
│ class ResourceManager {                                        │
│ private:                                                        │
│     int* data_;                                                 │
│     FILE* file_;                                                │
│                                                                 │
│ public:                                                         │
│     ResourceManager() {                                         │
│         data_ = new int[1000];        ← Утечка при исключении! │
│         file_ = fopen("data.txt", "r"); ← Утечка при исключении!│
│         if (!file_) {                                           │
│             delete[] data_;     ← Дублирование кода             │
│             throw std::runtime_error("Cannot open file");       │
│         }                                                       │
│     }                                                           │
│                                                                 │
│     ~ResourceManager() {                                        │
│         delete[] data_;                                         │
│         fclose(file_);                                          │
│     }                                                           │
│                                                                 │
│     // Проблемы:                                                │
│     // • Утечки памяти при исключениях                          │
│     // • Дублирование кода очистки                              │
│     // • Легко забыть освобождение                              │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШО (Smart Pointers):
┌─────────────────────────────────────────────────────────────────┐
│ class ResourceManager {                                        │
│ private:                                                        │
│     std::unique_ptr<int[]> data_;                               │
│     std::ifstream file_;                                        │
│                                                                 │
│ public:                                                         │
│     ResourceManager()                                           │
│         : data_(std::make_unique<int[]>(1000)),                │
│           file_("data.txt") {                                   │
│         if (!file_.is_open()) {                                 │
│             throw std::runtime_error("Cannot open file");       │
│         }                                                       │
│         // Автоматическое освобождение при исключениях!         │
│     }                                                           │
│                                                                 │
│     // Автоматический деструктор!                               │
│     // Нет необходимости в ручном управлении памятью           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘
```

## 🏗️ unique_ptr - Единоличное владение

```
┌─────────────────────────────────────────────────────────────────┐
│                    UNIQUE_PTR                                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  🎯 ЕДИНСТВЕННЫЙ ВЛАДЕЛЕЦ ОБЪЕКТА                             │
│  🚫 НЕВОЗМОЖНО КОПИРОВАТЬ (только перемещать)                │
│  ⚡ МАКСИМАЛЬНАЯ ПРОИЗВОДИТЕЛЬНОСТЬ                           │
│  🛡️ АВТОМАТИЧЕСКОЕ ОСВОБОЖДЕНИЕ ПАМЯТИ                       │
└─────────────────────────────────────────────────────────────────┘

Создание и использование:
┌─────────────────────────────────────────────────────────────────┐
│ // Создание                                                     │
│ auto ptr1 = std::make_unique<int>(42);                         │
│ auto ptr2 = std::make_unique<int[]>(100);                      │
│ auto ptr3 = std::make_unique<MyClass>(arg1, arg2);             │
│                                                                 │
│ // Использование                                                │
│ std::cout << *ptr1 << std::endl;          // Разыменование     │
│ ptr2[5] = 10;                             // Доступ к массиву   │
│ ptr3->method();                           // Вызов метода       │
│                                                                 │
│ // Перемещение (не копирование!)                               │
│ auto ptr4 = std::move(ptr1);              // ptr1 становится nullptr│
│                                                                 │
│ // Проверка владения                                            │
│ if (ptr1) {                             // Проверка на nullptr │
│     std::cout << "Owns object" << std::endl;                   │
│ } else {                                                         │
│     std::cout << "Doesn't own object" << std::endl;            │
│ }                                                                │
└─────────────────────────────────────────────────────────────────┘

Освобождение памяти:
┌─────────────────────────────────────────────────────────────────┐
│ // Автоматическое освобождение при выходе из области видимости │
│ {                                                               │
│     auto ptr = std::make_unique<int>(42);                      │
│     // ... использование ...                                   │
│ } // ← Автоматический delete здесь!                            │
│                                                                 │
│ // Ручное освобождение                                          │
│ ptr.reset();                    // Освобождает и устанавливает nullptr│
│ ptr.reset(new int(100));        // Освобождает и устанавливает новый│
│                                                                 │
│ // Получение raw pointer (осторожно!)                          │
│ int* raw = ptr.get();           // Получить raw pointer         │
│ int* raw2 = ptr.release();      // Освободить владение          │
└─────────────────────────────────────────────────────────────────┘
```

## 🔗 shared_ptr - Разделяемое владение

```
┌─────────────────────────────────────────────────────────────────┐
│                    SHARED_PTR                                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  🤝 РАЗДЕЛЯЕМОЕ ВЛАДЕНИЕ ОБЪЕКТОМ                              │
│  📊 СЧЕТЧИК ССЫЛОК (reference counting)                       │
│  🔄 АВТОМАТИЧЕСКОЕ ОСВОБОЖДЕНИЕ ПРИ ПОСЛЕДНЕЙ ССЫЛКЕ          │
│  ⚠️ НАКЛАДНЫЕ РАСХОДЫ НА СЧЕТЧИК                               │
└─────────────────────────────────────────────────────────────────┘

Создание и использование:
┌─────────────────────────────────────────────────────────────────┐
│ // Создание                                                     │
│ auto ptr1 = std::make_shared<int>(42);                         │
│ auto ptr2 = std::make_shared<MyClass>(arg1, arg2);             │
│                                                                 │
│ // Копирование (увеличивает счетчик ссылок)                    │
│ auto ptr3 = ptr1;              // Счетчик ссылок: 2            │
│ auto ptr4 = ptr2;              // Счетчик ссылок: 2            │
│                                                                 │
│ // Использование                                                │
│ std::cout << *ptr1 << std::endl;                               │
│ ptr2->method();                                                │
│                                                                 │
│ // Проверка счетчика ссылок                                     │
│ std::cout << "Reference count: " << ptr1.use_count() << std::endl;│
│                                                                 │
│ // Проверка единственного владения                              │
│ if (ptr1.unique()) {           // use_count() == 1             │
│     std::cout << "Only owner" << std::endl;                    │
│ }                                                                │
└─────────────────────────────────────────────────────────────────┘

Жизненный цикл:
┌─────────────────────────────────────────────────────────────────┐
│ {                                                               │
│     auto ptr1 = std::make_shared<int>(42);  // Счетчик: 1      │
│     {                                                           │
│         auto ptr2 = ptr1;                   // Счетчик: 2      │
│         auto ptr3 = ptr2;                   // Счетчик: 3      │
│         // ... использование ...                               │
│     } // ptr2, ptr3 уничтожаются              // Счетчик: 1    │
│     // ... использование ...                                   │
│ } // ptr1 уничтожается, объект удаляется      // Счетчик: 0    │
└─────────────────────────────────────────────────────────────────┘
```

## 🔗 weak_ptr - Слабые ссылки

```
┌─────────────────────────────────────────────────────────────────┐
│                    WEAK_PTR                                     │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  🔗 СЛАБАЯ ССЫЛКА НА ОБЪЕКТ                                    │
│  🚫 НЕ ВЛИЯЕТ НА ВРЕМЯ ЖИЗНИ ОБЪЕКТА                          │
│  🔄 ПРЕДОТВРАЩЕНИЕ ЦИКЛИЧЕСКИХ ССЫЛОК                          │
│  ✅ БЕЗОПАСНАЯ ПРОВЕРКА СУЩЕСТВОВАНИЯ                          │
└─────────────────────────────────────────────────────────────────┘

Использование:
┌─────────────────────────────────────────────────────────────────┐
│ // Создание из shared_ptr                                       │
│ auto shared = std::make_shared<int>(42);                       │
│ std::weak_ptr<int> weak = shared;                              │
│                                                                 │
│ // Проверка существования                                       │
│ if (auto locked = weak.lock()) {  // Получить shared_ptr       │
│     std::cout << "Object exists: " << *locked << std::endl;    │
│ } else {                                                         │
│     std::cout << "Object was destroyed" << std::endl;          │
│ }                                                                │
│                                                                 │
│ // Проверка без блокировки                                      │
│ if (weak.expired()) {           // Проверка без получения      │
│     std::cout << "Object expired" << std::endl;                │
│ }                                                                │
│                                                                 │
│ // Получение счетчика ссылок                                    │
│ std::cout << "Reference count: " << weak.use_count() << std::endl;│
└─────────────────────────────────────────────────────────────────┘

Решение циклических ссылок:
┌─────────────────────────────────────────────────────────────────┐
│ class Parent {                                                  │
│ public:                                                         │
│     std::vector<std::shared_ptr<Child>> children;              │
│     std::string name;                                           │
│ };                                                              │
│                                                                 │
│ class Child {                                                   │
│ public:                                                         │
│     std::weak_ptr<Parent> parent;  // ← Слабая ссылка!         │
│     std::string name;                                           │
│                                                                 │
│     void printParentName() {                                    │
│         if (auto p = parent.lock()) {                          │
│             std::cout << "Parent: " << p->name << std::endl;   │
│         }                                                       │
│     }                                                           │
│ };                                                              │
│                                                                 │
│ // Теперь нет циклических ссылок!                               │
│ auto parent = std::make_shared<Parent>();                      │
│ auto child = std::make_shared<Child>();                        │
│                                                                 │
│ parent->children.push_back(child);                             │
│ child->parent = parent;         // weak_ptr не увеличивает счетчик│
└─────────────────────────────────────────────────────────────────┘
```

## 🎨 make_unique vs make_shared

```
┌─────────────────────────────────────────────────────────────────┐
│                MAKE_UNIQUE vs MAKE_SHARED                      │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   make_unique   │ • Создает unique_ptr                          │
│                 │ • Один вызов new                              │
│                 │ • Максимальная производительность             │
│                 │ • Exception safety                            │
│                 │ • Доступно с C++14                            │
├─────────────────┼───────────────────────────────────────────────┤
│   make_shared   │ • Создает shared_ptr                          │
│                 │ • Один вызов new (оптимизация)               │
│                 │ • Создает control block                       │
│                 │ • Exception safety                            │
│                 │ • Доступно с C++11                            │
└─────────────────┴───────────────────────────────────────────────┘

Примеры использования:
┌─────────────────────────────────────────────────────────────────┐
│ // make_unique                                                  │
│ auto ptr1 = std::make_unique<int>(42);                         │
│ auto ptr2 = std::make_unique<int[]>(100);                      │
│ auto ptr3 = std::make_unique<MyClass>(arg1, arg2);             │
│                                                                 │
│ // make_shared                                                  │
│ auto ptr4 = std::make_shared<int>(42);                         │
│ auto ptr5 = std::make_shared<MyClass>(arg1, arg2);             │
│                                                                 │
│ // НЕ делайте так!                                              │
│ std::unique_ptr<int> bad1(new int(42));        // Избегайте!   │
│ std::shared_ptr<int> bad2(new int(42));        // Избегайте!   │
└─────────────────────────────────────────────────────────────────┘

Преимущества make_* функций:
✅ Exception safety
✅ Производительность (особенно для make_shared)
✅ Читаемость кода
✅ Автоматический вывод типов
```

## 🔄 Move Semantics с Smart Pointers

```
┌─────────────────────────────────────────────────────────────────┐
│              MOVE SEMANTICS С SMART POINTERS                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ // unique_ptr поддерживает move semantics                      │
│ auto ptr1 = std::make_unique<int>(42);                         │
│ auto ptr2 = std::move(ptr1);     // ptr1 становится nullptr    │
│                                                                 │
│ // Передача в функции                                           │
│ void process(std::unique_ptr<int> ptr) {                       │
│     // ptr получает владение                                    │
│     std::cout << *ptr << std::endl;                            │
│ } // ptr автоматически освобождается                           │
│                                                                 │
│ auto ptr = std::make_unique<int>(42);                          │
│ process(std::move(ptr));        // Передача владения            │
│ // ptr теперь nullptr                                           │
│                                                                 │
│ // Возврат из функций                                           │
│ std::unique_ptr<int> createValue(int value) {                  │
│     return std::make_unique<int>(value);                       │
│ }                                                               │
│                                                                 │
│ auto ptr = createValue(42);     // Автоматический move          │
└─────────────────────────────────────────────────────────────────┘

shared_ptr и move:
┌─────────────────────────────────────────────────────────────────┐
│ // shared_ptr тоже поддерживает move                           │
│ auto ptr1 = std::make_shared<int>(42);                         │
│ auto ptr2 = std::move(ptr1);    // ptr1 становится nullptr     │
│                                 // Счетчик ссылок не меняется   │
│                                                                 │
│ // Но обычно копируем shared_ptr                               │
│ auto ptr3 = ptr2;               // Счетчик ссылок: 2           │
│                                                                 │
│ // move полезен для передачи в функции                         │
│ void process(std::shared_ptr<int> ptr) {                       │
│     // Можем использовать move или копирование                 │
│ }                                                               │
│                                                                 │
│ process(std::move(ptr2));       // Move (быстрее)              │
│ process(ptr3);                  // Копирование (безопаснее)    │
└─────────────────────────────────────────────────────────────────┘
```

## 🧪 Тестирование с Smart Pointers

```
┌─────────────────────────────────────────────────────────────────┐
│              ТЕСТИРОВАНИЕ С SMART POINTERS                     │
└─────────────────────────────────────────────────────────────────┘

Преимущества для тестирования:
┌─────────────────┬───────────────────────────────────────────────┐
│ Изоляция        │ ✅ Легко создавать изолированные тесты       │
│                 │ class MockService {                           │
│                 │     MOCK_METHOD(void, doWork, ());           │
│                 │ };                                            │
│                 │                                               │
│                 │ TEST(MyClassTest, TestMethod) {              │
│                 │     auto mockService = std::make_unique<MockService>();│
│                 │     MyClass obj(std::move(mockService));     │
│                 │     // Изолированный тест                    │
│                 │ }                                             │
├─────────────────┼───────────────────────────────────────────────┤
│ Управление      │ ✅ Полный контроль над временем жизни       │
│ памятью         │ TEST(MemoryTest, NoLeaks) {                  │
│                 │     {                                         │
│                 │         auto ptr = std::make_unique<LargeObject>();│
│                 │         // Автоматическое освобождение       │
│                 │     } // Проверяем отсутствие утечек         │
│                 │ }                                             │
├─────────────────┼───────────────────────────────────────────────┤
│ Исключения      │ ✅ Безопасность при исключениях              │
│                 │ TEST(ExceptionTest, Safety) {                │
│                 │     try {                                     │
│                 │         auto ptr = std::make_unique<int>(42); │
│                 │         throw std::runtime_error("Test");     │
│                 │     } catch (...) {                           │
│                 │         // Память автоматически освобождена  │
│                 │     }                                         │
│                 │ }                                             │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🔗 Связь с паттернами проектирования

```
┌─────────────────────────────────────────────────────────────────┐
│            SMART POINTERS В ПАТТЕРНАХ                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   RAII          │ • Smart pointers - основа RAII               │
│                 │ • Автоматическое управление ресурсами        │
│                 │ • Exception safety из коробки                │
├─────────────────┼───────────────────────────────────────────────┤
│   Factory       │ • Возврат созданных объектов через smart ptrs│
│   Method        │ • Инкапсуляция создания и управления памятью │
│                 │ • Автоматическая очистка при ошибках         │
├─────────────────┼───────────────────────────────────────────────┤
│   Observer      │ • shared_ptr для разделения наблюдателей     │
│                 │ • weak_ptr для предотвращения циклических    │
│                 │   ссылок                                      │
├─────────────────┼───────────────────────────────────────────────┤
│   Command       │ • unique_ptr для команд                       │
│                 │ • Автоматическое управление временем жизни   │
│                 │ • Безопасное выполнение и откат               │
├─────────────────┼───────────────────────────────────────────────┤
│   Singleton     │ • shared_ptr для глобальных ресурсов         │
│                 │ • Автоматическое освобождение при завершении │
│                 │ • Thread-safe управление                      │
└─────────────────┴───────────────────────────────────────────────┘
```

## 💡 Практические рекомендации

```
┌─────────────────────────────────────────────────────────────────┐
│                  ПРАКТИЧЕСКИЕ РЕКОМЕНДАЦИИ                     │
└─────────────────────────────────────────────────────────────────┘

1. 🎯 Выбор типа указателя:
   • unique_ptr - для единоличного владения
   • shared_ptr - для разделяемого владения
   • weak_ptr - для предотвращения циклических ссылок
   • raw pointers - только для передачи в C API

2. 🔧 Принципы использования:
   • Всегда используйте make_unique/make_shared
   • Избегайте raw new/delete
   • Передавайте по ссылке когда возможно
   • Используйте move semantics для unique_ptr

3. 🧪 Тестирование:
   • Smart pointers упрощают создание моков
   • Автоматическое управление памятью в тестах
   • Exception safety из коробки
   • Изоляция тестов

4. ⚡ Производительность:
   • unique_ptr - минимальные накладные расходы
   • shared_ptr - накладные расходы на счетчик ссылок
   • weak_ptr - минимальные накладные расходы
   • make_shared - оптимизация выделения памяти

5. 🚨 Типичные ошибки:
   • Циклические ссылки с shared_ptr
   • Использование raw pointers вместо smart
   • Неправильное использование weak_ptr
   • Игнорирование move semantics
```

## 🎓 Ключевые выводы

```
┌─────────────────────────────────────────────────────────────────┐
│                      КЛЮЧЕВЫЕ ВЫВОДЫ                          │
└─────────────────────────────────────────────────────────────────┘

✅ Smart Pointers - современный стандарт C++:
   • Автоматическое управление памятью
   • Exception safety из коробки
   • RAII принцип в действии
   • Предотвращение утечек памяти

✅ Выбирайте подходящий тип:
   • unique_ptr - единоличное владение
   • shared_ptr - разделяемое владение
   • weak_ptr - слабые ссылки

✅ Используйте правильно:
   • make_unique/make_shared для создания
   • move semantics для unique_ptr
   • weak_ptr для предотвращения циклов
   • Избегайте raw pointers

✅ Интеграция с паттернами:
   • Основа для RAII
   • Упрощение Factory Method
   • Безопасность в Observer
   • Управление в Command

⚠️ Помните: Smart pointers - это не серебряная пуля, но мощный инструмент для безопасного управления памятью!
```

---
*Smart Pointers - это фундамент современного C++. Освойте их, и вы заложите прочную основу для изучения всех паттернов проектирования!*
