# 📊 Плакат: Template Method Pattern (Шаблонный метод)

## 🎯 Назначение Template Method Pattern

```
┌─────────────────────────────────────────────────────────────────┐
│                    TEMPLATE METHOD PATTERN                     │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  📋 ОПРЕДЕЛЯЕТ СКЕЛЕТ АЛГОРИТМА В БАЗОВОМ КЛАССЕ             │
│  🔄 ПОЗВОЛЯЕТ ПОДКЛАССАМ ПЕРЕОПРЕДЕЛЯТЬ ОТДЕЛЬНЫЕ ШАГИ        │
│  🚀 СОХРАНЯЕТ СТРУКТУРУ АЛГОРИТМА НЕИЗМЕННОЙ                  │
│  🛡️ СОБЛЮДЕНИЕ OPEN/CLOSED PRINCIPLE                          │
└─────────────────────────────────────────────────────────────────┘

Применение:
┌─────────────────┬───────────────────────────────────────────────┐
│   Data Processing│ • Обработка данных с разными форматами      │
├─────────────────┼───────────────────────────────────────────────┤
│   Game Engines  │ • Игровые циклы с разными реализациями       │
├─────────────────┼───────────────────────────────────────────────┤
│   Web Frameworks│ • Обработка HTTP запросов                    │
├─────────────────┼───────────────────────────────────────────────┤
│   Compilers     │ • Компиляция с разными оптимизациями         │
├─────────────────┼───────────────────────────────────────────────┤
│   Testing       │ • Тестовые фреймворки                        │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🔄 Проблема без Template Method

```
┌─────────────────────────────────────────────────────────────────┐
│                    ПРОБЛЕМА: ДУБЛИРОВАНИЕ КОДА                 │
└─────────────────────────────────────────────────────────────────┘

❌ ПЛОХОЙ ДИЗАЙН - Нарушение принципов:
┌─────────────────────────────────────────────────────────────────┐
│                    DataProcessor (Нарушает DRY!)               │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │              DataProcessor                                 ││
│  │                                                             ││
│  │  // ❌ ПРОБЛЕМЫ:                                          ││
│  │  // • Дублирование кода                                    ││
│  │  // • Сложность поддержки                                 ││
│  │  // • Нарушение DRY принципа                              ││
│  │  // • Сложность добавления новых типов                     ││
│  │                                                             ││
│  │  void processCSV(const std::string& filename) {            ││
│  │      // 1. Открыть файл                                    ││
│  │      std::ifstream file(filename);                         ││
│  │      if (!file.is_open()) {                                ││
│  │          throw std::runtime_error("Cannot open file");      ││
│  │      }                                                      ││
│  │                                                             ││
│  │      // 2. Прочитать данные                                ││
│  │      std::string line;                                      ││
│  │      while (std::getline(file, line)) {                    ││
│  │          // Парсинг CSV                                     ││
│  │      }                                                      ││
│  │                                                             ││
│  │      // 3. Обработать данные                               ││
│  │      // Логика обработки CSV                               ││
│  │                                                             ││
│  │      // 4. Сохранить результат                             ││
│  │      // Сохранение CSV                                      ││
│  │                                                             ││
│  │      // 5. Закрыть файл                                     ││
│  │      file.close();                                          ││
│  │  }                                                          ││
│  │                                                             ││
│  │  void processJSON(const std::string& filename) {            ││
│  │      // 1. Открыть файл                                    ││
│  │      std::ifstream file(filename);                         ││
│  │      if (!file.is_open()) {                                ││
│  │          throw std::runtime_error("Cannot open file");      ││
│  │      }                                                      ││
│  │                                                             ││
│  │      // 2. Прочитать данные                                ││
│  │      std::string line;                                      ││
│  │      while (std::getline(file, line)) {                    ││
│  │          // Парсинг JSON                                    ││
│  │      }                                                      ││
│  │                                                             ││
│  │      // 3. Обработать данные                               ││
│  │      // Логика обработки JSON                              ││
│  │                                                             ││
│  │      // 4. Сохранить результат                             ││
│  │      // Сохранение JSON                                     ││
│  │                                                             ││
│  │      // 5. Закрыть файл                                     ││
│  │      file.close();                                          ││
│  │  }                                                          ││
│  │                                                             ││
│  │  // ❌ ДУБЛИРОВАНИЕ КОДА!                                 ││
│  └─────────────────────────────────────────────────────────────┘│
│                                                                 │
│  Проблемы:                                                     │
│  ❌ Нарушение DRY принципа                                      │
│  ❌ Дублирование кода                                           │
│  ❌ Сложность поддержки                                         │
│  ❌ Сложность добавления новых типов                           │
└─────────────────────────────────────────────────────────────────┘
```

## ✅ Решение с Template Method

```
┌─────────────────────────────────────────────────────────────────┐
│                    РЕШЕНИЕ: TEMPLATE METHOD PATTERN           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    ХОРОШИЙ ДИЗАЙН                             │
│                                                                 │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐        │
│  │   CSV       │    │   JSON      │    │   XML       │        │
│  │ Processor   │    │ Processor   │    │ Processor   │        │
│  │             │    │             │    │             │        │
│  │ • parse()   │    │ • parse()   │    │ • parse()   │        │
│  │ • process() │    │ • process() │    │ • process() │        │
│  │ • save()    │    │ • save()    │    │ • save()    │        │
│  └─────────────┘    └─────────────┘    └─────────────┘        │
│         ▲                 ▲                 ▲                  │
│         │                 │                 │                  │
│  ┌──────┴─────────────────┴─────────────────┴──────────┐      │
│  │              DataProcessor                          │      │
│  │                                                     │      │
│  │  // Шаблонный метод (неизменяемый)                 │      │
│  │  void processData(const std::string& filename) {    │      │
│  │      // 1. Открыть файл                             │      │
│  │      std::ifstream file(filename);                  │      │
│  │      if (!file.is_open()) {                        │      │
│  │          throw std::runtime_error("Cannot open file");│      │
│  │      }                                              │      │
│  │                                                     │      │
│  │      // 2. Прочитать данные                         │      │
│  │      std::string data = readData(file);             │      │
│  │                                                     │      │
│  │      // 3. Обработать данные                        │      │
│  │      std::string processedData = processData(data);  │      │
│  │                                                     │      │
│  │      // 4. Сохранить результат                      │      │
│  │      saveResult(processedData);                     │      │
│  │                                                     │      │
│  │      // 5. Закрыть файл                             │      │
│  │      file.close();                                  │      │
│  │  }                                                  │      │
│  │                                                     │      │
│  │  // Абстрактные методы (переопределяемые)           │      │
│  │  virtual std::string readData(std::ifstream& file) = 0;│      │
│  │  virtual std::string processData(const std::string& data) = 0;│      │
│  │  virtual void saveResult(const std::string& result) = 0;│      │
│  └─────────────────────────────────────────────────────┘      │
│                                                                 │
│  Преимущества:                                                  │
│  ✅ Соблюдение DRY принципа                                     │
│  ✅ Нет дублирования кода                                       │
│  ✅ Легкость поддержки                                          │
│  ✅ Легкость добавления новых типов                           │
└─────────────────────────────────────────────────────────────────┘
```

## 🏗️ Структура Template Method Pattern

```
┌─────────────────────────────────────────────────────────────────┐
│                    СТРУКТУРА ПАТТЕРНА                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    AbstractClass (Абстрактный класс)           │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │                    AbstractClass                          ││
│  │                                                             ││
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        ││
│  │  │ Concrete    │  │ Concrete    │  │ Concrete    │        ││
│  │  │ ClassA      │  │ ClassB      │  │ ClassC      │        ││
│  │  │             │  │             │  │             │        ││
│  │  │ • primitive1│  │ • primitive1│  │ • primitive1│        ││
│  │  │ • primitive2│  │ • primitive2│  │ • primitive2│        ││
│  │  │ • primitive3│  │ • primitive3│  │ • primitive3│        ││
│  │  └─────────────┘  └─────────────┘  └─────────────┘        ││
│  │         ▲                 ▲                 ▲              ││
│  │         │                 │                 │              ││
│  │  ┌──────┴─────────────────┴─────────────────┴──────────┐  ││
│  │  │              AbstractClass                         │  ││
│  │  │                                                     │  ││
│  │  │  // Шаблонный метод (неизменяемый)                 │  ││
│  │  │  void templateMethod() {                           │  ││
│  │  │      primitive1();                                 │  ││
│  │  │      primitive2();                                 │  ││
│  │  │      primitive3();                                 │  ││
│  │  │  }                                                  │  ││
│  │  │                                                     │  ││
│  │  │  // Абстрактные методы (переопределяемые)          │  ││
│  │  │  virtual void primitive1() = 0;                     │  ││
│  │  │  virtual void primitive2() = 0;                    │  ││
│  │  │  virtual void primitive3() = 0;                    │  ││
│  │  └─────────────────────────────────────────────────────┘  ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 Последовательность взаимодействий

```
┌─────────────────────────────────────────────────────────────────┐
│              ПОСЛЕДОВАТЕЛЬНОСТЬ ВЗАИМОДЕЙСТВИЙ                │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    1. ВЫЗОВ ШАБЛОННОГО МЕТОДА                 │
│                                                                 │
│  ┌─────────────┐              ┌─────────────┐                 │
│  │   Client    │              │ AbstractClass│                │
│  │             │              │             │                 │
│  │ • call()    │              │ • templateMethod│              │
│  │ • use()     │              │ • primitive1 │                 │
│  └─────────────┘              └─────────────┘                 │
│         │                              ▲                      │
│         │                              │                      │
│         │      templateMethod()         │                      │
│         └──────────────────────────────┘                      │
│                                                                 │
│                    2. ВЫПОЛНЕНИЕ ПРИМИТИВНЫХ МЕТОДОВ           │
│                                                                 │
│  ┌─────────────┐              ┌─────────────┐                 │
│  │ AbstractClass│              │ ConcreteClass│                │
│  │             │              │             │                 │
│  │ • templateMethod│              │ • primitive1 │                 │
│  │ • primitive1 │              │ • primitive2 │                 │
│  │ • primitive2 │              │ • primitive3 │                 │
│  └─────────────┘              └─────────────┘                 │
│         │                              ▲                      │
│         │                              │                      │
│         │      primitive1()            │                      │
│         │      primitive2()            │                      │
│         │      primitive3()            │                      │
│         └──────────────────────────────┘                      │
│                                                                 │
│                    3. ЗАВЕРШЕНИЕ АЛГОРИТМА                     │
│                                                                 │
│  ┌─────────────┐              ┌─────────────┐                 │
│  │ AbstractClass│              │ ConcreteClass│                │
│  │             │              │             │                 │
│  │ • templateMethod│              │ • primitive1 │                 │
│  │ • primitive1 │              │ • primitive2 │                 │
│  │ • primitive2 │              │ • primitive3 │                 │
│  └─────────────┘              └─────────────┘                 │
│         ▲                              │                      │
│         │                              │                      │
│         │      return result           │                      │
│         └──────────────────────────────┘                      │
└─────────────────────────────────────────────────────────────────┘
```

## 🎨 Варианты реализации

### 1. Классическая реализация
```
┌─────────────────────────────────────────────────────────────────┐
│                  КЛАССИЧЕСКАЯ РЕАЛИЗАЦИЯ                      │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ // Абстрактный класс                                            │
│ class DataProcessor {                                           │
│ public:                                                          │
│     virtual ~DataProcessor() = default;                        │
│                                                                  │
│     // Шаблонный метод (неизменяемый)                          │
│     void processData(const std::string& filename) {             │
│         // 1. Открыть файл                                      │
│         std::ifstream file(filename);                           │
│         if (!file.is_open()) {                                  │
│             throw std::runtime_error("Cannot open file");       │
│         }                                                        │
│                                                                  │
│         // 2. Прочитать данные                                  │
│         std::string data = readData(file);                      │
│                                                                  │
│         // 3. Обработать данные                                 │
│         std::string processedData = processData(data);          │
│                                                                  │
│         // 4. Сохранить результат                               │
│         saveResult(processedData);                               │
│                                                                  │
│         // 5. Закрыть файл                                      │
│         file.close();                                            │
│     }                                                            │
│                                                                  │
│     // Абстрактные методы (переопределяемые)                   │
│     virtual std::string readData(std::ifstream& file) = 0;      │
│     virtual std::string processData(const std::string& data) = 0;│
│     virtual void saveResult(const std::string& result) = 0;     │
│ };                                                               │
│                                                                  │
│ // Конкретный класс - CSV процессор                              │
│ class CSVProcessor : public DataProcessor {                     │
│ public:                                                          │
│     std::string readData(std::ifstream& file) override {        │
│         std::string line;                                        │
│         std::string data;                                        │
│         while (std::getline(file, line)) {                      │
│             data += line + "\n";                                 │
│         }                                                        │
│         return data;                                             │
│     }                                                            │
│                                                                  │
│     std::string processData(const std::string& data) override { │
│         // Логика обработки CSV                                 │
│         std::string processed = data;                            │
│         // ... обработка ...                                     │
│         return processed;                                        │
│     }                                                            │
│                                                                  │
│     void saveResult(const std::string& result) override {       │
│         // Сохранение CSV                                        │
│         std::ofstream out("output.csv");                        │
│         out << result;                                           │
│     }                                                            │
│ };                                                               │
│                                                                  │
│ // Конкретный класс - JSON процессор                             │
│ class JSONProcessor : public DataProcessor {                    │
│ public:                                                          │
│     std::string readData(std::ifstream& file) override {        │
│         std::string line;                                        │
│         std::string data;                                        │
│         while (std::getline(file, line)) {                      │
│             data += line + "\n";                                │
│         }                                                        │
│         return data;                                             │
│     }                                                            │
│                                                                  │
│     std::string processData(const std::string& data) override { │
│         // Логика обработки JSON                                │
│         std::string processed = data;                            │
│         // ... обработка ...                                     │
│         return processed;                                        │
│     }                                                            │
│                                                                  │
│     void saveResult(const std::string& result) override {        │
│         // Сохранение JSON                                       │
│         std::ofstream out("output.json");                       │
│         out << result;                                           │
│     }                                                            │
│ };                                                               │
└─────────────────────────────────────────────────────────────────┘
```

### 2. Реализация с хуками
```
┌─────────────────────────────────────────────────────────────────┐
│              РЕАЛИЗАЦИЯ С ХУКАМИ                              │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ class DataProcessorWithHooks {                                  │
│ public:                                                          │
│     virtual ~DataProcessorWithHooks() = default;                 │
│                                                                  │
│     // Шаблонный метод с хуками                                  │
│     void processData(const std::string& filename) {             │
│         // Хук: до открытия файла                               │
│         beforeOpenFile(filename);                               │
│                                                                  │
│         // 1. Открыть файл                                      │
│         std::ifstream file(filename);                           │
│         if (!file.is_open()) {                                  │
│             throw std::runtime_error("Cannot open file");       │
│         }                                                        │
│                                                                  │
│         // Хук: после открытия файла                             │
│         afterOpenFile(file);                                     │
│                                                                  │
│         // 2. Прочитать данные                                  │
│         std::string data = readData(file);                      │
│                                                                  │
│         // Хук: после чтения данных                              │
│         afterReadData(data);                                     │
│                                                                  │
│         // 3. Обработать данные                                 │
│         std::string processedData = processData(data);           │
│                                                                  │
│         // Хук: после обработки данных                           │
│         afterProcessData(processedData);                         │
│                                                                  │
│         // 4. Сохранить результат                               │
│         saveResult(processedData);                               │
│                                                                  │
│         // Хук: после сохранения результата                      │
│         afterSaveResult();                                       │
│                                                                  │
│         // 5. Закрыть файл                                      │
│         file.close();                                            │
│     }                                                            │
│                                                                  │
│     // Абстрактные методы                                        │
│     virtual std::string readData(std::ifstream& file) = 0;      │
│     virtual std::string processData(const std::string& data) = 0;│
│     virtual void saveResult(const std::string& result) = 0;     │
│                                                                  │
│     // Хуки (переопределяемые, но не обязательные)              │
│     virtual void beforeOpenFile(const std::string& filename) {}  │
│     virtual void afterOpenFile(std::ifstream& file) {}          │
│     virtual void afterReadData(const std::string& data) {}      │
│     virtual void afterProcessData(const std::string& data) {}   │
│     virtual void afterSaveResult() {}                           │
│ };                                                               │
└─────────────────────────────────────────────────────────────────┘
```

### 3. Реализация с шаблонами
```
┌─────────────────────────────────────────────────────────────────┐
│              РЕАЛИЗАЦИЯ С ШАБЛОНАМИ                           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ template<typename Derived>                                      │
│ class DataProcessorTemplate {                                   │
│ public:                                                          │
│     // Шаблонный метод                                           │
│     void processData(const std::string& filename) {             │
│         // 1. Открыть файл                                      │
│         std::ifstream file(filename);                           │
│         if (!file.is_open()) {                                  │
│             throw std::runtime_error("Cannot open file");       │
│         }                                                        │
│                                                                  │
│         // 2. Прочитать данные                                  │
│         std::string data = static_cast<Derived*>(this)->readData(file);│
│                                                                  │
│         // 3. Обработать данные                                 │
│         std::string processedData = static_cast<Derived*>(this)->processData(data);│
│                                                                  │
│         // 4. Сохранить результат                               │
│         static_cast<Derived*>(this)->saveResult(processedData); │
│                                                                  │
│         // 5. Закрыть файл                                      │
│         file.close();                                            │
│     }                                                            │
│                                                                  │
│     // Методы, которые должны быть реализованы в производном классе│
│     std::string readData(std::ifstream& file);                  │
│     std::string processData(const std::string& data);           │
│     void saveResult(const std::string& result);                 │
│ };                                                               │
│                                                                  │
│ // Конкретный класс                                              │
│ class CSVProcessor : public DataProcessorTemplate<CSVProcessor> {│
│ public:                                                          │
│     std::string readData(std::ifstream& file) {                 │
│         // Реализация чтения CSV                                │
│         return "CSV data";                                       │
│     }                                                            │
│                                                                  │
│     std::string processData(const std::string& data) {          │
│         // Реализация обработки CSV                             │
│         return "Processed CSV data";                            │
│     }                                                            │
│                                                                  │
│     void saveResult(const std::string& result) {                │
│         // Реализация сохранения CSV                            │
│         std::ofstream out("output.csv");                        │
│         out << result;                                           │
│     }                                                            │
│ };                                                               │
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 Сравнение подходов

```
┌─────────────────────────────────────────────────────────────────┐
│                    СРАВНЕНИЕ ПОДХОДОВ                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│   Классический  │   Хуки          │    Шаблоны      │   std::function │
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│ Простота        │ Средняя         │ Низкая          │ Высокая         │
│ Производительность│ Высокая        │ Высокая         │ Очень высокая   │
│ Безопасность    │ Высокая         │ Высокая         │ Высокая         │
│ Гибкость        │ Высокая         │ Очень высокая   │ Высокая         │
│ Тестируемость   │ Высокая         │ Высокая         │ Высокая         │
│ Применимость    │ Общие случаи    │ Сложные случаи  │ Простые случаи  │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

## 🎯 Когда использовать Template Method

```
┌─────────────────────────────────────────────────────────────────┐
│                КОГДА ИСПОЛЬЗОВАТЬ TEMPLATE METHOD              │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Data Processing │ • Обработка данных с разными форматами        │
│                 │ • Единый алгоритм с разными реализациями      │
│                 │ • Сохранение структуры алгоритма             │
├─────────────────┼───────────────────────────────────────────────┤
│ Game Engines    │ • Игровые циклы с разными реализациями       │
│                 │ • Обработка событий                          │
│                 │ • Рендеринг с разными техниками              │
├─────────────────┼───────────────────────────────────────────────┤
│ Web Frameworks  │ • Обработка HTTP запросов                    │
│                 │ • Middleware цепочки                        │
│                 │ • Аутентификация и авторизация               │
├─────────────────┼───────────────────────────────────────────────┤
│ Compilers       │ • Компиляция с разными оптимизациями         │
│                 │ • Парсинг с разными грамматиками             │
│                 │ • Генерация кода для разных платформ        │
├─────────────────┼───────────────────────────────────────────────┤
│ Testing         │ • Тестовые фреймворки                        │
│                 │ • Setup и teardown логика                    │
│                 │ • Разные типы тестов                         │
└─────────────────┴───────────────────────────────────────────────┘

❌ ПЛОХИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Простые случаи  │ • Когда алгоритм не меняется                 │
│                 │ • Когда нет необходимости в гибкости          │
├─────────────────┼───────────────────────────────────────────────┤
│ Производительность│ • Когда критична производительность          │
│                 │ • Когда накладные расходы недопустимы         │
├─────────────────┼───────────────────────────────────────────────┤
│ Сложность       │ • Когда усложнение не оправдано              │
│                 │ • Когда можно использовать простые решения    │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🧪 Тестирование Template Method

```
┌─────────────────────────────────────────────────────────────────┐
│                    ТЕСТИРОВАНИЕ TEMPLATE METHOD               │
└─────────────────────────────────────────────────────────────────┘

Тестирование шаблонного метода:
┌─────────────────────────────────────────────────────────────────┐
│ TEST(TemplateMethodTest, DataProcessor) {                     │
│     CSVProcessor processor;                                     │
│     std::string filename = "test.csv";                         │
│                                                                 │
│     // Тест обработки данных                                   │
│     EXPECT_NO_THROW(processor.processData(filename));         │
│                                                                 │
│     // Проверяем, что файл был обработан                      │
│     std::ifstream file("output.csv");                          │
│     EXPECT_TRUE(file.is_open());                               │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘

Тестирование примитивных методов:
┌─────────────────────────────────────────────────────────────────┐
│ TEST(TemplateMethodTest, PrimitiveMethods) {                   │
│     CSVProcessor processor;                                     │
│     std::ifstream file("test.csv");                            │
│                                                                 │
│     // Тест чтения данных                                       │
│     std::string data = processor.readData(file);               │
│     EXPECT_FALSE(data.empty());                                │
│                                                                 │
│     // Тест обработки данных                                    │
│     std::string processed = processor.processData(data);       │
│     EXPECT_FALSE(processed.empty());                           │
│                                                                 │
│     // Тест сохранения результата                              │
│     EXPECT_NO_THROW(processor.saveResult(processed));         │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘

Тестирование с моками:
┌─────────────────────────────────────────────────────────────────┐
│ TEST(TemplateMethodTest, WithMocks) {                          │
│     MockDataProcessor processor;                               │
│     std::string filename = "test.csv";                         │
│                                                                 │
│     // Настраиваем ожидания                                     │
│     EXPECT_CALL(processor, readData(_))                        │
│         .WillOnce(Return("test data"));                        │
│     EXPECT_CALL(processor, processData("test data"))          │
│         .WillOnce(Return("processed data"));                  │
│     EXPECT_CALL(processor, saveResult("processed data"))       │
│         .Times(1);                                              │
│                                                                 │
│     // Выполняем тест                                           │
│     processor.processData(filename);                            │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

## 🔗 Связь с другими паттернами

```
┌─────────────────────────────────────────────────────────────────┐
│              СВЯЗЬ С ДРУГИМИ ПАТТЕРНАМИ                        │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│ Strategy        │ • Template Method - структура алгоритма      │
│                 │ • Strategy - выбор алгоритма                  │
│                 │ • Template Method - неизменяемая структура   │
│                 │ • Strategy - изменяемый алгоритм             │
├─────────────────┼───────────────────────────────────────────────┤
│ Factory Method  │ • Template Method может использовать Factory │
│                 │ • Создание объектов в шаблонном методе        │
│                 │ • Инкапсуляция создания                      │
├─────────────────┼───────────────────────────────────────────────┤
│ Command         │ • Template Method может использовать Command│
│                 │ • Инкапсуляция операций в шаблонном методе   │
│                 │ • Отложенное выполнение                      │
├─────────────────┼───────────────────────────────────────────────┤
│ Observer        │ • Template Method может использовать Observer│
│                 │ • Уведомления о выполнении шагов             │
│                 │ • Отслеживание прогресса                     │
└─────────────────┴───────────────────────────────────────────────┘
```

## 💡 Практические рекомендации

```
┌─────────────────────────────────────────────────────────────────┐
│                  ПРАКТИЧЕСКИЕ РЕКОМЕНДАЦИИ                     │
└─────────────────────────────────────────────────────────────────┘

1. 🎯 Выбор реализации:
   • Классическая - для общих случаев
   • Хуки - для сложных случаев
   • Шаблоны - для производительности
   • std::function - для простых случаев

2. 🔧 Принципы проектирования:
   • Слабая связанность между шаблонным методом и примитивами
   • Абстракция через интерфейсы
   • Инкапсуляция алгоритма
   • Разделение ответственности

3. 🧪 Тестирование:
   • Тестируйте шаблонный метод как единое целое
   • Тестируйте каждый примитивный метод отдельно
   • Используйте моки для изоляции тестов
   • Тестируйте с разными реализациями

4. ⚠️ Типичные ошибки:
   • Создание слишком сложного шаблонного метода
   • Игнорирование производительности
   • Неправильное управление состоянием
   • Отсутствие валидации входных данных

5. 📚 Лучшие практики:
   • Используйте RAII для управления ресурсами
   • Применяйте move semantics
   • Документируйте алгоритм
   • Рассмотрите асинхронное выполнение

6. 🚀 Оптимизация:
   • Кэшируйте часто используемые результаты
   • Используйте move semantics
   • Рассмотрите compile-time оптимизации
   • Профилируйте критические участки
```

## 🎓 Ключевые выводы

```
┌─────────────────────────────────────────────────────────────────┐
│                      КЛЮЧЕВЫЕ ВЫВОДЫ                          │
└─────────────────────────────────────────────────────────────────┘

✅ Template Method - мощный паттерн для алгоритмов:
   • Определение скелета алгоритма в базовом классе
   • Переопределение отдельных шагов в подклассах
   • Соблюдение DRY принципа
   • Сохранение структуры алгоритма

✅ Выбирайте подходящую реализацию:
   • Классическая - общие случаи
   • Хуки - сложные случаи
   • Шаблоны - производительность
   • std::function - простые случаи

✅ Используйте правильно:
   • Когда есть общий алгоритм с разными реализациями
   • Для соблюдения DRY принципа
   • Когда структура алгоритма не должна меняться
   • Для упрощения поддержки

✅ Избегайте злоупотребления:
   • Не используйте для простых случаев
   • Не создавайте слишком сложный шаблонный метод
   • Не игнорируйте производительность
   • Не забывайте об управлении ресурсами

✅ Интеграция с паттернами:
   • Альтернатива Strategy
   • Комбинация с Factory Method
   • Использование в Command
   • Основа для Observer
```

---
*Template Method Pattern - это ключ к структуре и гибкости. Используйте его для создания надежных и расширяемых алгоритмов!*
