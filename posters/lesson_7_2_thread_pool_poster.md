# 📊 Плакат: Thread Pool Pattern

## 🎯 Концепция Thread Pool

```
┌─────────────────────────────────────────────────────────────────┐
│                    THREAD POOL PATTERN                         │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  🔧 ПУЛ ПОТОКОВ ДЛЯ ЭФФЕКТИВНОГО ВЫПОЛНЕНИЯ ЗАДАЧ            │
│  ⚡ ПЕРЕИСПОЛЬЗОВАНИЕ ПОТОКОВ                                  │
│  📊 УПРАВЛЕНИЕ ПАРАЛЛЕЛИЗМОМ                                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   ПРОБЛЕМА      │  • Создание потока - дорогая операция         │
│                 │  • Неограниченные потоки → перегрузка системы │
│                 │  • Сложное управление жизненным циклом        │
├─────────────────┼───────────────────────────────────────────────┤
│   РЕШЕНИЕ       │  • Заранее создать пул потоков                │
│                 │  • Очередь задач для обработки                │
│                 │  • Переиспользование потоков                  │
│                 │  • Контролируемый параллелизм                 │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🏗️ Архитектура Thread Pool

```
┌─────────────────────────────────────────────────────────────────┐
│                   КОМПОНЕНТЫ THREAD POOL                       │
└─────────────────────────────────────────────────────────────────┘

    ┌──────────────────────────────────────────────────────┐
    │              THREAD POOL MANAGER                     │
    │  ┌────────────────────────────────────────────────┐  │
    │  │         TASK QUEUE (Очередь задач)             │  │
    │  │  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐         │  │
    │  │  │Task 1│→│Task 2│→│Task 3│→│Task 4│→ ...     │  │
    │  │  └──────┘ └──────┘ └──────┘ └──────┘         │  │
    │  └────────────────────────────────────────────────┘  │
    │                        ↓                              │
    │  ┌────────────────────────────────────────────────┐  │
    │  │         WORKER THREADS (Рабочие потоки)        │  │
    │  │  ┌────────┐ ┌────────┐ ┌────────┐            │  │
    │  │  │Worker 1│ │Worker 2│ │Worker 3│ ...        │  │
    │  │  │  BUSY  │ │  IDLE  │ │  BUSY  │            │  │
    │  │  └────────┘ └────────┘ └────────┘            │  │
    │  └────────────────────────────────────────────────┘  │
    │                        ↓                              │
    │  ┌────────────────────────────────────────────────┐  │
    │  │         STATISTICS & MONITORING                │  │
    │  │  • Active threads: 2/4                         │  │
    │  │  • Queue size: 5                                │  │
    │  │  • Tasks completed: 1523                       │  │
    │  │  • Avg wait time: 12ms                         │  │
    │  └────────────────────────────────────────────────┘  │
    └──────────────────────────────────────────────────────┘
```

## 🔄 Жизненный цикл задачи

```
┌─────────────────────────────────────────────────────────────────┐
│              ЖИЗНЕННЫЙ ЦИКЛ ЗАДАЧИ В THREAD POOL               │
└─────────────────────────────────────────────────────────────────┘

1. SUBMIT          2. ENQUEUE         3. WAIT           4. EXECUTE
┌──────────┐      ┌──────────┐      ┌──────────┐      ┌──────────┐
│ Клиент   │      │ Задача   │      │ Задача в │      │ Поток    │
│ отправ-  │ ───> │ добав-   │ ───> │ очереди  │ ───> │ выполняет│
│ ляет     │      │ лена в   │      │ ожидает  │      │ задачу   │
│ задачу   │      │ очередь  │      │ потока   │      │          │
└──────────┘      └──────────┘      └──────────┘      └──────────┘
     ↓                                                       ↓
     └──────────────────────────────────────────────────────┘
                    5. COMPLETE
                   ┌──────────┐
                   │ Результат│
                   │ возвра-  │
                   │ щается   │
                   └──────────┘
```

## ⚡ Типы Thread Pool

```
┌─────────────────────────────────────────────────────────────────┐
│                     ВИДЫ THREAD POOL                           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬─────────────────┬─────────────────┬───────────┐
│  FIXED POOL     │  CACHED POOL    │  SCHEDULED POOL │ WORK STEAL│
├─────────────────┼─────────────────┼─────────────────┼───────────┤
│ • Фиксированное │ • Динамическое  │ • Отложенное    │ • Балан-  │
│   кол-во        │   создание      │   выполнение    │   сировка │
│   потоков       │   потоков       │ • Периодические │   нагрузки│
│ • Простая       │ • Автомасшта-   │   задачи        │ • Кража   │
│   реализация    │   бирование     │ • Таймеры       │   работы  │
│ • Предсказуемый │ • Адаптивный    │ • Scheduling    │ • Высокая │
│   ресурс CPU    │   к нагрузке    │                 │   эффект. │
└─────────────────┴─────────────────┴─────────────────┴───────────┘
```

## 🔥 Work Stealing Algorithm

```
┌─────────────────────────────────────────────────────────────────┐
│                   WORK STEALING (Кража работы)                 │
└─────────────────────────────────────────────────────────────────┘

┌──────────────────┐    ┌──────────────────┐    ┌──────────────────┐
│   Worker 1       │    │   Worker 2       │    │   Worker 3       │
│  Local Queue     │    │  Local Queue     │    │  Local Queue     │
│ ┌──┐┌──┐┌──┐┌──┐│    │ ┌──┐┌──┐        │    │ (Empty)          │
│ │T1││T2││T3││T4││    │ │T5││T6│        │    │                  │
│ └──┘└──┘└──┘└──┘│    │ └──┘└──┘        │    │                  │
└──────────────────┘    └──────────────────┘    └──────────────────┘
       BUSY                   BUSY                    IDLE
                                                       ↓
                                                 [Ищет работу]
                                                       ↓
┌──────────────────────────────────────────────────────────────────┐
│  Worker 3 "крадет" половину задач у самого загруженного Worker 1│
└──────────────────────────────────────────────────────────────────┘
                                                       ↓
┌──────────────────┐    ┌──────────────────┐    ┌──────────────────┐
│   Worker 1       │    │   Worker 2       │    │   Worker 3       │
│ ┌──┐┌──┐        │    │ ┌──┐┌──┐        │    │ ┌──┐┌──┐        │
│ │T1││T2│        │    │ │T5││T6│        │    │ │T3││T4│        │
│ └──┘└──┘        │    │ └──┘└──┘        │    │ └──┘└──┘        │
└──────────────────┘    └──────────────────┘    └──────────────────┘
  Балансировка нагрузки ✅
```

## 💡 Сравнение подходов

```
┌─────────────────────────────────────────────────────────────────┐
│               БЕЗ THREAD POOL vs С THREAD POOL                 │
└─────────────────────────────────────────────────────────────────┘

❌ БЕЗ THREAD POOL (Создание потока на каждую задачу):
┌─────────────────────────────────────────────────────────────────┐
│ for (int i = 0; i < 1000; ++i) {                               │
│     std::thread t([i]() {                                       │
│         processTask(i);  // Создание потока ~ 1-2 ms          │
│     });                                                         │
│     t.detach();  // 1000 потоков → перегрузка системы!        │
│ }                                                               │
│                                                                 │
│ ⚠️ ПРОБЛЕМЫ:                                                   │
│  • Огромные накладные расходы на создание потоков             │
│  • Перегрузка планировщика ОС                                  │
│  • Неконтролируемое потребление памяти                        │
│  • Context switching overhead                                  │
└─────────────────────────────────────────────────────────────────┘

✅ С THREAD POOL:
┌─────────────────────────────────────────────────────────────────┐
│ ThreadPool pool(std::thread::hardware_concurrency());          │
│                                                                 │
│ std::vector<std::future<void>> futures;                        │
│ for (int i = 0; i < 1000; ++i) {                              │
│     futures.push_back(pool.enqueue([i]() {                     │
│         processTask(i);                                         │
│     }));                                                        │
│ }                                                               │
│                                                                 │
│ for (auto& f : futures) {                                      │
│     f.get();  // Дождаться завершения                          │
│ }                                                               │
│                                                                 │
│ ✅ ПРЕИМУЩЕСТВА:                                               │
│  • Фиксированное количество потоков                           │
│  • Переиспользование потоков (нет overhead)                   │
│  • Контролируемое потребление ресурсов                        │
│  • Эффективное использование CPU                               │
└─────────────────────────────────────────────────────────────────┘
```

## 🔧 Реализация с std::future и std::promise

```
┌─────────────────────────────────────────────────────────────────┐
│              АСИНХРОННЫЙ THREAD POOL С FUTURE                  │
└─────────────────────────────────────────────────────────────────┘

template<typename F, typename... Args>
auto ThreadPool::enqueue(F&& f, Args&&... args) 
    -> std::future<typename std::result_of<F(Args...)>::type> {
    
    using return_type = typename std::result_of<F(Args...)>::type;
    
    // Создаем packaged_task для получения future
    auto task = std::make_shared<std::packaged_task<return_type()>>(
        std::bind(std::forward<F>(f), std::forward<Args>(args)...)
    );
    
    // Получаем future для результата
    std::future<return_type> result = task->get_future();
    
    // Добавляем задачу в очередь
    {
        std::unique_lock<std::mutex> lock(queue_mutex_);
        
        if (stop_) {
            throw std::runtime_error("enqueue on stopped ThreadPool");
        }
        
        tasks_.emplace([task]() { (*task)(); });
    }
    
    // Уведомляем один поток
    condition_.notify_one();
    
    return result;  // Возвращаем future
}

┌─────────────────────────────────────────────────────────────────┐
│ ИСПОЛЬЗОВАНИЕ:                                                  │
│                                                                 │
│ auto future = pool.enqueue([]() {                              │
│     return 42;                                                  │
│ });                                                             │
│                                                                 │
│ int result = future.get();  // Блокируется до завершения       │
└─────────────────────────────────────────────────────────────────┘
```

## ⚠️ Проблемы и решения

```
┌─────────────────────────────────────────────────────────────────┐
│                  ТИПИЧНЫЕ ПРОБЛЕМЫ И РЕШЕНИЯ                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   DEADLOCK      │  РЕШЕНИЕ:                                     │
│                 │  • Избегать захвата нескольких mutex          │
│   Task A        │  • Использовать std::scoped_lock              │
│   ждет Task B   │  • Упорядочить захват locks                   │
│   Task B        │  • Timeout для захвата                        │
│   ждет Task A   │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   STARVATION    │  РЕШЕНИЕ:                                     │
│                 │  • Приоритетная очередь                       │
│   Низкоприори-  │  • Fair scheduling                            │
│   тетные задачи │  • Age-based priority boost                  │
│   не выполняются│  • Work stealing для балансировки             │
├─────────────────┼───────────────────────────────────────────────┤
│   QUEUE         │  РЕШЕНИЕ:                                     │
│   OVERFLOW      │  • Bounded queue с ограничением               │
│                 │  • Backpressure механизм                      │
│   Задачи        │  • Отклонение новых задач                     │
│   добавляются   │  • Приоритетное вытеснение                    │
│   быстрее чем   │                                               │
│   выполняются   │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   EXCEPTION     │  РЕШЕНИЕ:                                     │
│   HANDLING      │  • try-catch в worker threads                 │
│                 │  • std::future для передачи исключений        │
│   Исключение в  │  • Логирование ошибок                         │
│   задаче убивает│  • Graceful degradation                       │
│   поток         │                                               │
└─────────────────┴───────────────────────────────────────────────┘
```

## 📊 Метрики и мониторинг

```
┌─────────────────────────────────────────────────────────────────┐
│                   КЛЮЧЕВЫЕ МЕТРИКИ                             │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  📈 ПРОИЗВОДИТЕЛЬНОСТЬ                                          │
│  • Throughput: задач/сек                                        │
│  • Latency: время обработки задачи                              │
│  • Queue wait time: время в очереди                             │
│  • CPU utilization: использование CPU                           │
├─────────────────────────────────────────────────────────────────┤
│  🔄 УТИЛИЗАЦИЯ РЕСУРСОВ                                         │
│  • Active threads: активных потоков                             │
│  • Idle threads: простаивающих потоков                          │
│  • Queue size: размер очереди                                   │
│  • Thread pool saturation: насыщение пула                       │
├─────────────────────────────────────────────────────────────────┤
│  ⚠️ ПРОБЛЕМНЫЕ СИТУАЦИИ                                         │
│  • Task rejection rate: процент отклоненных задач               │
│  • Thread creation rate: частота создания потоков               │
│  • Exception rate: частота исключений                           │
│  • Deadlock detection: обнаружение дедлоков                     │
└─────────────────────────────────────────────────────────────────┘
```

## 🎓 Best Practices

```
┌─────────────────────────────────────────────────────────────────┐
│                      ЛУЧШИЕ ПРАКТИКИ                           │
└─────────────────────────────────────────────────────────────────┘

✅ DO (Рекомендуется):
┌─────────────────────────────────────────────────────────────────┐
│ 1. Размер пула = std::thread::hardware_concurrency()           │
│    • Оптимальное использование CPU                              │
│                                                                 │
│ 2. Использовать std::future для результатов                     │
│    • Безопасная передача результатов и исключений               │
│                                                                 │
│ 3. Graceful shutdown                                            │
│    pool.shutdown();  // Завершить существующие задачи          │
│                                                                 │
│ 4. Exception handling в задачах                                 │
│    try { task(); } catch (...) { log_error(); }                │
│                                                                 │
│ 5. Bounded queue для контроля памяти                            │
│    if (queue.size() > MAX_SIZE) reject_task();                 │
└─────────────────────────────────────────────────────────────────┘

❌ DON'T (Не рекомендуется):
┌─────────────────────────────────────────────────────────────────┐
│ 1. НЕ блокировать потоки на долго                              │
│    ❌ while (!data_ready) sleep(1s);  // Блокирует поток       │
│                                                                 │
│ 2. НЕ создавать слишком много потоков                          │
│    ❌ ThreadPool(1000);  // Слишком много!                     │
│                                                                 │
│ 3. НЕ забывать про cleanup                                      │
│    ❌ delete pool;  // Без shutdown!                           │
│                                                                 │
│ 4. НЕ игнорировать исключения                                   │
│    ❌ catch (...) {}  // Молчаливое игнорирование              │
│                                                                 │
│ 5. НЕ использовать unbounded queue                              │
│    ❌ std::queue<Task> tasks_;  // Может расти бесконечно      │
└─────────────────────────────────────────────────────────────────┘
```

## 🚀 Когда использовать Thread Pool

```
┌─────────────────────────────────────────────────────────────────┐
│                    КОГДА ИСПОЛЬЗОВАТЬ                          │
└─────────────────────────────────────────────────────────────────┘

✅ ПОДХОДИТ ДЛЯ:
  • Обработка HTTP запросов в веб-сервере
  • Параллельная обработка файлов
  • Batch processing задач
  • CPU-bound задачи с коротким временем выполнения
  • Асинхронная обработка событий

❌ НЕ ПОДХОДИТ ДЛЯ:
  • Очень длительные задачи (блокируют пул)
  • I/O-bound задачи с долгим ожиданием
  • Задачи с зависимостями (риск deadlock)
  • Real-time системы с жесткими SLA
  • Одна огромная задача (нет параллелизма)
```

## 📚 Связанные паттерны

```
┌─────────────────────────────────────────────────────────────────┐
│                   СВЯЗАННЫЕ ПАТТЕРНЫ                           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│  Actor Model    │  • Message-based параллелизм                  │
│                 │  • Изолированное состояние                    │
│                 │  • Может использовать Thread Pool внутри      │
├─────────────────┼───────────────────────────────────────────────┤
│  Reactor        │  • Event-driven архитектура                   │
│                 │  • Event loop + handler threads               │
│                 │  • Thread Pool для обработки событий          │
├─────────────────┼───────────────────────────────────────────────┤
│  Producer-      │  • Разделение производителей и потребителей   │
│  Consumer       │  • Thread Pool может быть потребителем        │
│                 │  • Bounded buffer для задач                   │
└─────────────────┴───────────────────────────────────────────────┘
```

---

**Автор**: Senior C++ Developer  
**Дата**: 2025-10-07  
**Версия**: 1.0
