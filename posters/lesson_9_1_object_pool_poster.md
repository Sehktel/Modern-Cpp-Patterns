# 📊 Плакат: Object Pool Pattern

## 🎯 Концепция Object Pool

```
┌─────────────────────────────────────────────────────────────────┐
│                    OBJECT POOL PATTERN                         │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  ♻️ ПЕРЕИСПОЛЬЗОВАНИЕ ДОРОГИХ ОБЪЕКТОВ                         │
│  ⚡ УСТРАНЕНИЕ НАКЛАДНЫХ РАСХОДОВ НА СОЗДАНИЕ/УНИЧТОЖЕНИЕ     │
│  🎯 КОНТРОЛЬ НАД КОЛИЧЕСТВОМ ОБЪЕКТОВ                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   ПРОБЛЕМА      │  • Создание объекта дорого (DB connections)   │
│                 │  • Уничтожение требует ресурсов               │
│                 │  • Частое выделение/освобождение памяти       │
│                 │  • Memory fragmentation                       │
├─────────────────┼───────────────────────────────────────────────┤
│   РЕШЕНИЕ       │  • Пул заранее созданных объектов             │
│                 │  • Переиспользование вместо создания          │
│                 │  • Возврат объектов в пул после использования │
│                 │  • Амортизация стоимости создания             │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🏗️ Архитектура Object Pool

```
┌─────────────────────────────────────────────────────────────────┐
│                   КОМПОНЕНТЫ OBJECT POOL                       │
└─────────────────────────────────────────────────────────────────┘

    ┌────────────────────────────────────────────────┐
    │           OBJECT POOL MANAGER                  │
    │                                                │
    │  ┌──────────────────────────────────────────┐ │
    │  │      AVAILABLE OBJECTS (Свободные)       │ │
    │  │  ┌────┐ ┌────┐ ┌────┐ ┌────┐           │ │
    │  │  │Obj1│ │Obj2│ │Obj3│ │Obj4│ ...       │ │
    │  │  └────┘ └────┘ └────┘ └────┘           │ │
    │  └──────────────────────────────────────────┘ │
    │                                                │
    │  ┌──────────────────────────────────────────┐ │
    │  │      IN-USE OBJECTS (Используются)       │ │
    │  │  ┌────┐ ┌────┐                           │ │
    │  │  │Obj5│ │Obj6│                           │ │
    │  │  └────┘ └────┘                           │ │
    │  └──────────────────────────────────────────┘ │
    │                                                │
    │  Capacity: 10 objects                          │
    │  Available: 4 objects                          │
    │  In-Use: 2 objects                             │
    └────────────────────────────────────────────────┘
              ↑               ↓
          acquire()      release()
              │               │
    ┌─────────────────────────────────────┐
    │         CLIENT CODE                 │
    │  auto obj = pool.acquire();         │
    │  obj->doWork();                     │
    │  pool.release(obj);                 │
    └─────────────────────────────────────┘
```

## 🔄 Жизненный цикл объекта

```
┌─────────────────────────────────────────────────────────────────┐
│              ЖИЗНЕННЫЙ ЦИКЛ ОБЪЕКТА В POOL                     │
└─────────────────────────────────────────────────────────────────┘

1. CREATION        2. READY           3. ACQUIRED        4. IN-USE
┌──────────┐      ┌──────────┐      ┌──────────┐      ┌──────────┐
│ Объект   │      │ Объект в │      │ Клиент   │      │ Клиент   │
│ создается│ ───> │ пуле     │ ───> │ получил  │ ───> │ использ- │
│ при init │      │ ждет     │      │ объект   │      │ ует      │
│ пула     │      │          │      │          │      │ объект   │
└──────────┘      └──────────┘      └──────────┘      └──────────┘
                       ↑                                     │
                       │                                     │
                       └─────────────────────────────────────┘
                              5. RELEASED
                           ┌──────────┐
                           │ Объект   │
                           │ возвращен│
                           │ в пул    │
                           │ (reset)  │
                           └──────────┘
```

## ⚡ Типы Object Pool

```
┌─────────────────────────────────────────────────────────────────┐
│                     ВИДЫ OBJECT POOL                           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬─────────────────┬─────────────────┬───────────┐
│  FIXED SIZE     │  DYNAMIC SIZE   │  LAZY INIT      │ EXPIRE    │
├─────────────────┼─────────────────┼─────────────────┼───────────┤
│ • Фиксирован-   │ • Растет по     │ • Создает по    │ • Объекты │
│   ный размер    │   требованию    │   мере надобно- │   истекают│
│   при init      │ • Может         │   сти           │ • TTL     │
│ • Простая       │   сокращаться   │ • Минимальный   │ • Освобож-│
│   реализация    │ • Адаптивный    │   начальный     │   дение   │
│ • Предсказуемый │   к нагрузке    │   overhead      │   старых  │
│   расход памяти │ • Сложнее       │ • Pay-as-you-go │ • Обновл. │
│                 │   управление    │                 │   объектов│
└─────────────────┴─────────────────┴─────────────────┴───────────┘

ПРИМЕРЫ:
• DB Connection Pool (fixed/dynamic)
• Thread Pool (fixed)
• Memory Pool (fixed, pre-allocated)
• HTTP Client Pool (dynamic, with TTL)
```

## 💡 Сравнение подходов

```
┌─────────────────────────────────────────────────────────────────┐
│         БЕЗ OBJECT POOL vs С OBJECT POOL                       │
└─────────────────────────────────────────────────────────────────┘

❌ БЕЗ OBJECT POOL (Создание каждый раз):
┌─────────────────────────────────────────────────────────────────┐
│ for (int i = 0; i < 1000; ++i) {                               │
│     // Создание DB connection ~ 100ms!                          │
│     auto conn = std::make_unique<DatabaseConnection>(           │
│         "host", "user", "password");                            │
│                                                                 │
│     conn->query("SELECT * FROM users");                         │
│                                                                 │
│     // Уничтожение connection ~ 50ms                            │
│ }  // ← Каждая итерация: 150ms overhead!                       │
│                                                                 │
│ Итого: 1000 * 150ms = 150 секунд на overhead! 😱              │
│                                                                 │
│ ⚠️ ПРОБЛЕМЫ:                                                   │
│  • Огромные накладные расходы на создание/уничтожение         │
│  • Медленная работа программы                                  │
│  • Memory fragmentation от частых new/delete                   │
│  • Overhead на системные вызовы (socket, connect)              │
└─────────────────────────────────────────────────────────────────┘

✅ С OBJECT POOL:
┌─────────────────────────────────────────────────────────────────┐
│ // Создаем пул один раз при старте                             │
│ ConnectionPool pool(10);  // 10 connections, init ~ 1 second   │
│                                                                 │
│ for (int i = 0; i < 1000; ++i) {                              │
│     // Получение connection из пула ~ 0.1ms                    │
│     auto conn = pool.acquire();                                 │
│                                                                 │
│     conn->query("SELECT * FROM users");                         │
│                                                                 │
│     pool.release(conn);  // Возврат в пул ~ 0.05ms            │
│ }  // ← Каждая итерация: 0.15ms overhead                       │
│                                                                 │
│ Итого: 1 sec (init) + 1000 * 0.15ms = 1.15 секунд            │
│                                                                 │
│ ✅ ПРЕИМУЩЕСТВА:                                               │
│  • 130x ускорение! (150s → 1.15s)                             │
│  • Переиспользование объектов                                  │
│  • Нет memory fragmentation                                    │
│  • Минимальные системные вызовы                                │
│  • Контролируемое потребление ресурсов                        │
└─────────────────────────────────────────────────────────────────┘
```

## 🔧 Реализация Generic Object Pool

```
┌─────────────────────────────────────────────────────────────────┐
│              GENERIC OBJECT POOL IMPLEMENTATION                │
└─────────────────────────────────────────────────────────────────┘

template<typename T>
class ObjectPool {
private:
    std::queue<std::unique_ptr<T>> available_;
    std::unordered_set<T*> in_use_;
    std::mutex mutex_;
    size_t capacity_;
    
    // Фабрика для создания объектов
    std::function<std::unique_ptr<T>()> factory_;
    
    // Функция сброса объекта перед возвратом в пул
    std::function<void(T*)> reset_func_;
    
public:
    ObjectPool(size_t capacity, 
               std::function<std::unique_ptr<T>()> factory,
               std::function<void(T*)> reset = nullptr)
        : capacity_(capacity), 
          factory_(std::move(factory)),
          reset_func_(std::move(reset)) {
        
        // Предварительное создание объектов
        for (size_t i = 0; i < capacity_; ++i) {
            available_.push(factory_());
        }
    }
    
    // Получение объекта из пула
    std::unique_ptr<T, std::function<void(T*)>> acquire() {
        std::lock_guard<std::mutex> lock(mutex_);
        
        if (available_.empty()) {
            throw std::runtime_error("Pool exhausted");
        }
        
        auto obj = std::move(available_.front());
        available_.pop();
        
        T* ptr = obj.get();
        in_use_.insert(ptr);
        
        // Возвращаем unique_ptr с custom deleter
        // который возвращает объект в пул
        return std::unique_ptr<T, std::function<void(T*)>>(
            obj.release(),
            [this](T* p) { this->release(p); }
        );
    }
    
private:
    void release(T* obj) {
        std::lock_guard<std::mutex> lock(mutex_);
        
        // Проверяем что объект был взят из пула
        if (in_use_.erase(obj) == 0) {
            return;  // Объект не из этого пула
        }
        
        // Сбрасываем состояние объекта
        if (reset_func_) {
            reset_func_(obj);
        }
        
        // Возвращаем в пул
        available_.push(std::unique_ptr<T>(obj));
    }
};

ИСПОЛЬЗОВАНИЕ:
┌─────────────────────────────────────────────────────────────────┐
│ // Создаем пул DB connections                                   │
│ ObjectPool<DatabaseConnection> pool(                            │
│     10,  // capacity                                            │
│     []() { return std::make_unique<DatabaseConnection>(...); }, │
│     [](auto* conn) { conn->reset(); }  // reset function       │
│ );                                                              │
│                                                                 │
│ // Используем                                                   │
│ {                                                               │
│     auto conn = pool.acquire();                                 │
│     conn->query("SELECT * FROM users");                         │
│ }  // ← Автоматически возвращается в пул при выходе из scope  │
└─────────────────────────────────────────────────────────────────┘
```

## 🎯 RAII Wrapper для Pool

```
┌─────────────────────────────────────────────────────────────────┐
│              RAII WRAPPER (PoolGuard)                          │
└─────────────────────────────────────────────────────────────────┘

template<typename T>
class PoolGuard {
private:
    T* object_;
    std::function<void(T*)> releaser_;
    
public:
    PoolGuard(T* obj, std::function<void(T*)> releaser)
        : object_(obj), releaser_(std::move(releaser)) {}
    
    ~PoolGuard() {
        if (object_ && releaser_) {
            releaser_(object_);
        }
    }
    
    // Запрещаем копирование
    PoolGuard(const PoolGuard&) = delete;
    PoolGuard& operator=(const PoolGuard&) = delete;
    
    // Разрешаем перемещение
    PoolGuard(PoolGuard&& other) noexcept
        : object_(other.object_), 
          releaser_(std::move(other.releaser_)) {
        other.object_ = nullptr;
    }
    
    T* get() { return object_; }
    T* operator->() { return object_; }
    T& operator*() { return *object_; }
};

ИСПОЛЬЗОВАНИЕ:
┌─────────────────────────────────────────────────────────────────┐
│ auto guard = pool.acquireGuard();                               │
│ guard->doWork();                                                │
│ // Автоматический возврат в пул при уничтожении guard          │
└─────────────────────────────────────────────────────────────────┘
```

## ⚠️ Проблемы и решения

```
┌─────────────────────────────────────────────────────────────────┐
│                  ТИПИЧНЫЕ ПРОБЛЕМЫ И РЕШЕНИЯ                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│   POOL          │  РЕШЕНИЕ:                                     │
│   EXHAUSTION    │  • Bounded waiting с timeout                  │
│                 │  • Dynamic pool expansion                     │
│   Все объекты   │  • Monitoring и alerts                        │
│   заняты, новые │  • Graceful degradation                       │
│   запросы ждут  │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   OBJECT LEAK   │  РЕШЕНИЕ:                                     │
│                 │  • RAII wrapper (auto-return)                 │
│   Объект не     │  • Weak pointer tracking                      │
│   возвращен в   │  • Timeout для in-use objects                 │
│   пул           │  • Debug mode с leak detection                │
├─────────────────┼───────────────────────────────────────────────┤
│   STATE         │  РЕШЕНИЕ:                                     │
│   POLLUTION     │  • Reset function для очистки состояния       │
│                 │  • Validation перед возвратом в пул           │
│   Объект        │  • Immutable objects где возможно             │
│   возвращен с   │  • State machine для отслеживания             │
│   грязным       │                                               │
│   состоянием    │                                               │
├─────────────────┼───────────────────────────────────────────────┤
│   MEMORY        │  РЕШЕНИЕ:                                     │
│   OVERHEAD      │  • Lazy initialization                        │
│                 │  • Dynamic resizing (grow/shrink)             │
│   Пул слишком   │  • Soft/hard limits                           │
│   большой,      │  • Expiration policy                          │
│   объекты не    │                                               │
│   используются  │                                               │
└─────────────────┴───────────────────────────────────────────────┘
```

## 📊 Метрики и мониторинг

```
┌─────────────────────────────────────────────────────────────────┐
│                   КЛЮЧЕВЫЕ МЕТРИКИ POOL                        │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  📈 УТИЛИЗАЦИЯ                                                  │
│  • Pool size: текущий размер пула                               │
│  • Available objects: свободных объектов                        │
│  • In-use objects: используемых объектов                        │
│  • Utilization rate: % занятости пула                           │
│  • Peak usage: пиковая нагрузка                                 │
├─────────────────────────────────────────────────────────────────┤
│  ⏱️ ПРОИЗВОДИТЕЛЬНОСТЬ                                          │
│  • Acquire latency: время получения объекта                     │
│  • Wait time: время ожидания когда пул полон                    │
│  • Object creation time: время создания объекта                 │
│  • Release latency: время возврата в пул                        │
├─────────────────────────────────────────────────────────────────┤
│  ⚠️ ПРОБЛЕМЫ                                                    │
│  • Pool exhaustion count: сколько раз пул исчерпан              │
│  • Leaked objects: объекты не возвращенные в пул                │
│  • Failed acquisitions: неудачные попытки получения             │
│  • Reset failures: ошибки при сбросе объекта                    │
└─────────────────────────────────────────────────────────────────┘

ALERTS:
⚠️  Pool utilization > 90% for > 5 minutes
⚠️  Average wait time > 1 second
⚠️  Leaked objects > 10% of pool size
⚠️  Pool exhaustion rate > 1% of requests
```

## 🎓 Best Practices

```
┌─────────────────────────────────────────────────────────────────┐
│                      ЛУЧШИЕ ПРАКТИКИ                           │
└─────────────────────────────────────────────────────────────────┘

✅ DO (Рекомендуется):
┌─────────────────────────────────────────────────────────────────┐
│ 1. Используйте RAII для автоматического возврата               │
│    auto obj = pool.acquire();  // auto-return on scope exit    │
│                                                                 │
│ 2. Очищайте состояние перед возвратом в пул                    │
│    reset_func = [](auto* obj) { obj->clear(); };              │
│                                                                 │
│ 3. Устанавливайте разумный размер пула                         │
│    size = expected_concurrent_requests * 1.5                   │
│                                                                 │
│ 4. Мониторьте метрики пула                                     │
│    • Утилизация, ожидание, exhaustion                          │
│                                                                 │
│ 5. Валидируйте объекты перед использованием                    │
│    if (!obj->isValid()) { recreate(); }                        │
│                                                                 │
│ 6. Используйте timeout для acquire()                           │
│    auto obj = pool.acquire(std::chrono::seconds(5));           │
└─────────────────────────────────────────────────────────────────┘

❌ DON'T (Не рекомендуется):
┌─────────────────────────────────────────────────────────────────┐
│ 1. НЕ забывайте возвращать объекты                             │
│    ❌ auto obj = pool.acquire(); // Забыли release!            │
│                                                                 │
│ 2. НЕ храните указатели на объекты из пула                     │
│    ❌ T* leaked = pool.acquire().get(); // Leak!               │
│                                                                 │
│ 3. НЕ используйте для легковесных объектов                     │
│    ❌ ObjectPool<int>  // Overhead > выгода                    │
│                                                                 │
│ 4. НЕ делайте пул слишком большим                              │
│    ❌ ObjectPool<Connection>(10000);  // Waste                 │
│                                                                 │
│ 5. НЕ игнорируйте exhaustion                                   │
│    ❌ try { acquire(); } catch(...) {}  // Silent fail         │
└─────────────────────────────────────────────────────────────────┘
```

## 🚀 Когда использовать Object Pool

```
┌─────────────────────────────────────────────────────────────────┐
│                    КОГДА ИСПОЛЬЗОВАТЬ                          │
└─────────────────────────────────────────────────────────────────┘

✅ ПОДХОДИТ ДЛЯ:
  • Database connections (дорогое создание)
  • Thread pools (системный overhead)
  • Network sockets (I/O overhead)
  • Graphics buffers (большие объекты)
  • Parsers/Compilers (тяжелая инициализация)
  • Crypto contexts (initialization cost)
  • Часто создаваемые объекты с predictable lifecycle

❌ НЕ ПОДХОДИТ ДЛЯ:
  • Простые объекты (int, string, small structs)
  • Объекты с непредсказуемым lifecycle
  • Объекты с сильно различающимся state
  • Stateless objects (лучше использовать singleton)
  • Объекты создаваемые редко
  • Когда overhead пула > выгода от переиспользования
```

## 📊 Производительность: Benchmark

```
┌─────────────────────────────────────────────────────────────────┐
│                BENCHMARK: WITH/WITHOUT POOL                    │
└─────────────────────────────────────────────────────────────────┘

TEST: 10,000 DB queries

WITHOUT POOL:
┌─────────────────────────────────────────────────────────────────┐
│ for (int i = 0; i < 10000; ++i) {                              │
│     auto conn = createConnection();  // 100ms                   │
│     conn->query("SELECT ...");       // 5ms                     │
│     destroyConnection(conn);         // 50ms                    │
│ }                                                               │
│                                                                 │
│ Total: 10,000 * (100 + 5 + 50) = 1,550 seconds ≈ 26 минут    │
└─────────────────────────────────────────────────────────────────┘

WITH POOL (size=10):
┌─────────────────────────────────────────────────────────────────┐
│ ConnectionPool pool(10);              // 1 second init          │
│                                                                 │
│ for (int i = 0; i < 10000; ++i) {                             │
│     auto conn = pool.acquire();       // 0.01ms                 │
│     conn->query("SELECT ...");        // 5ms                    │
│     pool.release(conn);               // 0.01ms                 │
│ }                                                               │
│                                                                 │
│ Total: 1 + 10,000 * (0.00001 + 0.005 + 0.00001) ≈ 51 seconds │
└─────────────────────────────────────────────────────────────────┘

РЕЗУЛЬТАТ: 30x УСКОРЕНИЕ! 🚀
```

## 📚 Связанные паттерны

```
┌─────────────────────────────────────────────────────────────────┐
│                   СВЯЗАННЫЕ ПАТТЕРНЫ                           │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│  Flyweight      │  • Разделение intrinsic/extrinsic state      │
│                 │  • Pool хранит shared состояние               │
│                 │  • Дополняет Object Pool                      │
├─────────────────┼───────────────────────────────────────────────┤
│  Factory        │  • Создание объектов для пула                 │
│                 │  • Абстракция создания                        │
│                 │  • Используется внутри Pool                   │
├─────────────────┼───────────────────────────────────────────────┤
│  Singleton      │  • Часто Pool реализован как Singleton        │
│                 │  • Единственный экземпляр пула                │
│                 │  • Глобальный доступ                          │
├─────────────────┼───────────────────────────────────────────────┤
│  Resource       │  • RAII для автоматического release           │
│  Acquisition    │  • Гарантия возврата объекта                  │
│  (RAII)         │  • Exception-safe usage                       │
└─────────────────┴───────────────────────────────────────────────┘
```

## 💼 Реальные примеры

```
┌─────────────────────────────────────────────────────────────────┐
│                  ПРИМЕРЫ ИЗ РЕАЛЬНОГО МИРА                     │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  DATABASE CONNECTION POOL                                       │
│  • PostgreSQL: pgpool, pgbouncer                                │
│  • MySQL: connection pooling                                    │
│  • Redis: connection pool                                       │
│  • Экономия на TCP handshake и authentication                  │
├─────────────────────────────────────────────────────────────────┤
│  THREAD POOL                                                    │
│  • Web servers: worker threads                                  │
│  • Game engines: job system                                     │
│  • GUI applications: background tasks                           │
│  • Избегание overhead создания потоков                         │
├─────────────────────────────────────────────────────────────────┤
│  MEMORY POOL                                                    │
│  • Game engines: frame allocators                               │
│  • Embedded systems: fixed memory                               │
│  • Real-time systems: deterministic allocation                 │
│  • Избегание fragmentation и syscalls                          │
├─────────────────────────────────────────────────────────────────┤
│  GRAPHICS BUFFER POOL                                           │
│  • OpenGL: VBO/FBO pools                                        │
│  • DirectX: buffer pools                                        │
│  • Video encoding: frame buffer reuse                           │
│  • Экономия на GPU memory allocation                           │
└─────────────────────────────────────────────────────────────────┘
```

---

**Автор**: Senior C++ Developer  
**Дата**: 2025-10-07  
**Версия**: 1.0
