# 📊 Плакат: Factory Method Pattern (Фабричный метод)

## 🎯 Назначение паттерна Factory Method

```
┌─────────────────────────────────────────────────────────────────┐
│                   FACTORY METHOD PATTERN                      │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  🏭 ИНКАПСУЛИРУЕТ СОЗДАНИЕ ОБЪЕКТОВ                          │
│  🔧 ПОЗВОЛЯЕТ ПОДКЛАССАМ ВЫБИРАТЬ ТИПЫ ОБЪЕКТОВ              │
│  🔄 ОБЕСПЕЧИВАЕТ ГИБКОСТЬ И РАСШИРЯЕМОСТЬ                     │
└─────────────────────────────────────────────────────────────────┘

Применение:
┌─────────────────┬───────────────────────────────────────────────┐
│   UI Framework  │ • Создание элементов интерфейса              │
├─────────────────┼───────────────────────────────────────────────┤
│   Игровые движки│ • Создание игровых объектов                   │
├─────────────────┼───────────────────────────────────────────────┤
│   Документы     │ • Создание различных типов документов        │
├─────────────────┼───────────────────────────────────────────────┤
│   Базы данных   │ • Создание подключений к разным БД           │
├─────────────────┼───────────────────────────────────────────────┤
│   Плагины       │ • Создание экземпляров плагинов              │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🔄 Проблема без Factory Method

```
┌─────────────────────────────────────────────────────────────────┐
│                    ПРОБЛЕМА: ЖЕСТКАЯ СВЯЗЬ                     │
└─────────────────────────────────────────────────────────────────┘

❌ ПЛОХО - Нарушение принципов:
┌─────────────────────────────────────────────────────────────────┐
│ class DocumentProcessor {                                       │
│ public:                                                         │
│     void processDocument(const std::string& type) {             │
│         if (type == "PDF") {                                    │
│             PDFDocument doc;        ← Жесткая связь             │
│             doc.open();                                         │
│         } else if (type == "Word") {                            │
│             WordDocument doc;      ← Жесткая связь              │
│             doc.open();                                         │
│         }                                                       │
│         // Проблемы:                                            │
│         // • Нарушение Open/Closed Principle                   │
│         // • Сложно добавлять новые типы                       │
│         // • Нарушение Dependency Inversion Principle          │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘
```

## ✅ Решение с Factory Method

```
┌─────────────────────────────────────────────────────────────────┐
│                    РЕШЕНИЕ: ПОЛИМОРФИЗМ                        │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШО - Соблюдение принципов:
┌─────────────────────────────────────────────────────────────────┐
│ class DocumentProcessor {                                       │
│ private:                                                        │
│     std::unique_ptr<DocumentFactory> factory_;                  │
│                                                                 │
│ public:                                                         │
│     DocumentProcessor(std::unique_ptr<DocumentFactory> factory) │
│         : factory_(std::move(factory)) {}                       │
│                                                                 │
│     void processDocument(const std::string& type) {             │
│         auto doc = factory_->createDocument(type); ← Полиморфизм│
│         doc->open();                                            │
│         doc->process();                                         │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘

Преимущества:
✅ Соблюдение Open/Closed Principle
✅ Легко добавлять новые типы
✅ Соблюдение Dependency Inversion Principle
✅ Инкапсуляция логики создания
```

## 🏗️ Структура Factory Method

```
┌─────────────────────────────────────────────────────────────────┐
│                    СТРУКТУРА ПАТТЕРНА                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    Product (Продукт)                           │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class Document {                                            ││
│  │ public:                                                     ││
│  │     virtual void open() = 0;                               ││
│  │     virtual void process() = 0;                            ││
│  │ };                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
│                              ▲                                 │
│                              │                                 │
│                              │ наследует                      │
│                              │                                 │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class PDFDocument : public Document {                      ││
│  │ public:                                                     ││
│  │     void open() override { /* PDF logic */ }               ││
│  │     void process() override { /* PDF logic */ }            ││
│  │ };                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                   Creator (Создатель)                          │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class DocumentFactory {                                     ││
│  │ public:                                                     ││
│  │     virtual ~DocumentFactory() = default;                  ││
│  │     virtual std::unique_ptr<Document> createDocument(      ││
│  │         const std::string& type) = 0;                      ││
│  │ };                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
│                              ▲                                 │
│                              │                                 │
│                              │ наследует                      │
│                              │                                 │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ class StandardDocumentFactory : public DocumentFactory {   ││
│  │ public:                                                     ││
│  │     std::unique_ptr<Document> createDocument(               ││
│  │         const std::string& type) override {                 ││
│  │         if (type == "PDF") {                                ││
│  │             return std::make_unique<PDFDocument>();         ││
│  │         }                                                   ││
│  │         // ... другие типы                                  ││
│  │     }                                                       ││
│  │ };                                                          ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
```

## 🎨 Варианты реализации

### 1. Simple Factory (Простая фабрика)
```
┌─────────────────────────────────────────────────────────────────┐
│                    SIMPLE FACTORY                              │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ class SimpleDocumentFactory {                                   │
│ public:                                                         │
│     static std::unique_ptr<Document> createDocument(            │
│         const std::string& type) {                              │
│         if (type == "PDF") {                                    │
│             return std::make_unique<PDFDocument>();             │
│         } else if (type == "Word") {                            │
│             return std::make_unique<WordDocument>();            │
│         }                                                       │
│         throw std::invalid_argument("Unknown type: " + type);   │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘

Использование:
┌─────────────────────────────────────────────────────────────────┐
│ auto doc = SimpleDocumentFactory::createDocument("PDF");        │
│ doc->open();                                                    │
└─────────────────────────────────────────────────────────────────┘

Преимущества:
✅ Простота реализации
✅ Централизованное создание

Недостатки:
❌ Нарушение Open/Closed Principle
❌ Не является паттерном GoF
```

### 2. Static Factory Methods
```
┌─────────────────────────────────────────────────────────────────┐
│                STATIC FACTORY METHODS                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ class Point {                                                   │
│ private:                                                        │
│     double x_, y_;                                              │
│     Point(double x, double y) : x_(x), y_(y) {}                │
│                                                                 │
│ public:                                                         │
│     // Различные способы создания                               │
│     static Point fromCartesian(double x, double y) {            │
│         return Point(x, y);                                     │
│     }                                                           │
│                                                                 │
│     static Point fromPolar(double radius, double angle) {       │
│         double x = radius * cos(angle);                         │
│         double y = radius * sin(angle);                         │
│         return Point(x, y);                                     │
│     }                                                           │
│                                                                 │
│     static Point origin() {                                     │
│         return Point(0, 0);                                     │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘

Использование:
┌─────────────────────────────────────────────────────────────────┐
│ auto p1 = Point::fromCartesian(3, 4);                          │
│ auto p2 = Point::fromPolar(5, 0.6435);                         │
│ auto p3 = Point::origin();                                     │
└─────────────────────────────────────────────────────────────────┘

Преимущества:
✅ Ясные имена методов
✅ Различные способы создания
✅ Инкапсуляция конструктора
```

### 3. Registry-based Factory
```
┌─────────────────────────────────────────────────────────────────┐
│                REGISTRY-BASED FACTORY                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ template<typename BaseType>                                     │
│ class FactoryRegistry {                                         │
│ private:                                                        │
│     std::map<std::string, std::function<std::unique_ptr<BaseType>()>> │
│         creators_;                                              │
│                                                                 │
│ public:                                                         │
│     template<typename DerivedType>                              │
│     void registerType(const std::string& name) {                │
│         creators_[name] = []() {                                │
│             return std::make_unique<DerivedType>();             │
│         };                                                      │
│     }                                                           │
│                                                                 │
│     std::unique_ptr<BaseType> create(const std::string& name) { │
│         auto it = creators_.find(name);                         │
│         if (it != creators_.end()) {                            │
│             return it->second();                                │
│         }                                                       │
│         throw std::invalid_argument("Unknown type: " + name);   │
│     }                                                           │
│ };                                                              │
└─────────────────────────────────────────────────────────────────┘

Использование:
┌─────────────────────────────────────────────────────────────────┐
│ FactoryRegistry<Document> registry;                             │
│ registry.registerType<PDFDocument>("pdf");                      │
│ registry.registerType<WordDocument>("word");                    │
│                                                                 │
│ auto doc = registry.create("pdf");                              │
└─────────────────────────────────────────────────────────────────┘

Преимущества:
✅ Динамическая регистрация типов
✅ Расширяемость без модификации
✅ Плагинная архитектура
```

## 🔄 Сравнение подходов

```
┌─────────────────────────────────────────────────────────────────┐
│                    СРАВНЕНИЕ ПОДХОДОВ                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐
│   Simple        │   Factory       │   Static        │   Registry      │
│   Factory       │   Method        │   Factory       │   Factory       │
├─────────────────┼─────────────────┼─────────────────┼─────────────────┤
│ Простота        │ Средняя         │ Высокая         │ Низкая          │
│ Расширяемость   │ Низкая          │ Высокая         │ Высокая         │
│ Гибкость        │ Низкая          │ Высокая         │ Очень высокая   │
│ Производительность│ Высокая        │ Средняя         │ Низкая          │
│ Тестируемость   │ Низкая          │ Высокая         │ Высокая         │
│ Применимость    │ Простые случаи  │ Стандартные     │ Плагины         │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
```

## 🎯 Когда использовать Factory Method

```
┌─────────────────────────────────────────────────────────────────┐
│                КОГДА ИСПОЛЬЗОВАТЬ FACTORY METHOD               │
└─────────────────────────────────────────────────────────────────┘

✅ ХОРОШИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Неизвестный тип │ • Класс не знает заранее, какие объекты      │
│ объектов        │   нужно создавать                             │
├─────────────────┼───────────────────────────────────────────────┤
│ Расширяемость   │ • Система должна быть расширяемой без        │
│                 │   модификации существующего кода              │
├─────────────────┼───────────────────────────────────────────────┤
│ Инкапсуляция    │ • Нужно скрыть детали создания объектов      │
├─────────────────┼───────────────────────────────────────────────┤
│ Полиморфизм     │ • Хотите использовать полиморфизм для        │
│                 │   создания объектов                           │
├─────────────────┼───────────────────────────────────────────────┤
│ Тестируемость   │ • Нужно легко создавать моки для тестов      │
└─────────────────┴───────────────────────────────────────────────┘

❌ ПЛОХИЕ СЛУЧАИ:
┌─────────────────┬───────────────────────────────────────────────┐
│ Простое создание│ • Создание объектов простое и не изменяется  │
├─────────────────┼───────────────────────────────────────────────┤
│ Один тип        │ • Всегда создается один и тот же тип         │
├─────────────────┼───────────────────────────────────────────────┤
│ Производительность│ • Критична производительность создания     │
├─────────────────┼───────────────────────────────────────────────┤
│ Сложность       │ • Добавляется ненужная сложность             │
└─────────────────┴───────────────────────────────────────────────┘
```

## 🧪 Тестирование Factory Method

```
┌─────────────────────────────────────────────────────────────────┐
│                ТЕСТИРОВАНИЕ FACTORY METHOD                     │
└─────────────────────────────────────────────────────────────────┘

Преимущества для тестирования:
┌─────────────────┬───────────────────────────────────────────────┐
│ Моки            │ ✅ Легко создавать моки для фабрик           │
│                 │ class MockDocumentFactory : public DocumentFactory { │
│                 │     MOCK_METHOD(std::unique_ptr<Document>,    │
│                 │                  createDocument, (const std::string&)); │
│                 │ };                                            │
├─────────────────┼───────────────────────────────────────────────┤
│ Изоляция        │ ✅ Легко изолировать тесты                   │
│                 │ auto mockFactory = std::make_unique<MockDocumentFactory>(); │
│                 │ DocumentProcessor processor(std::move(mockFactory)); │
├─────────────────┼───────────────────────────────────────────────┤
│ Управление      │ ✅ Полный контроль над создаваемыми объектами│
│ зависимостями   │ EXPECT_CALL(*mockFactory, createDocument("PDF")) │
│                 │     .WillOnce(Return(ByMove(std::make_unique<MockPDFDocument>()))); │
└─────────────────┴───────────────────────────────────────────────┘

Пример теста:
┌─────────────────────────────────────────────────────────────────┐
│ TEST(DocumentProcessorTest, ProcessDocument) {                  │
│     auto mockFactory = std::make_unique<MockDocumentFactory>();  │
│     auto mockDocument = std::make_unique<MockDocument>();       │
│                                                                 │
│     EXPECT_CALL(*mockFactory, createDocument("PDF"))            │
│         .WillOnce(Return(ByMove(std::move(mockDocument))));     │
│     EXPECT_CALL(*mockDocument, open()).Times(1);                │
│                                                                 │
│     DocumentProcessor processor(std::move(mockFactory));        │
│     processor.processDocument("PDF");                           │
│ }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

## 🔗 Связь с другими паттернами

```
┌─────────────────────────────────────────────────────────────────┐
│              СВЯЗЬ С ДРУГИМИ ПАТТЕРНАМИ                        │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┬───────────────────────────────────────────────┐
│ Abstract Factory│ • Factory Method создает один тип объекта    │
│                 │ • Abstract Factory создает семейства объектов│
│                 │ • Factory Method - частный случай Abstract Factory│
├─────────────────┼───────────────────────────────────────────────┤
│ Builder         │ • Factory Method создает объект в один шаг   │
│                 │ • Builder создает объект пошагово            │
│                 │ • Factory Method - простые объекты           │
│                 │ • Builder - сложные объекты                  │
├─────────────────┼───────────────────────────────────────────────┤
│ Prototype       │ • Factory Method создает новые объекты       │
│                 │ • Prototype клонирует существующие объекты   │
│                 │ • Factory Method - стандартное создание      │
│                 │ • Prototype - копирование                    │
├─────────────────┼───────────────────────────────────────────────┤
│ Singleton       │ • Factory Method может использовать Singleton│
│                 │ • Singleton может быть фабрикой              │
│                 │ • Вместе обеспечивают глобальный доступ      │
└─────────────────┴───────────────────────────────────────────────┘
```

## 💡 Практические рекомендации

```
┌─────────────────────────────────────────────────────────────────┐
│                  ПРАКТИЧЕСКИЕ РЕКОМЕНДАЦИИ                     │
└─────────────────────────────────────────────────────────────────┘

1. 🎯 Выбор реализации:
   • Simple Factory - для простых случаев
   • Factory Method - для стандартных задач
   • Static Factory Methods - для различных способов создания
   • Registry Factory - для плагинной архитектуры

2. 🔧 Принципы проектирования:
   • Соблюдайте Open/Closed Principle
   • Используйте Dependency Inversion
   • Инкапсулируйте логику создания
   • Обеспечьте расширяемость

3. 🧪 Тестирование:
   • Создавайте интерфейсы для фабрик
   • Используйте моки в тестах
   • Тестируйте различные типы объектов
   • Проверяйте обработку ошибок

4. ⚡ Производительность:
   • Рассмотрите кэширование объектов
   • Используйте move semantics
   • Избегайте ненужных копирований
   • Профилируйте критические участки

5. 📚 Документация:
   • Документируйте поддерживаемые типы
   • Описывайте параметры создания
   • Приводите примеры использования
   • Объясняйте причины выбора паттерна
```

## 🎓 Ключевые выводы

```
┌─────────────────────────────────────────────────────────────────┐
│                      КЛЮЧЕВЫЕ ВЫВОДЫ                          │
└─────────────────────────────────────────────────────────────────┘

✅ Factory Method - мощный инструмент:
   • Инкапсулирует создание объектов
   • Обеспечивает расширяемость системы
   • Следует принципам SOLID
   • Упрощает тестирование

✅ Выбирайте подходящую реализацию:
   • Simple Factory - для простых случаев
   • Factory Method - для стандартных задач
   • Static Factory Methods - для ясности
   • Registry Factory - для плагинов

✅ Используйте правильно:
   • Когда тип объекта неизвестен заранее
   • Когда нужна расширяемость
   • Когда важна тестируемость
   • Когда нужно инкапсулировать создание

✅ Избегайте злоупотребления:
   • Не используйте для простого создания
   • Не добавляйте сложность без необходимости
   • Не забывайте об обработке ошибок
   • Не нарушайте принципы SOLID
```

---
*Factory Method - это мост между абстракцией и конкретными реализациями. 
Используйте его для создания гибких и расширяемых систем!*
