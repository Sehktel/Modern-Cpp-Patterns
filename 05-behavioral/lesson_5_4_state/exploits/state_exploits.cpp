#include <iostream>
#include <memory>
#include <thread>
#include <chrono>
#include <atomic>

/**
 * @file state_exploits.cpp  
 * @brief Практические эксплойты для State паттерна
 * 
 * ⚠️  ТОЛЬКО ДЛЯ ОБРАЗОВАТЕЛЬНЫХ ЦЕЛЕЙ!
 */

// ============================================================================
// ЭКСПЛОЙТ 1: TOCTOU ДЛЯ BYPASS AUTHENTICATION
// Цель: Получить доступ через race condition в проверке состояния
// ============================================================================

enum class AuthState {
    UNAUTHENTICATED,
    AUTHENTICATING,
    AUTHENTICATED
};

class VulnerableAuth {
private:
    AuthState state_ = AuthState::UNAUTHENTICATED;
    
public:
    AuthState getState() const {
        return state_;  // Time of Check
    }
    
    void setState(AuthState new_state) {
        state_ = new_state;
    }
    
    void accessResource() {
        // УЯЗВИМОСТЬ: TOCTOU
        if (getState() == AuthState::AUTHENTICATED) {  // Time of Check
            std::cout << "Проверка пройдена...\n";
            
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
            
            // Time of Use - state мог измениться!
            std::cout << "🔓 Доступ к конфиденциальным данным разрешен\n";
            std::cout << "   → Секретный ключ: sk-1234567890\n";
            std::cout << "   → Database password: admin123\n";
        } else {
            std::cout << "❌ Доступ запрещен\n";
        }
    }
};

void exploit_toctou_auth_bypass() {
    std::cout << "\n=== ЭКСПЛОЙТ 1: TOCTOU Authentication Bypass ===\n";
    
    VulnerableAuth auth;
    std::atomic<bool> success{false};
    
    // Поток атакующего: пытается получить доступ
    std::thread attacker([&auth, &success]() {
        for (int attempt = 1; attempt <= 10; ++attempt) {
            std::cout << "\n[Попытка " << attempt << "] Запрос доступа...\n";
            auth.accessResource();
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    });
    
    // Поток эксплойта: быстро меняет state
    std::thread exploiter([&auth]() {
        for (int i = 0; i < 100; ++i) {
            auth.setState(AuthState::AUTHENTICATED);
            std::this_thread::sleep_for(std::chrono::microseconds(100));
            auth.setState(AuthState::UNAUTHENTICATED);
            std::this_thread::sleep_for(std::chrono::microseconds(100));
        }
    });
    
    attacker.join();
    exploiter.join();
    
    std::cout << "\n💡 Результат:\n";
    std::cout << "   ✓ Обход аутентификации через TOCTOU\n";
    std::cout << "   ✓ Доступ к конфиденциальным данным\n";
    std::cout << "   ✓ Утечка credentials\n";
}

// ============================================================================
// ЭКСПЛОЙТ 2: INVALID STATE TRANSITION → DOUBLE REFUND
// Цель: Получить возврат средств дважды
// ============================================================================

enum class PaymentState {
    PENDING,
    COMPLETED,
    REFUNDED
};

class VulnerablePayment {
private:
    PaymentState state_ = PaymentState::PENDING;
    double amount_ = 0.0;
    
public:
    void complete(double amount) {
        state_ = PaymentState::COMPLETED;
        amount_ = amount;
        std::cout << "💳 Платеж завершен: $" << amount << "\n";
    }
    
    void refund() {
        // УЯЗВИМОСТЬ: Нет проверки current state!
        std::cout << "💰 Возврат: $" << amount_ << "\n";
        state_ = PaymentState::REFUNDED;
    }
    
    void setState(PaymentState new_state) {
        state_ = new_state;  // Прямой доступ!
    }
    
    PaymentState getState() const { return state_; }
};

void exploit_double_refund() {
    std::cout << "\n=== ЭКСПЛОЙТ 2: Double Refund через Invalid Transition ===\n";
    
    VulnerablePayment payment;
    
    std::cout << "Сценарий: Покупатель хочет получить возврат дважды\n\n";
    
    // Легитимная транзакция
    payment.complete(500.0);
    
    // Первый возврат
    payment.refund();
    
    std::cout << "\n🚨 АТАКА: Возврат в COMPLETED и повторный refund\n";
    
    // АТАКА: Манипулируем состоянием
    payment.setState(PaymentState::COMPLETED);
    
    // Второй возврат!
    payment.refund();
    
    std::cout << "\n💡 Последствия:\n";
    std::cout << "   ✓ Получено $1000 вместо $500\n";
    std::cout << "   ✓ Финансовые потери компании\n";
    std::cout << "   ✓ Массовое мошенничество возможно\n";
}

// ============================================================================
// ЭКСПЛОЙТ 3: RACE CONDITION → USE-AFTER-FREE
// Цель: Вызвать use-after-free через race на state transition
// ============================================================================

class StateObject {
public:
    virtual ~StateObject() {
        std::cout << "State удален\n";
    }
    
    virtual void action() = 0;
};

class StateA : public StateObject {
public:
    void action() override {
        std::cout << "StateA действие\n";
    }
};

class StateB : public StateObject {
public:
    void action() override {
        std::cout << "StateB действие\n";
    }
};

class DanglingStateContext {
private:
    StateObject* state_;  // Сырой указатель!
    
public:
    DanglingStateContext() : state_(new StateA()) {}
    
    void changeState() {
        delete state_;
        state_ = new StateB();  // НЕТ СИНХРОНИЗАЦИИ!
    }
    
    void performAction() {
        state_->action();  // Может быть dangling!
    }
    
    ~DanglingStateContext() {
        delete state_;
    }
};

void exploit_race_use_after_free() {
    std::cout << "\n=== ЭКСПЛОЙТ 3: Race Condition → Use-After-Free ===\n";
    
    DanglingStateContext context;
    
    std::cout << "Сценарий: Два потока работают с одним Context\n\n";
    
    std::atomic<bool> crashed{false};
    
    // Поток 1: Постоянно меняет state
    std::thread state_changer([&context]() {
        for (int i = 0; i < 100; ++i) {
            context.changeState();
            std::this_thread::sleep_for(std::chrono::microseconds(50));
        }
    });
    
    // Поток 2: Использует state
    std::thread state_user([&context, &crashed]() {
        for (int i = 0; i < 100; ++i) {
            try {
                context.performAction();  // UAF риск!
                std::this_thread::sleep_for(std::chrono::microseconds(75));
            } catch (...) {
                crashed = true;
                std::cout << "🚨 CRASH обнаружен!\n";
                break;
            }
        }
    });
    
    state_changer.join();
    state_user.join();
    
    if (!crashed) {
        std::cout << "\n⚠️  Use-after-free может не проявиться сразу (heisenbug)\n";
    }
    
    std::cout << "💡 С AddressSanitizer:\n";
    std::cout << "   ERROR: AddressSanitizer: heap-use-after-free\n";
}

// ============================================================================
// ЭКСПЛОЙТ 4: STATE CONFUSION → PRIVILEGE ESCALATION
// Цель: Получить admin права через confusion состояний
// ============================================================================

enum class UserRole {
    GUEST,
    USER,
    ADMIN
};

class VulnerableSession {
private:
    UserRole role_ = UserRole::GUEST;
    std::string username_;
    
public:
    void login(const std::string& username, const std::string& password) {
        // Упрощенная проверка
        if (password == "password") {
            role_ = UserRole::USER;
            username_ = username;
            std::cout << "✅ Logged in as USER: " << username << "\n";
        }
    }
    
    void elevateToAdmin(const std::string& admin_code) {
        if (admin_code == "ADMIN_SECRET") {
            role_ = UserRole::ADMIN;
            std::cout << "✅ Elevated to ADMIN\n";
        }
    }
    
    void performAdminAction() {
        // УЯЗВИМОСТЬ: Проверка и действие разделены
        if (role_ == UserRole::ADMIN) {  // Check
            std::cout << "Проверка admin прав...\n";
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
            
            // Use - role могла измениться!
            std::cout << "🔓 Выполнение admin команды\n";
            std::cout << "   → Удаление пользователей\n";
            std::cout << "   → Изменение конфигурации\n";
        } else {
            std::cout << "❌ Недостаточно прав\n";
        }
    }
    
    void setRole(UserRole role) {
        role_ = role;  // Прямой доступ!
    }
};

void exploit_state_confusion_privesc() {
    std::cout << "\n=== ЭКСПЛОЙТ 4: State Confusion → Privilege Escalation ===\n";
    
    VulnerableSession session;
    session.login("attacker", "password");
    
    // Поток 1: Запрос admin действия
    std::thread requester([&session]() {
        std::cout << "[Запрос] Попытка admin действия как USER\n";
        session.performAdminAction();
    });
    
    // Поток 2: Повышаем права во время проверки
    std::thread privilege_injector([&session]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(25));
        std::cout << "[Инжектор] 🚨 Повышение до ADMIN!\n";
        session.setRole(UserRole::ADMIN);
    });
    
    requester.join();
    privilege_injector.join();
    
    std::cout << "\n💡 Последствия:\n";
    std::cout << "   ✓ Обход проверки прав\n";
    std::cout << "   ✓ Выполнение привилегированных операций\n";
    std::cout << "   ✓ Full system compromise\n";
}

// ============================================================================
// MAIN
// ============================================================================

int main() {
    std::cout << "=== ПРАКТИЧЕСКИЕ ЭКСПЛОЙТЫ STATE PATTERN ===\n";
    std::cout << "⚠️  ВНИМАНИЕ: Только для обучения!\n";
    
    try {
        exploit_toctou_auth_bypass();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    try {
        exploit_double_refund();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    try {
        exploit_race_use_after_free();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    try {
        exploit_state_confusion_privesc();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    std::cout << "\n=== ЗАЩИТНЫЕ МЕРЫ ===\n";
    std::cout << "✅ Атомарная проверка и использование состояния\n";
    std::cout << "✅ Валидация допустимых переходов\n";
    std::cout << "✅ Мьютексы для защиты shared state\n";
    std::cout << "✅ Умные указатели для управления памятью\n";
    std::cout << "✅ State transition table\n";
    std::cout << "✅ Audit logging всех переходов\n";
    
    return 0;
}
