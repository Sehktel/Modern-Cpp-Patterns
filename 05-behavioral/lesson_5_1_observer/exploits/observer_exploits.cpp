#include <iostream>
#include <vector>
#include <memory>
#include <thread>
#include <mutex>
#include <chrono>
#include <cstring>
#include <functional>

/**
 * @file observer_exploits.cpp
 * @brief Практические эксплойты для уязвимостей Observer паттерна
 * 
 * ⚠️  ТОЛЬКО ДЛЯ ОБРАЗОВАТЕЛЬНЫХ ЦЕЛЕЙ!
 * Эти эксплойты демонстрируют реальные атаки на уязвимые реализации Observer.
 */

// ============================================================================
// ЭКСПЛОЙТ 1: USE-AFTER-FREE ДЛЯ КОНТРОЛЯ ПОТОКА ВЫПОЛНЕНИЯ
// Цель: Перенаправить выполнение программы через dangling pointer
// ============================================================================

class IObserver {
public:
    virtual ~IObserver() = default;
    virtual void update(const std::string& message) = 0;
};

// Уязвимый Subject (хранит сырые указатели)
class VulnerableSubject {
private:
    std::vector<IObserver*> observers_;
    
public:
    void attach(IObserver* observer) {
        observers_.push_back(observer);
    }
    
    void notify(const std::string& message) {
        for (auto* observer : observers_) {
            observer->update(message);  // Потенциальный use-after-free
        }
    }
};

// Легитимный observer
class LegitObserver : public IObserver {
public:
    void update(const std::string& message) override {
        std::cout << "[Legit] " << message << "\n";
    }
};

// Злонамеренный observer для эксплойта
class MaliciousObserver : public IObserver {
public:
    void update(const std::string& message) override {
        std::cout << "🚨 ЭКСПЛОЙТ: Злонамеренный код выполнен!\n";
        std::cout << "🚨 Получен доступ к: " << message << "\n";
        
        // В реальном эксплойте здесь мог быть:
        // - Выполнение shellcode
        // - Кража данных
        // - Изменение потока выполнения
        // - Privilege escalation
    }
};

void exploit_use_after_free() {
    std::cout << "\n=== ЭКСПЛОЙТ 1: Use-After-Free ===\n";
    
    VulnerableSubject subject;
    
    // 1. Создаем легитимный observer
    {
        LegitObserver legit;
        subject.attach(&legit);
        subject.notify("Безопасное сообщение");
        
        // legit удаляется здесь, но Subject хранит dangling pointer
    }
    
    // 2. Создаем злонамеренный observer в том же месте памяти
    MaliciousObserver malicious;
    
    // 3. АТАКА: Subject использует dangling pointer, который теперь указывает
    //    на MaliciousObserver (если повезет с размещением в памяти)
    std::cout << "\n🔥 Попытка эксплуатации use-after-free...\n";
    subject.notify("Конфиденциальные данные: пароль=admin123");
    
    std::cout << "\n💡 В реальной ситуации:\n";
    std::cout << "   - Атакующий контролирует размещение объектов в памяти\n";
    std::cout << "   - Может перенаправить vtable на свой код\n";
    std::cout << "   - Получает выполнение произвольного кода\n";
}

// ============================================================================
// ЭКСПЛОЙТ 2: RACE CONDITION ДЛЯ ОБХОДА ПРОВЕРОК БЕЗОПАСНОСТИ
// Цель: Получить доступ к ресурсам через состояние гонки
// ============================================================================

class PrivilegedObserver : public IObserver {
private:
    bool hasPermission_ = false;
    
public:
    void setPermission(bool perm) {
        hasPermission_ = perm;
    }
    
    bool hasPermission() const {
        return hasPermission_;
    }
    
    void update(const std::string& message) override {
        if (hasPermission_) {
            std::cout << "🔓 [Privileged] Доступ к: " << message << "\n";
        } else {
            std::cout << "🔒 [Denied] Нет доступа\n";
        }
    }
};

// Уязвимый Subject без синхронизации
class UnsafeSubject {
private:
    std::vector<PrivilegedObserver*> observers_;
    
public:
    void attach(PrivilegedObserver* observer) {
        observers_.push_back(observer);
    }
    
    void notifyPrivileged(const std::string& message) {
        for (auto* obs : observers_) {
            // УЯЗВИМОСТЬ: Проверка и использование не атомарны
            if (obs->hasPermission()) {
                std::this_thread::sleep_for(std::chrono::microseconds(100)); // Симуляция задержки
                obs->update(message);
            }
        }
    }
};

void exploit_race_condition() {
    std::cout << "\n=== ЭКСПЛОЙТ 2: Race Condition (TOCTOU) ===\n";
    
    UnsafeSubject subject;
    PrivilegedObserver observer;
    
    subject.attach(&observer);
    
    // Атакующий поток: постоянно меняет permissions
    std::thread attacker([&observer]() {
        for (int i = 0; i < 100; ++i) {
            observer.setPermission(true);   // Даем права
            std::this_thread::sleep_for(std::chrono::microseconds(50));
            observer.setPermission(false);  // Забираем права
            std::this_thread::sleep_for(std::chrono::microseconds(50));
        }
    });
    
    // Легитимный поток: отправляет конфиденциальные данные
    std::thread sender([&subject]() {
        for (int i = 0; i < 10; ++i) {
            std::this_thread::sleep_for(std::chrono::milliseconds(20));
            subject.notifyPrivileged("🔐 Секретные данные #" + std::to_string(i));
        }
    });
    
    attacker.join();
    sender.join();
    
    std::cout << "\n💡 Атакующий использовал TOCTOU (Time-of-Check to Time-of-Use):\n";
    std::cout << "   - Проверка permissions и использование не атомарны\n";
    std::cout << "   - Получен доступ к привилегированным данным\n";
}

// ============================================================================
// ЭКСПЛОЙТ 3: ITERATOR INVALIDATION ДЛЯ ОБХОДА ЛОГИКИ
// Цель: Вызвать повторную обработку или пропуск через манипуляцию итератором
// ============================================================================

class ActionObserver : public IObserver {
private:
    std::function<void()> action_;
    std::string name_;
    
public:
    ActionObserver(const std::string& name, std::function<void()> action)
        : name_(name), action_(std::move(action)) {}
    
    void update(const std::string& message) override {
        std::cout << "[" << name_ << "] Выполнение действия...\n";
        if (action_) {
            action_();
        }
    }
    
    std::string getName() const { return name_; }
};

class ManipulableSubject {
private:
    std::vector<ActionObserver*> observers_;
    
public:
    void attach(ActionObserver* observer) {
        observers_.push_back(observer);
    }
    
    void remove(ActionObserver* observer) {
        observers_.erase(
            std::remove(observers_.begin(), observers_.end(), observer),
            observers_.end());
    }
    
    void notify(const std::string& message) {
        std::cout << "Уведомление observers...\n";
        // УЯЗВИМОСТЬ: Итератор может быть invalidated во время notify
        for (auto* obs : observers_) {
            obs->update(message);
        }
    }
    
    size_t count() const { return observers_.size(); }
};

void exploit_iterator_invalidation() {
    std::cout << "\n=== ЭКСПЛОЙТ 3: Iterator Invalidation ===\n";
    
    ManipulableSubject subject;
    
    ActionObserver obs1("Observer1", []() {
        std::cout << "  → Observer1 действие\n";
    });
    
    // Злонамеренный observer, который манипулирует списком
    ActionObserver malicious("Malicious", [&subject, &obs1]() {
        std::cout << "  🚨 Malicious действие: удаляем Observer1 во время итерации!\n";
        subject.remove(&obs1);  // Iterator invalidation!
    });
    
    ActionObserver obs3("Observer3", []() {
        std::cout << "  → Observer3 действие\n";
    });
    
    subject.attach(&obs1);
    subject.attach(&malicious);
    subject.attach(&obs3);
    
    std::cout << "Начальное количество observers: " << subject.count() << "\n";
    
    std::cout << "\n🔥 Запуск эксплойта...\n";
    subject.notify("Trigger");
    
    std::cout << "\nКоличество observers после: " << subject.count() << "\n";
    std::cout << "\n💡 Что произошло:\n";
    std::cout << "   - Malicious observer удалил другой observer во время notify\n";
    std::cout << "   - Iterator был invalidated → undefined behavior\n";
    std::cout << "   - Возможен segfault или пропуск observers\n";
}

// ============================================================================
// ЭКСПЛОЙТ 4: MEMORY EXHAUSTION ЧЕРЕЗ ПОДПИСКУ
// Цель: DoS атака через создание множества observers
// ============================================================================

class LeakySubject {
private:
    std::vector<std::shared_ptr<IObserver>> observers_;
    
public:
    void attach(std::shared_ptr<IObserver> observer) {
        observers_.push_back(observer);
    }
    
    // Нет метода detach - memory leak!
    
    size_t count() const { return observers_.size(); }
};

class HeavyObserver : public IObserver {
private:
    std::vector<char> data_;  // Занимает память
    
public:
    HeavyObserver(size_t size_mb) {
        data_.resize(size_mb * 1024 * 1024, 'X');
    }
    
    void update(const std::string& message) override {
        // Ничего не делаем
    }
};

void exploit_memory_exhaustion() {
    std::cout << "\n=== ЭКСПЛОЙТ 4: Memory Exhaustion (DoS) ===\n";
    
    auto subject = std::make_shared<LeakySubject>();
    
    std::cout << "Атакующий создает множество heavy observers...\n";
    
    // Атака: создаем много "тяжелых" observers
    for (int i = 0; i < 10; ++i) {
        auto heavy = std::make_shared<HeavyObserver>(10);  // 10 MB каждый
        subject->attach(heavy);
        
        std::cout << "  Создан observer #" << i << " (занято ~" 
                  << (i + 1) * 10 << " MB)\n";
    }
    
    std::cout << "\n🚨 Всего observers: " << subject->count() << "\n";
    std::cout << "🚨 Использовано памяти: ~100 MB\n";
    std::cout << "🚨 Observers не могут быть удалены (нет detach)!\n";
    
    std::cout << "\n💡 Последствия:\n";
    std::cout << "   - Memory leak накапливается\n";
    std::cout << "   - Возможна нехватка памяти (OOM)\n";
    std::cout << "   - Denial of Service\n";
    
    // В реальности это привело бы к падению программы
}

// ============================================================================
// ЭКСПЛОЙТ 5: TIMING ATTACK ЧЕРЕЗ OBSERVER
// Цель: Извлечение информации через анализ времени выполнения
// ============================================================================

class TimingSensitiveSubject {
private:
    std::vector<std::function<void(const std::string&)>> observers_;
    std::string secretKey_ = "SuperSecretPassword123";
    
public:
    void attach(std::function<void(const std::string&)> observer) {
        observers_.push_back(observer);
    }
    
    void authenticate(const std::string& password) {
        // УЯЗВИМОСТЬ: Небезопасное сравнение строк (timing attack)
        bool authenticated = (password == secretKey_);
        
        if (authenticated) {
            for (auto& obs : observers_) {
                obs("Authentication successful");
            }
        } else {
            for (auto& obs : observers_) {
                obs("Authentication failed");
            }
        }
    }
};

void exploit_timing_attack() {
    std::cout << "\n=== ЭКСПЛОЙТ 5: Timing Attack ===\n";
    
    TimingSensitiveSubject subject;
    
    // Атакующий подписывается на события
    subject.attach([](const std::string& msg) {
        // Можно измерять время обработки
    });
    
    std::cout << "Атакующий пытается подобрать пароль через timing attack...\n";
    
    // Симуляция подбора
    std::vector<std::string> attempts = {
        "S",
        "Su",
        "Sup",
        "Supe",
        "Super",
        "SuperS",
        "SuperSe",
        "SuperSec"
    };
    
    for (const auto& attempt : attempts) {
        auto start = std::chrono::high_resolution_clock::now();
        
        subject.authenticate(attempt);
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();
        
        std::cout << "  Попытка '" << attempt << "': " << duration << " ns\n";
    }
    
    std::cout << "\n💡 Атакующий может:\n";
    std::cout << "   - Анализировать время обработки\n";
    std::cout << "   - Определять правильность префикса пароля\n";
    std::cout << "   - Постепенно восстановить весь пароль\n";
}

// ============================================================================
// MAIN
// ============================================================================

int main() {
    std::cout << "=== ПРАКТИЧЕСКИЕ ЭКСПЛОЙТЫ ДЛЯ OBSERVER PATTERN ===\n";
    std::cout << "⚠️  ВНИМАНИЕ: Эти эксплойты предназначены ТОЛЬКО для обучения!\n";
    std::cout << "⚠️  НЕ ИСПОЛЬЗУЙТЕ в реальных системах без разрешения!\n\n";
    
    try {
        exploit_use_after_free();
    } catch (...) {
        std::cout << "Exception caught (expected for use-after-free)\n";
    }
    
    exploit_race_condition();
    
    try {
        exploit_iterator_invalidation();
    } catch (...) {
        std::cout << "Exception caught (expected for iterator invalidation)\n";
    }
    
    exploit_memory_exhaustion();
    exploit_timing_attack();
    
    std::cout << "\n=== ЗАЩИТНЫЕ МЕРЫ ===\n";
    std::cout << "✅ Используйте умные указатели (weak_ptr) вместо сырых\n";
    std::cout << "✅ Защищайте критические секции мьютексами\n";
    std::cout << "✅ Копируйте контейнеры перед итерацией\n";
    std::cout << "✅ Ограничивайте количество подписок\n";
    std::cout << "✅ Используйте constant-time операции для секретных данных\n";
    std::cout << "✅ Применяйте RAII для автоматической отписки\n";
    
    return 0;
}
