#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <cstring>

// ============================================================================
// ЭКСПЛОИТЫ ДЛЯ ABSTRACT FACTORY
// ============================================================================

// TODO: Добавить комментарии на русском языке
// TODO: Создать более сложные эксплоиты
// TODO: Добавить обход защитных механизмов

// Уязвимый Abstract Factory для демонстрации
class VulnerableAbstractFactory {
private:
    std::vector<void*> objects;
    std::vector<size_t> sizes;
    
    VulnerableAbstractFactory() {
        std::cout << "VulnerableAbstractFactory создан в потоке " << std::this_thread::get_id() << std::endl;
    }
    
public:
    static VulnerableAbstractFactory& getInstance() {
        static VulnerableAbstractFactory instance;
        return instance;
    }
    
    // УЯЗВИМОСТЬ: Небезопасное создание объектов
    template<typename T>
    T* createObject(size_t size) {
        void* obj = new char[size];
        objects.push_back(obj);
        sizes.push_back(size);
        
        // УЯЗВИМОСТЬ: Небезопасное приведение типа
        return static_cast<T*>(obj);
    }
    
    void* getObject(size_t index) {
        if (index < objects.size()) {
            return objects[index];
        }
        return nullptr;
    }
    
    size_t getObjectCount() const {
        return objects.size();
    }
    
    ~VulnerableAbstractFactory() {
        for (void* obj : objects) {
            delete[] static_cast<char*>(obj);
        }
        std::cout << "VulnerableAbstractFactory уничтожен" << std::endl;
    }
};

// ============================================================================
// ЭКСПЛОИТ 1: TYPE CONFUSION ДЛЯ ПОЛУЧЕНИЯ КОНТРОЛЯ
// ============================================================================

void exploitTypeConfusion() {
    std::cout << "\n=== ЭКСПЛОИТ 1: TYPE CONFUSION ===" << std::endl;
    
    auto& factory = VulnerableAbstractFactory::getInstance();
    
    // Создаем объект одного типа
    int* intObj = factory.createObject<int>(sizeof(int));
    *intObj = 0x41414141; // 'AAAA'
    
    std::cout << "Создан int объект со значением: " << std::hex << *intObj << std::dec << std::endl;
    
    // УЯЗВИМОСТЬ: Получаем объект как другой тип
    char* charObj = static_cast<char*>(factory.getObject(0));
    
    std::cout << "Получен как char: ";
    for (int i = 0; i < sizeof(int); ++i) {
        std::cout << charObj[i];
    }
    std::cout << std::endl;
    
    // УЯЗВИМОСТЬ: Попытка использовать как указатель
    void** ptrObj = static_cast<void**>(factory.getObject(0));
    std::cout << "Получен как указатель: " << ptrObj << std::endl;
    
    std::cout << "ЭКСПЛОИТ УСПЕШЕН - Type confusion достигнут!" << std::endl;
}

// ============================================================================
// ЭКСПЛОИТ 2: MEMORY CORRUPTION ЧЕРЕЗ BUFFER OVERFLOW
// ============================================================================

class CorruptibleAbstractFactory {
private:
    char* buffer;
    size_t bufferSize;
    size_t currentSize;
    
public:
    CorruptibleAbstractFactory() : buffer(nullptr), bufferSize(0), currentSize(0) {
        std::cout << "CorruptibleAbstractFactory создан" << std::endl;
    }
    
    void* createObjectArray(size_t count, size_t elementSize) {
        // УЯЗВИМОСТЬ: Integer overflow
        size_t totalSize = count * elementSize;
        
        if (currentSize + totalSize > bufferSize) {
            bufferSize = currentSize + totalSize;
            char* newBuffer = new char[bufferSize];
            if (buffer) {
                memcpy(newBuffer, buffer, currentSize);
                delete[] buffer;
            }
            buffer = newBuffer;
        }
        
        void* obj = buffer + currentSize;
        currentSize += totalSize;
        
        return obj;
    }
    
    char* getBuffer() {
        return buffer;
    }
    
    ~CorruptibleAbstractFactory() {
        delete[] buffer;
        std::cout << "CorruptibleAbstractFactory уничтожен" << std::endl;
    }
};

void exploitBufferOverflow() {
    std::cout << "\n=== ЭКСПЛОИТ 2: BUFFER OVERFLOW ===" << std::endl;
    
    CorruptibleAbstractFactory factory;
    
    // Нормальное использование
    void* obj1 = factory.createObjectArray(10, 100);
    std::cout << "Создан массив: 10 * 100 = 1000 байт" << std::endl;
    
    // УЯЗВИМОСТЬ: Integer overflow
    size_t largeCount = SIZE_MAX / 2;
    size_t largeSize = SIZE_MAX / 2;
    
    std::cout << "Попытка создать массив: " << largeCount << " * " << largeSize << std::endl;
    
    void* obj2 = factory.createObjectArray(largeCount, largeSize);
    
    if (obj2) {
        std::cout << "Массив создан (возможно из-за overflow)!" << std::endl;
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Buffer overflow достигнут!" << std::endl;
    } else {
        std::cout << "Массив не создан" << std::endl;
    }
}

// ============================================================================
// ЭКСПЛОИТ 3: USE-AFTER-FREE АТАКА
// ============================================================================

class UseAfterFreeAbstractFactory {
private:
    std::vector<void*> objects;
    std::vector<bool> valid;
    
public:
    UseAfterFreeAbstractFactory() {
        std::cout << "UseAfterFreeAbstractFactory создан" << std::endl;
    }
    
    void* createObject(size_t size) {
        void* obj = new char[size];
        objects.push_back(obj);
        valid.push_back(true);
        
        // Заполняем объект данными
        memset(obj, 'A', size);
        
        return obj;
    }
    
    void destroyObject(size_t index) {
        if (index < objects.size() && valid[index]) {
            delete[] static_cast<char*>(objects[index]);
            valid[index] = false;
            // УЯЗВИМОСТЬ: Не обнуляем указатель
        }
    }
    
    void* getObject(size_t index) {
        if (index < objects.size()) {
            return objects[index]; // Может быть dangling pointer
        }
        return nullptr;
    }
    
    bool isObjectValid(size_t index) const {
        if (index < valid.size()) {
            return valid[index];
        }
        return false;
    }
    
    ~UseAfterFreeAbstractFactory() {
        for (size_t i = 0; i < objects.size(); ++i) {
            if (valid[i]) {
                delete[] static_cast<char*>(objects[i]);
            }
        }
        std::cout << "UseAfterFreeAbstractFactory уничтожен" << std::endl;
    }
};

void exploitUseAfterFree() {
    std::cout << "\n=== ЭКСПЛОИТ 3: USE-AFTER-FREE ===" << std::endl;
    
    UseAfterFreeAbstractFactory factory;
    
    // Создаем объект
    void* obj = factory.createObject(1024);
    std::cout << "Объект создан" << std::endl;
    
    // Уничтожаем объект
    factory.destroyObject(0);
    std::cout << "Объект уничтожен" << std::endl;
    
    // УЯЗВИМОСТЬ: Попытка использовать после уничтожения
    void* danglingObj = factory.getObject(0);
    if (danglingObj) {
        std::cout << "Объект все еще доступен (dangling pointer)" << std::endl;
        std::cout << "Валидность: " << (factory.isObjectValid(0) ? "Да" : "Нет") << std::endl;
        
        // Попытка прочитать данные
        char* data = static_cast<char*>(danglingObj);
        std::cout << "Первые 10 символов: ";
        for (int i = 0; i < 10; ++i) {
            std::cout << data[i];
        }
        std::cout << std::endl;
        
        std::cout << "ЭКСПЛОИТ УСПЕШЕН - Use-After-Free достигнут!" << std::endl;
    }
}

// ============================================================================
// ЭКСПЛОИТ 4: MEMORY LEAK АТАКА
// ============================================================================

void exploitMemoryLeak() {
    std::cout << "\n=== ЭКСПЛОИТ 4: MEMORY LEAK ===" << std::endl;
    
    auto& factory = VulnerableAbstractFactory::getInstance();
    
    // Попытка исчерпать память
    for (int i = 0; i < 1000; ++i) {
        try {
            // Создаем большие объекты
            void* obj = factory.createObject<char>(100000);
            if (i % 100 == 0) {
                std::cout << "Создан объект " << i << std::endl;
            }
        } catch (const std::bad_alloc& e) {
            std::cout << "Память исчерпана на объекте " << i << std::endl;
            std::cout << "ЭКСПЛОИТ УСПЕШЕН - DoS через memory leak достигнут!" << std::endl;
            break;
        }
    }
    
    std::cout << "Общее количество объектов: " << factory.getObjectCount() << std::endl;
}

// ============================================================================
// ОСНОВНАЯ ФУНКЦИЯ
// ============================================================================

int main() {
    std::cout << "=== ДЕМОНСТРАЦИЯ ЭКСПЛОИТОВ ДЛЯ ABSTRACT FACTORY ===" << std::endl;
    std::cout << "ВНИМАНИЕ: Этот код содержит эксплоиты для образовательных целей!" << std::endl;
    
    // Запуск различных эксплоитов
    exploitTypeConfusion();
    exploitBufferOverflow();
    exploitUseAfterFree();
    exploitMemoryLeak();
    
    std::cout << "\n=== РЕКОМЕНДАЦИИ ПО ЗАЩИТЕ ===" << std::endl;
    std::cout << "1. Используйте безопасные типы и шаблоны" << std::endl;
    std::cout << "2. Проверяйте типы перед приведением" << std::endl;
    std::cout << "3. Применяйте RAII для управления ресурсами" << std::endl;
    std::cout << "4. Валидируйте входные данные" << std::endl;
    std::cout << "5. Используйте умные указатели" << std::endl;
    std::cout << "6. Регулярно анализируйте код с помощью инструментов безопасности" << std::endl;
    
    return 0;
}