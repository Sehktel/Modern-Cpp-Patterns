#include <iostream>
#include <string>
#include <cstring>
#include <vector>

/**
 * @file builder_exploits.cpp
 * @brief Практические эксплойты для Builder паттерна
 * 
 * ⚠️  ТОЛЬКО ДЛЯ ОБРАЗОВАТЕЛЬНЫХ ЦЕЛЕЙ!
 */

// ============================================================================
// ЭКСПЛОЙТ 1: BUFFER OVERFLOW ДЛЯ ROP CHAIN
// Цель: Перезаписать return address через overflow
// ============================================================================

struct VulnerablePacket {
    char header[32];
    char data[64];
    void (*callback)();  // Function pointer - target для hijacking
    
    VulnerablePacket() : callback(nullptr) {}
};

class VulnerablePacketBuilder {
private:
    VulnerablePacket packet_;
    
public:
    VulnerablePacketBuilder& setHeader(const char* h) {
        strcpy(packet_.header, h);  // BUFFER OVERFLOW!
        return *this;
    }
    
    VulnerablePacketBuilder& setData(const char* d) {
        strcpy(packet_.data, d);  // BUFFER OVERFLOW!
        return *this;
    }
    
    VulnerablePacketBuilder& setCallback(void (*cb)()) {
        packet_.callback = cb;
        return *this;
    }
    
    VulnerablePacket build() { return packet_; }
};

void legitCallback() {
    std::cout << "✅ Легитимный callback\n";
}

void maliciousCallback() {
    std::cout << "🚨 ЭКСПЛОЙТ: Злонамеренный код выполнен!\n";
    std::cout << "🚨 В реальности здесь был бы shellcode\n";
}

void exploit_buffer_overflow_rop() {
    std::cout << "\n=== ЭКСПЛОЙТ 1: Buffer Overflow → ROP ===\n";
    
    VulnerablePacketBuilder builder;
    
    // Создаем overflow для перезаписи callback pointer
    char overflow[96];
    memset(overflow, 'A', 31);
    overflow[31] = '\0';
    
    std::cout << "1. Установка header (переполнение в data)...\n";
    builder.setHeader(overflow);
    
    // Еще один overflow для достижения callback
    char data_overflow[80];
    memset(data_overflow, 'B', 79);
    data_overflow[79] = '\0';
    
    std::cout << "2. Установка data (переполнение в callback)...\n";
    builder.setData(data_overflow);
    
    std::cout << "3. Установка легитимного callback...\n";
    builder.setCallback(legitCallback);
    
    auto packet = builder.build();
    
    std::cout << "4. Вызов callback (может быть перезаписан):\n";
    if (packet.callback) {
        packet.callback();
    }
    
    std::cout << "\n💡 Атакующий может:\n";
    std::cout << "   - Перезаписать function pointer через overflow\n";
    std::cout << "   - Перенаправить на свой код (ROP gadgets)\n";
    std::cout << "   - Получить выполнение произвольного кода\n";
}

// ============================================================================
// ЭКСПЛОЙТ 2: INTEGER OVERFLOW ДЛЯ HEAP SPRAY
// Цель: Создать маленький буфер вместо большого для heap corruption
// ============================================================================

class AllocatorBuilder {
private:
    size_t element_size_;
    size_t element_count_;
    
public:
    AllocatorBuilder& setElementSize(size_t size) {
        element_size_ = size;
        return *this;
    }
    
    AllocatorBuilder& setElementCount(size_t count) {
        element_count_ = count;
        return *this;
    }
    
    char* build() {
        // УЯЗВИМОСТЬ: Integer overflow
        size_t total = element_size_ * element_count_;
        
        if (total == 0) {
            std::cout << "⚠️  Integer overflow: total = 0\n";
            return nullptr;
        }
        
        std::cout << "Выделяем " << total << " байт...\n";
        return new char[total];  // Может выделить гораздо меньше!
    }
};

void exploit_integer_overflow_heap_spray() {
    std::cout << "\n=== ЭКСПЛОЙТ 2: Integer Overflow → Heap Spray ===\n";
    
    AllocatorBuilder builder;
    
    // Подбираем числа для overflow
    size_t max_size_t = std::numeric_limits<size_t>::max();
    size_t element_size = max_size_t / 2 + 1;
    size_t element_count = 2;
    
    std::cout << "Запрашиваем:\n";
    std::cout << "  Element size: " << element_size << "\n";
    std::cout << "  Element count: " << element_count << "\n";
    std::cout << "  Expected total: " << (element_size * element_count) << " (overflow!)\n";
    
    char* buffer = builder
        .setElementSize(element_size)
        .setElementCount(element_count)
        .build();
    
    if (buffer) {
        std::cout << "\n🚨 Выделен маленький буфер вместо огромного!\n";
        std::cout << "🚨 Последующая запись вызовет heap corruption\n";
        
        // В реальности здесь было бы:
        // memset(buffer, 0x41, element_size * element_count); // Heap overflow!
        
        delete[] buffer;
    }
    
    std::cout << "\n💡 Атакующий может:\n";
    std::cout << "   - Создать маленький буфер через overflow\n";
    std::cout << "   - Записать больше данных чем выделено\n";
    std::cout << "   - Перезаписать metadata кучи\n";
    std::cout << "   - Провести heap spray attack\n";
}

// ============================================================================
// ЭКСПЛОЙТ 3: VALIDATION BYPASS → PRIVILEGE ESCALATION
// Цель: Получить admin права через некорректный builder
// ============================================================================

struct Account {
    std::string username;
    bool is_admin;
    int credit_limit;
};

class BypassableAccountBuilder {
private:
    Account account_;
    
public:
    BypassableAccountBuilder() {
        account_.is_admin = false;
        account_.credit_limit = 100;
    }
    
    BypassableAccountBuilder& setUsername(const std::string& name) {
        account_.username = name;
        return *this;
    }
    
    BypassableAccountBuilder& setAdmin(bool admin) {
        // УЯЗВИМОСТЬ: Нет проверки прав!
        account_.is_admin = admin;
        return *this;
    }
    
    BypassableAccountBuilder& setCreditLimit(int limit) {
        // УЯЗВИМОСТЬ: Нет валидации!
        account_.credit_limit = limit;
        return *this;
    }
    
    Account build() {
        // Валидация только здесь - слишком поздно!
        if (account_.is_admin) {
            std::cout << "⚠️  Предупреждение: создан admin аккаунт\n";
        }
        return account_;
    }
};

void exploit_validation_bypass_privesc() {
    std::cout << "\n=== ЭКСПЛОЙТ 3: Validation Bypass → Privilege Escalation ===\n";
    
    BypassableAccountBuilder builder;
    
    std::cout << "Сценарий: Регистрация нового пользователя\n";
    std::cout << "Атакующий манипулирует запросом:\n\n";
    
    // АТАКА: Установка недопустимых значений
    auto account = builder
        .setUsername("attacker")
        .setAdmin(true)  // Обычный пользователь НЕ должен это устанавливать!
        .setCreditLimit(999999999)  // Огромный лимит!
        .build();
    
    std::cout << "\n🚨 Создан аккаунт:\n";
    std::cout << "   Username: " << account.username << "\n";
    std::cout << "   Admin: " << (account.is_admin ? "YES" : "NO") << "\n";
    std::cout << "   Credit Limit: $" << account.credit_limit << "\n";
    
    std::cout << "\n💡 Последствия:\n";
    std::cout << "   ✓ Получены права администратора\n";
    std::cout << "   ✓ Неограниченный кредитный лимит\n";
    std::cout << "   ✓ Полный доступ к системе\n";
}

// ============================================================================
// ЭКСПЛОЙТ 4: STATE POLLUTION → SESSION HIJACKING
// Цель: Украсть authentication токен через state pollution
// ============================================================================

struct HttpRequest {
    std::string url;
    std::vector<std::string> headers;
};

class StatefulRequestBuilder {
private:
    HttpRequest request_;
    
public:
    StatefulRequestBuilder& setUrl(const std::string& url) {
        request_.url = url;
        return *this;
    }
    
    StatefulRequestBuilder& addHeader(const std::string& header) {
        request_.headers.push_back(header);  // Накапливаются!
        return *this;
    }
    
    HttpRequest build() {
        // УЯЗВИМОСТЬ: Не очищает state!
        return request_;
    }
};

void exploit_state_pollution_session_hijack() {
    std::cout << "\n=== ЭКСПЛОЙТ 4: State Pollution → Session Hijacking ===\n";
    
    StatefulRequestBuilder builder;
    
    std::cout << "Сценарий: Shared builder в многопользовательском приложении\n\n";
    
    // Пользователь 1: Аутентифицированный запрос
    std::cout << "1. User1 создает запрос с auth токеном:\n";
    auto req1 = builder
        .setUrl("/api/user/profile")
        .addHeader("Authorization: Bearer USER1_SECRET_TOKEN")
        .build();
    
    for (const auto& h : req1.headers) {
        std::cout << "   " << h << "\n";
    }
    
    // Пользователь 2: Использует тот же builder
    std::cout << "\n2. User2 создает свой запрос:\n";
    auto req2 = builder
        .setUrl("/api/public/data")
        .build();
    
    std::cout << "   Headers в запросе User2:\n";
    for (const auto& h : req2.headers) {
        std::cout << "   " << h << "\n";  // УТЕК токен User1!
    }
    
    std::cout << "\n🚨 Токен User1 утек в запрос User2!\n";
    
    std::cout << "\n💡 Последствия:\n";
    std::cout << "   ✓ Session hijacking\n";
    std::cout << "   ✓ Unauthorized access к аккаунту User1\n";
    std::cout << "   ✓ Data breach\n";
}

// ============================================================================
// ЭКСПЛОЙТ 5: SQL INJECTION ЧЕРЕЗ BUILDER
// Цель: Провести SQL injection через параметры builder
// ============================================================================

struct SqlQuery {
    std::string table;
    std::string where_clause;
    
    std::string toSQL() const {
        return "SELECT * FROM " + table + " WHERE " + where_clause;
    }
};

class UnsafeQueryBuilder {
private:
    SqlQuery query_;
    
public:
    UnsafeQueryBuilder& from(const std::string& table) {
        query_.table = table;  // Нет санитизации!
        return *this;
    }
    
    UnsafeQueryBuilder& where(const std::string& condition) {
        query_.where_clause = condition;  // SQL INJECTION!
        return *this;
    }
    
    SqlQuery build() {
        return query_;
    }
};

void exploit_sql_injection() {
    std::cout << "\n=== ЭКСПЛОЙТ 5: SQL Injection через Builder ===\n";
    
    UnsafeQueryBuilder builder;
    
    std::cout << "Сценарий: API принимает параметры для построения SQL\n\n";
    
    // Легитимный запрос
    auto query1 = builder
        .from("users")
        .where("id = 1")
        .build();
    
    std::cout << "1. Легитимный SQL:\n   " << query1.toSQL() << "\n";
    
    // АТАКА: SQL Injection
    std::cout << "\n2. АТАКА: SQL Injection payload\n";
    
    UnsafeQueryBuilder evil_builder;
    auto query2 = evil_builder
        .from("users")
        .where("1=1; DROP TABLE users; --")
        .build();
    
    std::cout << "   Вредоносный SQL:\n   " << query2.toSQL() << "\n";
    
    std::cout << "\n🚨 SQL injection успешен!\n";
    
    std::cout << "\n💡 Последствия:\n";
    std::cout << "   ✓ Полный доступ к базе данных\n";
    std::cout << "   ✓ Удаление таблиц\n";
    std::cout << "   ✓ Exfiltration данных\n";
    std::cout << "   ✓ Authentication bypass\n";
}

// ============================================================================
// MAIN
// ============================================================================

int main() {
    std::cout << "=== ПРАКТИЧЕСКИЕ ЭКСПЛОЙТЫ BUILDER PATTERN ===\n";
    std::cout << "⚠️  ВНИМАНИЕ: Только для обучения!\n";
    
    try {
        exploit_buffer_overflow_rop();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    try {
        exploit_integer_overflow_heap_spray();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    try {
        exploit_validation_bypass_privesc();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    try {
        exploit_state_pollution_session_hijack();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    try {
        exploit_sql_injection();
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << "\n";
    }
    
    std::cout << "\n=== ЗАЩИТНЫЕ МЕРЫ ===\n";
    std::cout << "✅ Проверяйте длину перед strcpy (используйте strncpy)\n";
    std::cout << "✅ Проверяйте переполнение перед умножением\n";
    std::cout << "✅ Валидируйте в каждом setter, не только в build()\n";
    std::cout << "✅ Очищайте state после build()\n";
    std::cout << "✅ Параметризованные запросы вместо конкатенации\n";
    std::cout << "✅ Используйте std::string вместо char[]\n";
    
    return 0;
}
