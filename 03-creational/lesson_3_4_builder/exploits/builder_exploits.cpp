#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <cstring>

// ============================================================================
// ЭКСПЛОИТЫ ДЛЯ BUILDER
// ============================================================================

// TODO: Добавить комментарии на русском языке
// TODO: Создать более сложные эксплоиты
// TODO: Добавить обход защитных механизмов

// Уязвимый Builder для демонстрации
class VulnerableBuilder {
private:
    char* buffer;
    size_t bufferSize;
    size_t currentSize;
    
    VulnerableBuilder() : buffer(nullptr), bufferSize(0), currentSize(0) {
        std::cout << "VulnerableBuilder создан в потоке " << std::this_thread::get_id() << std::endl;
    }
    
public:
    static VulnerableBuilder& getInstance() {
        static VulnerableBuilder instance;
        return instance;
    }
    
    // УЯЗВИМОСТЬ: Buffer overflow при добавлении данных
    void addData(const char* data, size_t length) {
        if (currentSize + length > bufferSize) {
            bufferSize = currentSize + length;
            char* newBuffer = new char[bufferSize];
            if (buffer) {
                memcpy(newBuffer, buffer, currentSize);
                delete[] buffer;
            }
            buffer = newBuffer;
        }
        
        memcpy(buffer + currentSize, data, length);
        currentSize += length;
    }
    
    char* getBuffer() {
        return buffer;
    }
    
    size_t getSize() const {
        return currentSize;
    }
    
    ~VulnerableBuilder() {
        delete[] buffer;
        std::cout << "VulnerableBuilder уничтожен" << std::endl;
    }
};

// ============================================================================
// ЭКСПЛОИТ 1: BUFFER OVERFLOW ДЛЯ ПОЛУЧЕНИЯ КОНТРОЛЯ
// ============================================================================

void exploitBufferOverflow() {
    std::cout << "\n=== ЭКСПЛОИТ 1: BUFFER OVERFLOW ===" << std::endl;
    
    auto& builder = VulnerableBuilder::getInstance();
    
    // Создаем payload для переполнения буфера
    std::vector<char> payload(1000);
    
    // Заполняем payload полезной нагрузкой
    for (size_t i = 0; i < payload.size(); ++i) {
        payload[i] = 'A' + (i % 26);
    }
    
    // УЯЗВИМОСТЬ: Добавляем данные, которые могут вызвать переполнение
    builder.addData(payload.data(), payload.size());
    
    std::cout << "Добавлены данные размером: " << payload.size() << std::endl;
    std::cout << "Текущий размер буфера: " << builder.getSize() << std::endl;
    
    // Попытка получить доступ к буферу
    char* buffer = builder.getBuffer();
    if (buffer) {
        std::cout << "Получен доступ к буферу" << std::endl;
        std::cout << "Первые 50 символов: ";
        for (int i = 0; i < 50 && i < builder.getSize(); ++i) {
            std::cout << buffer[i];
        }
        std::cout << std::endl;
    }
}

// ============================================================================
// ЭКСПЛОИТ 2: MEMORY CORRUPTION ЧЕРЕЗ USE-AFTER-FREE
// ============================================================================

class CorruptibleBuilder {
private:
    char* data;
    bool isBuilt;
    
public:
    CorruptibleBuilder() : data(nullptr), isBuilt(false) {
        std::cout << "CorruptibleBuilder создан" << std::endl;
    }
    
    void build() {
        if (!isBuilt) {
            data = new char[1024];
            strcpy(data, "Built object data");
            isBuilt = true;
        }
    }
    
    void reset() {
        delete[] data;
        data = nullptr;
        isBuilt = false;
    }
    
    char* getData() {
        return data;
    }
    
    ~CorruptibleBuilder() {
        delete[] data;
        std::cout << "CorruptibleBuilder уничтожен" << std::endl;
    }
};

void exploitUseAfterFree() {
    std::cout << "\n=== ЭКСПЛОИТ 2: USE-AFTER-FREE ===" << std::endl;
    
    CorruptibleBuilder builder;
    
    // Строим объект
    builder.build();
    std::cout << "Объект построен" << std::endl;
    
    // Сбрасываем состояние
    builder.reset();
    std::cout << "Состояние сброшено" << std::endl;
    
    // УЯЗВИМОСТЬ: Попытка использовать после сброса
    char* data = builder.getData();
    if (data) {
        std::cout << "Данные доступны: " << data << std::endl;
        std::cout << "ЭКСПЛОИТ УСПЕШЕН!" << std::endl;
    } else {
        std::cout << "Данные недоступны" << std::endl;
    }
}

// ============================================================================
// ЭКСПЛОИТ 3: INTEGER OVERFLOW ДЛЯ ОБХОДА ПРОВЕРОК
// ============================================================================

void exploitIntegerOverflow() {
    std::cout << "\n=== ЭКСПЛОИТ 3: INTEGER OVERFLOW ===" << std::endl;
    
    auto& builder = VulnerableBuilder::getInstance();
    
    // УЯЗВИМОСТЬ: Integer overflow
    size_t largeSize = SIZE_MAX - 100;
    
    std::cout << "Попытка добавить данные размером: " << largeSize << std::endl;
    
    // Создаем данные для overflow
    std::vector<char> overflowData(1000);
    std::fill(overflowData.begin(), overflowData.end(), 'X');
    
    // Попытка вызвать overflow
    try {
        builder.addData(overflowData.data(), largeSize);
        std::cout << "Данные добавлены (возможно из-за overflow)" << std::endl;
    } catch (...) {
        std::cout << "Произошло исключение при добавлении данных" << std::endl;
    }
    
    std::cout << "Текущий размер буфера: " << builder.getSize() << std::endl;
}

// ============================================================================
// ЭКСПЛОИТ 4: RESOURCE EXHAUSTION АТАКА
// ============================================================================

void exploitResourceExhaustion() {
    std::cout << "\n=== ЭКСПЛОИТ 4: RESOURCE EXHAUSTION ===" << std::endl;
    
    auto& builder = VulnerableBuilder::getInstance();
    
    // Попытка исчерпать память
    for (int i = 0; i < 100; ++i) {
        std::string largeData(100000, 'A' + (i % 26));
        
        try {
            builder.addData(largeData.c_str(), largeData.length());
            std::cout << "Добавлены данные итерация " << i << std::endl;
        } catch (const std::bad_alloc& e) {
            std::cout << "Память исчерпана на итерации " << i << std::endl;
            std::cout << "ЭКСПЛОИТ УСПЕШЕН - DoS достигнут!" << std::endl;
            break;
        }
    }
    
    std::cout << "Финальный размер буфера: " << builder.getSize() << std::endl;
}

// ============================================================================
// ОСНОВНАЯ ФУНКЦИЯ
// ============================================================================

int main() {
    std::cout << "=== ДЕМОНСТРАЦИЯ ЭКСПЛОИТОВ ДЛЯ BUILDER ===" << std::endl;
    std::cout << "ВНИМАНИЕ: Этот код содержит эксплоиты для образовательных целей!" << std::endl;
    
    // Запуск различных эксплоитов
    exploitBufferOverflow();
    exploitUseAfterFree();
    exploitIntegerOverflow();
    exploitResourceExhaustion();
    
    std::cout << "\n=== РЕКОМЕНДАЦИИ ПО ЗАЩИТЕ ===" << std::endl;
    std::cout << "1. Используйте std::vector и std::string вместо сырых указателей" << std::endl;
    std::cout << "2. Проверяйте размеры перед операциями с памятью" << std::endl;
    std::cout << "3. Применяйте RAII для управления ресурсами" << std::endl;
    std::cout << "4. Валидируйте входные данные" << std::endl;
    std::cout << "5. Используйте умные указатели" << std::endl;
    std::cout << "6. Регулярно анализируйте код с помощью инструментов безопасности" << std::endl;
    
    return 0;
}