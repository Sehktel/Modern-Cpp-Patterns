# üõ°Ô∏è Security Poster: Builder Pattern

## üéØ –û–±–∑–æ—Ä —É–≥—Ä–æ–∑ Builder Pattern

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –£–Ø–ó–í–ò–ú–û–°–¢–ò BUILDER PATTERN               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üî¥ –ö–†–ò–¢–ò–ß–ù–´–ï –£–ì–†–û–ó–´:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Buffer Overflow     ‚îÇ CWE-120: Unchecked string building           ‚îÇ
‚îÇ                     ‚îÇ Impact: Heap overflow, RCE                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Integer Overflow    ‚îÇ CWE-190: Size calculation overflow          ‚îÇ
‚îÇ                     ‚îÇ Impact: Buffer overflow, memory corruption   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ State Corruption    ‚îÇ Invalid build sequence                       ‚îÇ
‚îÇ                     ‚îÇ Impact: Inconsistent object state, crashes   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üü° –í–´–°–û–ö–ò–ï –£–ì–†–û–ó–´:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Memory Leaks        ‚îÇ CWE-401: Exception during build              ‚îÇ
‚îÇ Incomplete Objects  ‚îÇ Missing required parameters                  ‚îÇ
‚îÇ SQL Injection       ‚îÇ Query builder –±–µ–∑ sanitization               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üí£ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —É—è–∑–≤–∏–º–æ—Å—Ç—å #1: Buffer Overflow –≤ String Building

### –ê–Ω–∞—Ç–æ–º–∏—è –∞—Ç–∞–∫–∏

```cpp
// ‚ùå –£–Ø–ó–í–ò–ú–´–ô –ö–û–î - Unchecked string concatenation
class VulnerableBuilder {
private:
    char buffer_[1024];  // ‚ö†Ô∏è Fixed size buffer
    size_t pos_ = 0;
    
public:
    VulnerableBuilder& addString(const std::string& str) {
        // ‚ö†Ô∏è No bounds checking!
        strcpy(buffer_ + pos_, str.c_str());  // üí• Buffer overflow!
        pos_ += str.length();
        return *this;
    }
    
    std::string build() {
        return std::string(buffer_, pos_);
    }
};
```

### üéØ Exploitation: Heap overflow

```cpp
// –≠–ö–°–ü–õ–û–ô–¢: Buffer overflow attack
void exploit_buffer_overflow() {
    VulnerableBuilder builder;
    
    // –ê–¢–ê–ö–ê: Overflow buffer —Å large input
    std::string payload(2000, 'A');  // 2000 > 1024
    payload += "\xef\xbe\xad\xde";   // Overwrite return address
    
    builder.addString(payload);  // üí• Buffer overflow!
    
    // –ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è:
    // 1. buffer_ overflows –Ω–∞ stack
    // 2. –ü–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç return address
    // 3. –ü—Ä–∏ return ‚Üí –ø–µ—Ä–µ—Ö–æ–¥ –Ω–∞ 0xdeadbeef
    // 4. RCE
}

// –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π exploit: Heap overflow
class HeapBuilder {
    char* buffer_;  // ‚ö†Ô∏è Heap allocated –Ω–æ fixed size
    size_t capacity_ = 1024;
    size_t pos_ = 0;
    
public:
    HeapBuilder() { buffer_ = new char[capacity_]; }
    
    HeapBuilder& addString(const std::string& str) {
        memcpy(buffer_ + pos_, str.data(), str.length());  // üí• No check!
        pos_ += str.length();
        return *this;
    }
};

void exploit_heap_overflow() {
    HeapBuilder builder;
    
    // Overflow heap buffer
    builder.addString(std::string(2000, 'A'));
    // üí• Overflows –Ω–∞ adjacent heap chunks
    // ‚Üí Heap metadata corruption
    // ‚Üí Control over allocator
    // ‚Üí RCE
}
```

### ‚úÖ –ó–∞—â–∏—Ç–∞: Dynamic buffer —Å bounds checking

```cpp
// ‚úÖ –ë–ï–ó–û–ü–ê–°–ù–´–ô –ö–û–î - Dynamic growth —Å validation
class SecureBuilder {
private:
    std::vector<char> buffer_;  // ‚úÖ Dynamic size
    const size_t MAX_SIZE = 10 * 1024 * 1024;  // 10MB limit
    
public:
    SecureBuilder& addString(const std::string& str) {
        // ‚úÖ Validate size
        if (str.length() > MAX_SIZE) {
            throw std::invalid_argument("String too large");
        }
        
        // ‚úÖ Check total size
        if (buffer_.size() + str.length() > MAX_SIZE) {
            throw std::runtime_error("Builder size limit exceeded");
        }
        
        // ‚úÖ Check for overflow
        if (buffer_.size() > SIZE_MAX - str.length()) {
            throw std::overflow_error("Size calculation overflow");
        }
        
        // ‚úÖ Safe append
        buffer_.insert(buffer_.end(), str.begin(), str.end());
        return *this;
    }
    
    std::string build() {
        return std::string(buffer_.begin(), buffer_.end());
    }
};

// –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞: std::stringstream (–µ—â–µ –ø—Ä–æ—â–µ)
class SimpleBuilder {
    std::stringstream ss_;
    size_t size_ = 0;
    const size_t MAX_SIZE = 10 * 1024 * 1024;
    
public:
    SimpleBuilder& add(const std::string& str) {
        if (size_ + str.length() > MAX_SIZE) {
            throw std::runtime_error("Size limit exceeded");
        }
        
        ss_ << str;
        size_ += str.length();
        return *this;
    }
    
    std::string build() { return ss_.str(); }
};
```

## üí£ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —É—è–∑–≤–∏–º–æ—Å—Ç—å #2: Integer Overflow –≤ Size Calculation

### –ê–Ω–∞—Ç–æ–º–∏—è –∞—Ç–∞–∫–∏

```cpp
// ‚ùå –£–Ø–ó–í–ò–ú–´–ô –ö–û–î - Integer overflow –≤ allocation
class AllocatingBuilder {
public:
    struct Config {
        size_t item_count;
        size_t item_size;
    };
    
    char* build(const Config& config) {
        // ‚ö†Ô∏è Integer overflow!
        size_t total_size = config.item_count * config.item_size;
        
        char* buffer = new char[total_size];  // üí• May allocate small buffer!
        // Fill buffer...
        return buffer;
    }
};
```

### üéØ Exploitation: Integer overflow ‚Üí heap overflow

```cpp
// –≠–ö–°–ü–õ–û–ô–¢: Integer overflow attack
void exploit_integer_overflow() {
    AllocatingBuilder builder;
    
    // –ê–¢–ê–ö–ê: Trigger integer overflow
    AllocatingBuilder::Config malicious_config;
    malicious_config.item_count = SIZE_MAX / 2 + 1;  // Large value
    malicious_config.item_size = 4;                  // Small multiplier
    
    // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ:
    // total_size = (SIZE_MAX/2 + 1) * 4
    //            = SIZE_MAX/2*4 + 4
    //            = SIZE_MAX*2 + 4
    //            ‚Üí Overflow! –†–µ–∑—É–ª—å—Ç–∞—Ç: –æ—á–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–æ–µ —á–∏—Å–ª–æ
    
    char* buffer = builder.build(malicious_config);
    // üí• Allocated small buffer (–Ω–∞–ø—Ä–∏–º–µ—Ä, 8 bytes)
    // –ù–æ code –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç —á—Ç–æ buffer –±–æ–ª—å—à–æ–π
    // ‚Üí Heap overflow –ø—Ä–∏ filling
}
```

### ‚úÖ –ó–∞—â–∏—Ç–∞: Overflow-safe arithmetic

```cpp
// ‚úÖ –ë–ï–ó–û–ü–ê–°–ù–´–ô –ö–û–î - Overflow checking
class SecureAllocatingBuilder {
public:
    struct Config {
        size_t item_count;
        size_t item_size;
    };
    
    std::unique_ptr<char[]> build(const Config& config) {
        // ‚úÖ Validate inputs
        if (config.item_count == 0 || config.item_size == 0) {
            throw std::invalid_argument("Invalid config");
        }
        
        // ‚úÖ Check for multiplication overflow
        if (config.item_count > SIZE_MAX / config.item_size) {
            throw std::overflow_error(
                "Size calculation would overflow: " +
                std::to_string(config.item_count) + " * " +
                std::to_string(config.item_size)
            );
        }
        
        size_t total_size = config.item_count * config.item_size;
        
        // ‚úÖ Additional limit check
        const size_t MAX_ALLOCATION = 100 * 1024 * 1024;  // 100MB
        if (total_size > MAX_ALLOCATION) {
            throw std::runtime_error("Allocation size exceeds limit");
        }
        
        // ‚úÖ Safe allocation
        return std::make_unique<char[]>(total_size);
    }
};

// C++20: std::cmp_* –¥–ª—è safe comparisons
bool safe_multiply(size_t a, size_t b, size_t& result) {
    if (a == 0 || b == 0) {
        result = 0;
        return true;
    }
    
    if (a > SIZE_MAX / b) {
        return false;  // Overflow would occur
    }
    
    result = a * b;
    return true;
}
```

## üí£ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —É—è–∑–≤–∏–º–æ—Å—Ç—å #3: SQL Injection –≤ Query Builder

### –ê–Ω–∞—Ç–æ–º–∏—è –∞—Ç–∞–∫–∏

```cpp
// ‚ùå –£–Ø–ó–í–ò–ú–´–ô –ö–û–î - SQL query builder –±–µ–∑ sanitization
class VulnerableSQLBuilder {
private:
    std::string query_;
    
public:
    VulnerableSQLBuilder& select(const std::string& columns) {
        query_ = "SELECT " + columns + " ";  // ‚ö†Ô∏è No sanitization!
        return *this;
    }
    
    VulnerableSQLBuilder& from(const std::string& table) {
        query_ += "FROM " + table + " ";  // ‚ö†Ô∏è No sanitization!
        return *this;
    }
    
    VulnerableSQLBuilder& where(const std::string& condition) {
        query_ += "WHERE " + condition;  // ‚ö†Ô∏è No sanitization!
        return *this;
    }
    
    std::string build() { return query_; }
};
```

### üéØ Exploitation: SQL injection

```cpp
// –≠–ö–°–ü–õ–û–ô–¢: SQL injection attack
void exploit_sql_injection() {
    VulnerableSQLBuilder builder;
    
    // –õ–µ–≥–∏—Ç–∏–º–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
    // SELECT * FROM users WHERE id = 1
    
    // –ê–¢–ê–ö–ê: Malicious input
    std::string malicious_condition = "1=1 OR '1'='1"; // Always true
    
    std::string query = builder
        .select("*")
        .from("users")
        .where(malicious_condition)
        .build();
    
    // –†–µ–∑—É–ª—å—Ç–∞—Ç: "SELECT * FROM users WHERE 1=1 OR '1'='1"
    // ‚Üí Returns ALL users (auth bypass!)
    
    // –ë–æ–ª–µ–µ –æ–ø–∞—Å–Ω–∞—è –∞—Ç–∞–∫–∞:
    std::string drop_table = "1=1; DROP TABLE users; --";
    
    query = builder
        .select("*")
        .from("users")
        .where(drop_table)
        .build();
    
    // –†–µ–∑—É–ª—å—Ç–∞—Ç: "SELECT * FROM users WHERE 1=1; DROP TABLE users; --"
    // ‚Üí Executes TWO queries:
    //   1. SELECT * FROM users WHERE 1=1
    //   2. DROP TABLE users
    // üí• Database destroyed!
}
```

### ‚úÖ –ó–∞—â–∏—Ç–∞: Parameterized queries

```cpp
// ‚úÖ –ë–ï–ó–û–ü–ê–°–ù–´–ô –ö–û–î - Parameterized query builder
class SecureSQLBuilder {
private:
    std::string query_;
    std::vector<std::string> params_;
    int param_index_ = 0;
    
public:
    SecureSQLBuilder& select(const std::vector<std::string>& columns) {
        // ‚úÖ Whitelist validation –¥–ª—è column names
        for (const auto& col : columns) {
            if (!isValidIdentifier(col)) {
                throw std::invalid_argument("Invalid column name: " + col);
            }
        }
        
        query_ = "SELECT " + join(columns, ", ") + " ";
        return *this;
    }
    
    SecureSQLBuilder& from(const std::string& table) {
        // ‚úÖ Whitelist validation
        if (!isValidIdentifier(table)) {
            throw std::invalid_argument("Invalid table name: " + table);
        }
        
        query_ += "FROM " + table + " ";
        return *this;
    }
    
    SecureSQLBuilder& where(const std::string& column, 
                           const std::string& value) {
        // ‚úÖ Column name validation
        if (!isValidIdentifier(column)) {
            throw std::invalid_argument("Invalid column name: " + column);
        }
        
        // ‚úÖ Value –∫–∞–∫ parameter (–ù–ï concatenated!)
        query_ += "WHERE " + column + " = $" + std::to_string(++param_index_) + " ";
        params_.push_back(value);
        
        return *this;
    }
    
    std::pair<std::string, std::vector<std::string>> build() {
        return {query_, params_};
    }
    
private:
    static bool isValidIdentifier(const std::string& id) {
        // ‚úÖ Allow —Ç–æ–ª—å–∫–æ alphanumeric + underscore
        static const std::regex valid_id_regex("^[a-zA-Z_][a-zA-Z0-9_]*$");
        return std::regex_match(id, valid_id_regex);
    }
};

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
auto [query, params] = SecureSQLBuilder()
    .select({"id", "name", "email"})
    .from("users")
    .where("id", user_input)  // ‚úÖ user_input –∫–∞–∫ parameter
    .build();

// Execute —Å parameterized query:
// query = "SELECT id, name, email FROM users WHERE id = $1"
// params = {user_input}
// ‚Üí SQL engine treats user_input as DATA, –Ω–µ CODE
// ‚Üí No injection possible!
```

## üõ†Ô∏è –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è

### 1. ASan - Buffer Overflow Detection

```bash
g++ -fsanitize=address -g builder_vulnerabilities.cpp -o builder_asan

./builder_asan
```

**–í—ã–≤–æ–¥ ASan**:
```
=================================================================
==12345==ERROR: AddressSanitizer: heap-buffer-overflow
WRITE of size 2000 at 0x602000000010 thread T0
    #0 0x400b12 in VulnerableBuilder::addString() builder.cpp:45
```

### 2. Static Analysis - Buffer Overflow

```bash
clang-tidy builder_vulnerabilities.cpp \
    -checks='clang-analyzer-security.insecureAPI.strcpy'

# Warning: Call to function 'strcpy' is insecure
```

### 3. UBSan - Integer Overflow Detection

```bash
g++ -fsanitize=undefined -g builder_vulnerabilities.cpp -o builder_ubsan

./builder_ubsan
```

**–í—ã–≤–æ–¥ UBSan**:
```
builder.cpp:67:23: runtime error: unsigned integer overflow:
18446744073709551615 * 4 cannot be represented in type 'unsigned long'
```

## üìã Security Checklist –¥–ª—è Builder Pattern

### Design Phase
```
[ ] –û–ø—Ä–µ–¥–µ–ª–µ–Ω maximum size –¥–ª—è built objects
[ ] –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω—ã required vs optional parameters
[ ] –†–∞—Å—Å–º–æ—Ç—Ä–µ–Ω—ã injection risks (SQL, command, etc.)
[ ] –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ validation strategy
```

### Implementation Phase
```
[ ] Dynamic buffers (std::vector, std::string) –≤–º–µ—Å—Ç–æ fixed
[ ] Overflow checking –¥–ª—è size calculations
[ ] Bounds checking –¥–ª—è all append operations
[ ] Input sanitization (whitelist –¥–ª—è identifiers)
[ ] Parameterized output (–¥–ª—è SQL, commands)
[ ] Exception-safe building
```

### Testing Phase
```
[ ] Buffer overflow tests —Å ASan
[ ] Integer overflow tests —Å UBSan
[ ] Injection tests (malformed input)
[ ] Size limit tests
[ ] Incomplete object tests
[ ] Exception safety tests
```

### Deployment Phase
```
[ ] Monitoring –¥–ª—è builder size anomalies
[ ] Logging –¥–ª—è large builds
[ ] Rate limiting –¥–ª—è builder usage
```

## üéì Best Practices

### 1. Fluent Builder —Å Validation

```cpp
// ‚úÖ Builder —Å step-by-step validation
class ValidatedBuilder {
    std::stringstream ss_;
    bool header_set_ = false;
    bool body_set_ = false;
    
public:
    ValidatedBuilder& setHeader(const std::string& header) {
        if (header.empty()) {
            throw std::invalid_argument("Header cannot be empty");
        }
        ss_ << "Header: " << header << "\n";
        header_set_ = true;
        return *this;
    }
    
    ValidatedBuilder& setBody(const std::string& body) {
        if (!header_set_) {
            throw std::logic_error("Must set header before body");
        }
        ss_ << "Body: " << body << "\n";
        body_set_ = true;
        return *this;
    }
    
    std::string build() {
        if (!header_set_ || !body_set_) {
            throw std::logic_error("Incomplete object");
        }
        return ss_.str();
    }
};
```

### 2. Type-Safe Builder (Builder Pattern + Type State)

```cpp
// ‚úÖ Compile-time validation —Å type states
template<bool HasHeader, bool HasBody>
class TypedBuilder;

template<>
class TypedBuilder<false, false> {
    std::string data_;
    
public:
    TypedBuilder<true, false> setHeader(const std::string& h) {
        TypedBuilder<true, false> next;
        next.data_ = "Header: " + h + "\n";
        return next;
    }
    
    // ‚ùå setBody() –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (compile error)
    // ‚ùå build() –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (compile error)
};

template<>
class TypedBuilder<true, false> {
    std::string data_;
    
public:
    TypedBuilder<true, true> setBody(const std::string& b) {
        TypedBuilder<true, true> next;
        next.data_ = data_ + "Body: " + b + "\n";
        return next;
    }
    
    // ‚ùå build() –µ—â–µ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
};

template<>
class TypedBuilder<true, true> {
    std::string data_;
    
public:
    std::string build() {  // ‚úÖ –¢–æ–ª—å–∫–æ –∑–¥–µ—Å—å –¥–æ—Å—Ç—É–ø–µ–Ω build()
        return data_;
    }
};

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
auto result = TypedBuilder<false, false>()
    .setHeader("Hello")  // ‚úÖ OK
    .setBody("World")    // ‚úÖ OK
    .build();            // ‚úÖ OK

// auto bad = TypedBuilder<false, false>().build();  // ‚ùå Compile error!
```

## üí° –ó–æ–ª–æ—Ç–æ–µ –ø—Ä–∞–≤–∏–ª–æ Builder Security

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                                ‚îÇ
‚îÇ  "Builder accumulates data - validate EVERY input.            ‚îÇ
‚îÇ   Use dynamic buffers —Å bounds checking.                      ‚îÇ
‚îÇ   Check for integer overflow –≤ size calculations.             ‚îÇ
‚îÇ   Sanitize/parameterize output (SQL, commands)."              ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ fixed-size buffers.                  ‚îÇ
‚îÇ  –í—Å–µ–≥–¥–∞ validate accumulated size.                           ‚îÇ
‚îÇ  Parameterize, don't concatenate (SQL, shell commands).       ‚îÇ
‚îÇ                                                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

**–í–µ—Ä—Å–∏—è**: 1.0  
**–î–∞—Ç–∞**: 2025-10-11  
**–ö—É—Ä—Å**: Patterns (Security Integration Track)  
**–õ–∏—Ü–µ–Ω–∑–∏—è**: MIT

