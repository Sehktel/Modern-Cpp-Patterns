#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <cstring>

// ============================================================================
// ЭКСПЛОИТЫ ДЛЯ УЯЗВИМОСТЕЙ В SINGLETON
// ============================================================================
//
// Этот файл демонстрирует практические эксплоиты для уязвимостей Singleton:
// 1. Race Condition Exploit - получение множественных экземпляров
// 2. Memory Exhaustion (DoS) - утечки памяти для crash системы
// 3. Use-After-Free Exploit - использование после уничтожения
// 4. Timing Attack - определение состояния через измерение времени
//
// ЗАПУСК:
// g++ -std=c++17 -pthread singleton_exploits.cpp -o singleton_exploits
// ./singleton_exploits
//
// ⚠️ ВНИМАНИЕ: Эти эксплоиты предназначены ТОЛЬКО для обучения!
//              Использование на production системах БЕЗ разрешения НЕЗАКОННО!
// ============================================================================

// Уязвимый Singleton для демонстрации
class VulnerableSingleton {
private:
    static VulnerableSingleton* instance;
    char* adminPassword;
    bool isAdmin;
    int userLevel;
    
    VulnerableSingleton() : adminPassword(nullptr), isAdmin(false), userLevel(0) {
        // УЯЗВИМОСТЬ: Race condition при инициализации
        std::cout << "VulnerableSingleton создан в потоке " << std::this_thread::get_id() << std::endl;
        
        // Имитация медленной инициализации
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        
        adminPassword = new char[256];
        strcpy(adminPassword, "super_secret_password_123");
        isAdmin = true;
        userLevel = 999;
    }
    
public:
    static VulnerableSingleton* getInstance() {
        // УЯЗВИМОСТЬ: Отсутствие синхронизации
        if (instance == nullptr) {
            instance = new VulnerableSingleton();
        }
        return instance;
    }
    
    // Методы для демонстрации привилегий
    bool checkAdminAccess(const char* password) {
        if (isAdmin && strcmp(password, adminPassword) == 0) {
            return true;
        }
        return false;
    }
    
    int getUserLevel() const { return userLevel; }
    bool isAdminUser() const { return isAdmin; }
    
    // Метод для демонстрации уязвимости
    void performAdminAction() {
        if (isAdmin) {
            std::cout << "Выполняется административное действие!" << std::endl;
            std::cout << "Уровень пользователя: " << userLevel << std::endl;
        } else {
            std::cout << "Доступ запрещен!" << std::endl;
        }
    }
    
    ~VulnerableSingleton() {
        delete[] adminPassword;
        std::cout << "VulnerableSingleton уничтожен" << std::endl;
    }
};

VulnerableSingleton* VulnerableSingleton::instance = nullptr;

// ============================================================================
// ЭКСПЛОИТ 1: RACE CONDITION ДЛЯ ПОЛУЧЕНИЯ ПРИВИЛЕГИЙ
// ============================================================================

void exploitRaceCondition() {
    std::cout << "\n=== ЭКСПЛОИТ 1: RACE CONDITION ===" << std::endl;
    
    std::vector<std::thread> threads;
    
    // Создаем несколько потоков, которые одновременно обращаются к Singleton
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back([i]() {
            // Небольшая задержка для увеличения вероятности race condition
            std::this_thread::sleep_for(std::chrono::milliseconds(i * 10));
            
            auto instance = VulnerableSingleton::getInstance();
            
            std::cout << "Поток " << i << " получил доступ к Singleton" << std::endl;
            std::cout << "  - Администратор: " << (instance->isAdminUser() ? "Да" : "Нет") << std::endl;
            std::cout << "  - Уровень пользователя: " << instance->getUserLevel() << std::endl;
            
            // Попытка выполнить административное действие
            instance->performAdminAction();
        });
    }
    
    for (auto& thread : threads) {
        thread.join();
    }
}

// ============================================================================
// ЭКСПЛОИТ 2: USE-AFTER-FREE
// ============================================================================

void exploitUseAfterFree() {
    std::cout << "\n=== ЭКСПЛОИТ 2: USE-AFTER-FREE ===" << std::endl;
    
    // Получаем экземпляр Singleton
    auto instance = VulnerableSingleton::getInstance();
    
    std::cout << "Получен экземпляр Singleton" << std::endl;
    std::cout << "Администратор: " << (instance->isAdminUser() ? "Да" : "Нет") << std::endl;
    
    // УЯЗВИМОСТЬ: В реальном коде объект может быть уничтожен
    // в другом потоке или через другой механизм
    
    // Симулируем использование после освобождения
    std::cout << "Попытка использования после потенциального освобождения..." << std::endl;
    
    // В реальном эксплоите здесь может произойти crash или
    // получение доступа к уже освобожденной памяти
    try {
        instance->performAdminAction();
        std::cout << "Эксплоит успешен!" << std::endl;
    } catch (...) {
        std::cout << "Произошла ошибка при использовании после освобождения" << std::endl;
    }
}

// ============================================================================
// ЭКСПЛОИТ 3: MEMORY CORRUPTION ЧЕРЕЗ INTEGER OVERFLOW
// ============================================================================

class CorruptibleSingleton {
private:
    static CorruptibleSingleton* instance;
    int* data;
    size_t size;
    
    CorruptibleSingleton() : size(1000) {
        data = new int[size];
        for (size_t i = 0; i < size; ++i) {
            data[i] = i;
        }
        std::cout << "CorruptibleSingleton создан" << std::endl;
    }
    
public:
    static CorruptibleSingleton* getInstance() {
        if (instance == nullptr) {
            instance = new CorruptibleSingleton();
        }
        return instance;
    }
    
    // УЯЗВИМОСТЬ: Integer overflow может привести к buffer overflow
    void setData(size_t index, int value) {
        if (index < size) {  // Проверка может быть обойдена при overflow
            data[index] = value;
        }
    }
    
    int getData(size_t index) {
        if (index < size) {
            return data[index];
        }
        return -1;
    }
    
    // УЯЗВИМОСТЬ: Возврат указателя на внутренние данные
    int* getDataPointer() {
        return data;
    }
    
    ~CorruptibleSingleton() {
        delete[] data;
        std::cout << "CorruptibleSingleton уничтожен" << std::endl;
    }
};

CorruptibleSingleton* CorruptibleSingleton::instance = nullptr;

void exploitIntegerOverflow() {
    std::cout << "\n=== ЭКСПЛОИТ 3: INTEGER OVERFLOW ===" << std::endl;
    
    auto instance = CorruptibleSingleton::getInstance();
    
    // Нормальное использование
    instance->setData(100, 999);
    std::cout << "Нормальное значение: " << instance->getData(100) << std::endl;
    
    // УЯЗВИМОСТЬ: Integer overflow
    size_t largeIndex = SIZE_MAX - 100;  // Очень большое число
    std::cout << "Попытка использования индекса: " << largeIndex << std::endl;
    
    // При overflow проверка может быть обойдена
    instance->setData(largeIndex, 0x41414141);  // 'AAAA'
    
    std::cout << "Попытка чтения по переполненному индексу..." << std::endl;
    int value = instance->getData(largeIndex);
    std::cout << "Прочитанное значение: " << std::hex << value << std::dec << std::endl;
}

// ============================================================================
// ЭКСПЛОИТ 4: SIDE CHANNEL ATTACK
// ============================================================================

void exploitSideChannel() {
    std::cout << "\n=== ЭКСПЛОИТ 4: SIDE CHANNEL ATTACK ===" << std::endl;
    
    auto instance = VulnerableSingleton::getInstance();
    
    // Timing attack на проверку пароля
    const char* passwords[] = {
        "wrong_password",
        "admin",
        "password",
        "super_secret_password_123",
        "root"
    };
    
    std::cout << "Проведение timing attack на проверку пароля..." << std::endl;
    
    for (const char* password : passwords) {
        auto start = std::chrono::high_resolution_clock::now();
        
        bool result = instance->checkAdminAccess(password);
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
        
        std::cout << "Пароль: " << password 
                  << ", Результат: " << (result ? "Успех" : "Неудача")
                  << ", Время: " << duration.count() << " мкс" << std::endl;
        
        if (result) {
            std::cout << "ЭКСПЛОИТ УСПЕШЕН! Найден правильный пароль!" << std::endl;
            break;
        }
    }
}

// ============================================================================
// ОСНОВНАЯ ФУНКЦИЯ
// ============================================================================

int main() {
    std::cout << "=== ДЕМОНСТРАЦИЯ ЭКСПЛОИТОВ ДЛЯ SINGLETON ===" << std::endl;
    std::cout << "ВНИМАНИЕ: Этот код содержит эксплоиты для образовательных целей!" << std::endl;
    
    // Запуск различных эксплоитов
    exploitRaceCondition();
    exploitUseAfterFree();
    exploitIntegerOverflow();
    exploitSideChannel();
    
    std::cout << "\n=== РЕКОМЕНДАЦИИ ПО ЗАЩИТЕ ===" << std::endl;
    std::cout << "1. Используйте std::call_once для thread-safe инициализации" << std::endl;
    std::cout << "2. Применяйте RAII для управления ресурсами" << std::endl;
    std::cout << "3. Проверяйте размеры перед операциями с памятью" << std::endl;
    std::cout << "4. Используйте постоянное время для криптографических операций" << std::endl;
    std::cout << "5. Регулярно анализируйте код с помощью инструментов безопасности" << std::endl;
    
    return 0;
}

